#!/usr/bin/env python
"""cloud-checkr-verify
===================
IAM boto:
In this script we create a cloudcheckr group, IAM user, and Policy that 
provides access to cloudcheckr.
"""

# errors:list - a global list of errors to display to the user.  This prevents
# them from having to correct one issue at a time, they can get a nice little
# list of everything that is wrong, correct all of it at once, and re-run this
# program
errors=[]

#
# Built-In
#
import cStringIO
import fcntl
import os
import optparse
import subprocess
from subprocess import Popen, PIPE, STDOUT
from pprint import pprint
import sys
import time

# 
# Internal
#
try:
	#import pytis as PyTis # Shared GPL/PPL License
	#import pytis as PyTis # Shared GPL/PPL License
	import pytis3 as PyTis # Shared GPL/PPL License
	from pylib import configobj as COBJ
except ImportError as e:
	print("This program requires the PyTis python library to run.")
	print("You may download the PyTis library, or do an SVN checkout from:")
	print("<https://sourceforge.net/projects/pytis/>")
	print("This program should be installed in the bin directory of the PyTis library.")
	sys.exit(1)


#
# Third-Party
#
try:
	import boto
	import boto.cloudtrail
	import boto.exception
except ImportError as e:
	errors.append("This program requires python-boto " \
	"<https://github.com/boto/boto>.\nPlease ask your administrator for " \
	"assistance.")


__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee and Bernard Constantino'
__created__ = '05:25pm 06 Jun, 2015'
__copyright__ = 'Booz Allen Hamilton'
__version__ = '0'

def create_sid():
	def name():
		if len(sys.argv) <= 1:
			if not sys.argv[0].strip():
				return 'Python Cli'
		prog = os.path.basename(sys.argv[0].strip())
		return prog.replace('-',' ').title().replace(' ','')
	pieces=[
		'AutoGeneratedBy',
		name(),
		'On',
		str(PyTis.timestamp(full=True)).replace(' ',
			'').replace('-',
			'').replace('.',
			'').replace(':','')
	]
	return ''.join(pieces)

	


def run_python_program(cmd):
	""" I broke this out into function because currently, I do not like the way
	it behaves.  In the future I would like to use subprocess, and put a wrapper
	around subprocess that catches errors, python tracebacks.  If the traceback
	contains "KeyboardInterrupt."  Then handle it without showing it to the
	screen.  For now, I spent too much time messing with the subprocess.PIPES, so
	I am going to use the built in os.system (just for now). 
	"""
	# XXX:TODO  - finish this, change the way it behaives.  Read the docstring
	# for more information.

	if type(cmd) is str: 
		# if it is not a list, turn it into one
		cmdl = cmd.split(' ')

	def _():
		# subprocess.call(cmdl) # did not print output until I hit enter, then once
		# I hit enter it still only prints one line, then no more regardless of
		# number of returns press

		# subprocess.check_output(cmdl)# did not print output until I hit enter,
		# then once I hit enter it still only prints one line, then no more
		# regardless of number of returns press
		 
		# subprocess.Popen(cmdl) # odd but incorrect behavior
		os.system(cmd)
		#sys.stdout.flush()
	return _

def check_access(opts,args):
	"""
	Run tests to ensure that this script should run without any issues.  Append 
	any errors we find into the global errors list so that they may be reported
	to the user.
	"""
	global errors, log
	data = {}
#
# Locate aws config, this is usually located in a user account.  First we will
# attempt to determin which user we are signed in as.  Then we will look for
# the file in the default paths.  If we cannot find it there we will look in
# other likely locations.  If we still haven't found it, we will report this to
# the user.
#

	if opts.boto_config:
		possible_config_path = opts.boto_config
		if not os.path.exists(os.path.abspath(opts.boto_config)):

			errors.append("The path you provided for the aws config file does not " \
				"exist, or I do not have read access to that file.")
			return

	else:

		# 
		# config path not provided, try to guess
		#
		assumed_home_dir = PyTis.homedir()

		possible_aws = os.path.join(assumed_home_dir,'.aws')

		possible_config_path = os.path.abspath(os.path.join(possible_aws,
			'config'))

		if not os.path.exists(possible_config_path):
			#
			# It does not exist in their user directory, lets try one other place
			# first.
			#
			
			possible_config_path = os.path.abspath(os.path.join('/etc', 'aws',
				'config'))

			if not opts.quiet:
				manual = PyTis.getInputYN("Cannot locate the config file for " \
					"awscli.  AWS cli may not yet be configured.  Would you like " \
					"to configure it now?") 

				if manual:
					run_python_program('aws configure')()

				if not os.path.exists(possible_config_path):
					errors.append("Cannot locate the config file for awscli.  Please " \
						"manually specify using the --boto-config argument.")
					return

	config_file = COBJ.load(possible_config_path)
	# XXX: Cleanup, remove the default string and have it passed as an option,
	# even if it isn't a required option and defaults to "default"
	section_title = 'default'

	try:
		data = config_file[section_title]
	except KeyError as e:
		try:
			config_file['region']
		except KeyError as e:
			errors.append("The %s section could not be found in the config file "\
				"at: %s" % (section_title, possible_config_path))
			return
		else:
			data = config_file
	else:
		try:
			aws_access_key_id = data['aws_access_key_id']
			aws_secret_access_key = data['aws_secret_access_key']
		except KeyError as e:

			#
			# access items were not in the config file, lets Locate aws credentials
			# file
			#

			if opts.credentials:
				possible_credentials_path = opts.credentials
				if not os.path.exists(os.path.abspath(opts.credentials)):
					errors.append("The path you provided for the aws credentials file " \
						"does not exist, or I do not have read access to that file.")
					return

			else:
				possible_credentials_path = os.path.abspath(os.path.join(possible_aws,
					'credentials'))

				if not os.path.exists(possible_credentials_path):
					# It does not exist in their user directory, lets try one other place
					# first.
					possible_credentials_path = os.path.abspath(os.path.join('/etc', 
						'aws', 'credentials'))

					if not os.path.exists(possible_credentials_path):
						errors.append("Cannot locate the credentials file for awscli.  " \
							"Please manually specify using the --credentials argument.")
						return

			cred_file = COBJ.load(possible_credentials_path, False)
			try:
				aws_access_key_id = cred_file[section_title]['aws_access_key_id']
				aws_secret_access_key=cred_file[section_title]['aws_secret_access_key']
			except KeyError as e:
				try:
					aws_access_key_id = cred_file['aws_access_key_id']
					aws_secret_access_key = cred_file['aws_secret_access_key']
				except KeyError as e:
					errors.append("The %s section could not be found in the " \
					"credentials file at: %s, nor could the values for " \
					"'aws_access_key_id' and 'aws_secret_access_key' without a " \
					"section." % (section_title, possible_credentials_path))
					return
				else:
					data['aws_access_key_id'] = aws_access_key_id
					data['aws_secret_access_key'] = aws_secret_access_key
			else:
				data['aws_access_key_id'] = aws_access_key_id
				data['aws_secret_access_key'] = aws_secret_access_key

	return data

def check_input(opts,args):
	#global log
	pass

def run(opts,args,data={}):
	""" cloud-checkr-verify run __doc__ help
	CloudTrail leverages Simple Storage Service (S3).  This program will talk to
	CloudTrail via it's API (built into AWS internal) to ...
	Steps:
		- create account
		- turn on cloud trail
		- ask cloud trail, please send logs to S3 Bucket in Master Computer
			Inncident Responce Team's (CIRT) account

	S3 Bucket that every account to point to.

	"""
	global log
	#
	# Create a connection to the Cloudtrail service (we are leveraging python's
	# BOTO as an API to speak with cloudtrail).
#
	# BOTO will also utilize the config/credentials file automatically to grab
	# the key and secretkey.  This is automated for us by BOTO; which is why we
	# donot have to provide them here in code.
	#

	# primary region in this account
	try:
		cloudtrail = boto.cloudtrail.connect_to_region("us-east-1") 
	except boto.exception.NoAuthHandlerFound as e:
		log.error("%s" % str(e))
		log.error("It is likely you have a missmatched version of awscli and " \
			"boto installed, please ask an administrator to ensure you have the " \
			"latest version of both installed, and try again.")
		return 1

	#
	# Define Cloudtrail service
	#

# Default (name of new trail)
# awsbahcloudtrail (name of master S3 bucket)
	try:
		response = cloudtrail.create_trail(
								 'Default',
								 'awsbahcloudtrail',
								 s3_key_prefix=None,
								 sns_topic_name=None,
								 include_global_service_events=None,
								 cloud_watch_logs_log_group_arn=None,
								 cloud_watch_logs_role_arn=None
							 )
	except boto.cloudtrail.exceptions.TrailAlreadyExistsException:
		# good, we are glad it already exists
		log.debug('FAIL CREATING CLOUD TRAIL - ALREADY EXISTS.')
# XXX:What happens if one already exists with this name?
										 
	# tell cloud trial to turn logging on for this new trail
	response = cloudtrail.start_logging('Default')
# XXX:what happens if it was for some reason, already turned on for this trail?

	#
	# Create a connection to the Identity Access Management (IAM) service
	#
	iam = boto.connect_iam()

	#
	# Define IAM Password Policy
	#

	iam_policy = iam.update_account_password_policy( 
		allow_users_to_change_password=True,
		hard_expiry=False,
		max_password_age=90,
		minimum_password_length=15,
		password_reuse_prevention=6,
		require_lowercase_characters=True,
		require_numbers=True,
		require_symbols=True,
		require_uppercase_characters=True
	)

	#
	# Define Policies for cloudcheckr, ProjectAdmin, and Cyber Solutions Network
	# (CSN) Now create a group for the cloudcheckr and ProjetAdmin users.
	# This group will allow members to use all EC2 and S3 functionality
	#

	ProjectAdmin_policy = """{
		"Version": "2012-10-17",
		"Statement": [
			{
				"Effect": "Allow",
				"Action": "*",
				"Resource": "*"
			},
			{
				"Sid": "%(Sid)s",
				"Effect": "Deny",
				"Action": "ec2:PurchaseReservedInstancesOffering",
				"Resource": "*"
			}
		]
	}""" % dict(Sid=create_sid())

	cloudcheckr_policy = """{
		"Version": "2012-10-17",
		"Statement": [
		{
		"Sid": "%(Sid)s",
		"Action": [
					"autoscaling:Describe*",
					"cloudformation:DescribeStacks",
					"cloudformation:GetStackPolicy",
					"cloudformation:GetTemplate",
					"cloudformation:ListStackResources",
					"cloudfront:List*",
					"cloudfront:GetDistributionConfig",
					"cloudfront:GetStreamingDistributionConfig",
					"cloudsearch:DescribeDomains",
					"cloudsearch:DescribeServiceAccessPolicies",
					"cloudsearch:DescribeStemmingOptions",
					"cloudsearch:DescribeStopwordOptions",
					"cloudsearch:DescribeSynonymOptions",
					"cloudsearch:DescribeDefaultSearchField",
					"cloudsearch:DescribeIndexFields",
					"cloudsearch:DescribeRankExpressions",
					"cloudtrail:DescribeTrails",
					"cloudtrail:GetTrailStatus",
					"cloudwatch:GetMetricStatistics",
					"cloudwatch:ListMetrics",
					"config:DescribeDeliveryChannels",
					"config:DescribeDeliveryChannelStatus",
					"config:DescribeConfigurationRecorders",
					"config:DescribeConfigurationRecorderStatus",
					"datapipeline:ListPipelines",
					"datapipeline:GetPipelineDefinition",
					"datapipeline:DescribePipelines",
					"directconnect:DescribeLocations",
					"directconnect:DescribeConnections",
					"directconnect:DescribeVirtualInterfaces",
					"dynamodb:ListTables",
					"dynamodb:DescribeTable",
					"ec2:DescribeAvailabilityZones",
					"ec2:DescribeKeyPairs",
					"ec2:DescribePlacementGroups",
					"ec2:DescribeAddresses",
					"ec2:DescribeReservedInstances",
					"ec2:DescribeSpotInstanceRequests",
					"ec2:DescribeImages",
					"ec2:DescribeImageAttribute",
					"ec2:DescribeSnapshots",
					"ec2:DescribeVolumes",
					"ec2:DescribeTags",
					"ec2:DescribeNetworkInterfaces",
					"ec2:DescribeSecurityGroups",
					"ec2:DescribeInstanceStatus",
					"ec2:DescribeInstanceAttribute",
					"ec2:DescribeVolumeStatus",
					"ec2:DescribeInstances",
					"ec2:GetConsoleOutput",
					"ec2:DescribeDhcpOptions",
					"ec2:DescribeCustomerGateways",
					"ec2:DescribeVpcs",
					"ec2:DescribeSubnets",
					"ec2:DescribeRouteTables",
					"ec2:DescribeVpnConnections",
					"ec2:DescribeNetworkAcls",
					"ec2:DescribeInternetGateways",
					"ec2:DescribeVpnGateways",
					"elasticache:DescribeCacheClusters",
					"elasticache:DescribeReservedCacheNodes",
					"elasticache:DescribeCacheSecurityGroups",
					"elasticache:DescribeCacheParameterGroups",
					"elasticache:DescribeCacheParameters",
					"elasticache:DescribeCacheSubnetGroups",
					"elasticbeanstalk:DescribeApplications",
					"elasticbeanstalk:DescribeConfigurationSettings",
					"elasticbeanstalk:DescribeEnvironments",
					"elasticbeanstalk:DescribeEvents",
					"elasticloadbalancing:DescribeLoadBalancers",
					"elasticloadbalancing:DescribeInstanceHealth",
					"elasticloadbalancing:DescribeLoadBalancerAttributes",
					"elasticmapreduce:DescribeJobFlows",
					"elasticmapreduce:DescribeStep",
					"elasticmapreduce:DescribeCluster",
					"elasticmapreduce:ListSteps",
					"elasticmapreduce:ListInstanceGroups",
					"elasticmapreduce:ListBootstrapActions",
					"elasticmapreduce:ListClusters",
					"glacier:List*",
					"glacier:DescribeVault",
					"glacier:GetVaultNotifications",
					"glacier:DescribeJob",
					"glacier:GetJobOutput",
					"iam:Get*",
					"iam:List*",
					"kinesis:ListStreams",
					"kinesis:DescribeStream",
					"kinesis:GetShardIterator",
					"kinesis:GetRecords",
					"rds:DescribeReservedDBInstances",
					"rds:DescribeDBInstances",
					"rds:DescribeDBSubnetGroups",
					"rds:DescribeDBSecurityGroups",
					"rds:DescribeDBParameterGroups",
					"rds:DescribeDBSnapshots",
					"rds:DescribeEvents",
					"rds:DescribeEventSubscriptions",
					"rds:DescribeDBEngineVersions",
					"rds:DescribeOptionGroups",
					"rds:ListTagsForResource",
					"redshift:Describe*",
					"redshift:ViewQueriesInConsole",
					"route53:ListHealthChecks",
					"route53:ListHostedZones",
					"route53:ListResourceRecordSets",
					"s3:GetACL",
					"s3:GetBucketLocation",
					"s3:GetBucketLogging",
					"s3:GetBucketTagging",
					"s3:GetBucketWebsite",
					"s3:GetBucketNotification",
					"s3:GetLifecycleConfiguration",
					"s3:GetNotificationConfiguration",
					"s3:GetObject",
					"s3:GetObjectMetadata",
					"s3:List*",
					"ses:ListIdentities",
					"ses:GetSendStatistics",
					"ses:GetIdentityDkimAttributes",
					"ses:GetIdentityVerificationAttributes",
					"ses:GetSendQuota",
					"sdb:ListDomains",
					"sdb:DomainMetadata",
					"support:*",
					"swf:ListClosedWorkflowExecutions",
					"swf:ListDomains",
					"swf:ListActivityTypes",
					"swf:ListWorkflowTypes",
					"sns:GetSnsTopic",
					"sns:GetTopicAttributes",
					"sns:GetSubscriptionAttributes",
					"sns:ListTopics",
					"sns:ListSubscriptionsByTopic",
					"sqs:ListQueues",
					"sqs:GetQueueAttributes"
		],
		"Effect": "Allow",
		"Resource": "*"
		}
		]
	}""" % dict(Sid=create_sid())

	BAHCrossAccount_CIRT_policy = """{
			"Version": "2012-10-17",
			"Statement": [
					{
							"Sid": "%(Sid)s",
							"Effect": "Allow",
							"Action": [
									"ec2:*"
							],
							"Resource": [
									"*"
							]
					},
					{
							"Effect": "Allow",
							"Action": [
									"directconnect:*"
							],
							"Resource": [
									"*"
							]
					},
					{
							"Effect": "Allow",
							"Action": [
									"iam:*"
							],
							"Resource": [
									"*"
							]
					},
					{
							"Effect": "Allow",
							"Action": [
									"s3:*"
							],
							"Resource": [
									"*"
							]
					},
					{
							"Effect": "Allow",
							"Action": [
									"glacier:*"
							],
							"Resource": [
									"*"
							]
					},
					{
							"Effect": "Allow",
							"Action": [
									"cloudtrail:*"
							],
							"Resource": [
									"*"
							]
					}
			]
	}""" % dict(Sid=create_sid())


	BAHCrossAccount_CIRT_Trust_policy = """{
		"Version": "2012-10-17",
		"Statement": [
			{
				"Sid": "%(Sid)s",
				"Effect": "Allow",
				"Principal": {
					"AWS": "arn:aws:iam::632121157026:root"
				},
				"Action": "sts:AssumeRole"
			}
		]
	}""" % dict(Sid=create_sid())


	#
	# Assocaite Policies with a group
	#

	try:
		response = iam.create_group('ProjectAdmin')
	except boto.exception.BotoServerError as e:
		if '<Message>Group with name' in str(e) and \
			' already exists.</Message>' in str(e):
			log.debug("Group '%s' already exists." % 'ProjectAdmin')
		else:
			raise boto.exception.BotoServerError(e)

	response = iam.put_group_policy('ProjectAdmin', 'ProjectAdmin_NORI_Policy', 
		ProjectAdmin_policy)

	try:
		response = iam.create_group('Cloudcheckr')
	except boto.exception.BotoServerError as e:
		if '<Message>Group with name' in str(e) and \
			' already exists.</Message>' in str(e):
			log.debug("Group '%s' already exists." % 'ProjectAdmin')
		else:
			raise boto.exception.BotoServerError(e)

	response = iam.put_group_policy('Cloudcheckr', 'CloudcheckrPolicy',
		cloudcheckr_policy)

	 
#
# Associate Switch Role Policy with a Role
#

	try:
		role = iam.create_role('BAHCrossAccount_CIRT_Role')
	except boto.exception.BotoServerError as e:
		if '<Message>Role with name' in str(e) and \
			' already exists.</Message>' in str(e):
			log.debug("Role '%s' already exists." % 'ProjectAdmin')
		else:
			raise boto.exception.BotoServerError(e)



	role = iam.put_role_policy('BAHCrossAccount_CIRT_Role',
		'BAHCrossAccount_CIRT_Policy', BAHCrossAccount_CIRT_policy)

# Updates Trust Relationship 
	role = iam.update_assume_role_policy('BAHCrossAccount_CIRT_Role',
		BAHCrossAccount_CIRT_Trust_policy)
	 
#
# Now create the cloudcheckr user and place him in the cloudcheckr group.
#
	try:
		response = iam.create_user('cloudcheckruser')
	except boto.exception.BotoServerError as e:
		if '<Message>User with name' in str(e) and \
			' already exists.</Message>' in str(e):
			log.debug("User '%s' already exists." % 'ProjectAdmin')
			response = iam.get_user('cloudcheckruser')
		else:
			raise boto.exception.BotoServerError(e)


	user = response.user
	response = iam.add_user_to_group('Cloudcheckr', 'cloudcheckruser')
	 

#
# Create AccessKey/SecretKey pair for cloudcheckr
#

	response = iam.create_access_key('cloudcheckruser')
	access_key = response.access_key_id
	secret_key = response.secret_access_key
	print "Access Key: ", repr(access_key)
	print "Secret Key: ", repr(secret_key)


#
# Now log into cloudcheckr and create a new account while I grab a drink or 5.  
#



# /home/username/.aws/config

# XXX: STOP HERE

def main():
	"""usage: %prog -c[PATH] -C[PATH] <options>"""
	global errors, log

	filename = os.path.abspath(os.path.join(PyTis.__configdir__, '%s.ini' % \
		os.path.basename(os.path.abspath(sys.argv[0]))))

	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	parser.extra_txt = "\n\n%s\n" % run.__doc__ + """

Josh
aws --version: aws-cli/1.2.9 Python/3.4.0 Linux/3.13.0-48-generic
aws --version: aws-cli/1.2.9 Python/2.7.6 Linux/3.13.0-48-generic
boto:					 2.20.1

Bernie
aws --version: aws-cli/1.7.31 Python/2.7.9 Linux/3.14.35-28.38.amzn1.x86_64
boto:					 2.38.0
examples:	
	xxx

SEE ALSO:
	xxx

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

HISTORY:
	Original Author

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	parser.set_description(__doc__)

	# to determine help mode (short or full)
	helpishere=False
	for a in sys.argv:
		if a == '--help':
			helpishere=True

	if helpishere:
		# set verbose help
		verbose_help = "Be more Verbose (make lots of noise)"
		# set aws_access_key_id help
		aws_access_key_id_help = "Normally, the AWS Access Key ID would be " \
			"loaded from the .aws/credentials file, however, you may choose to " \
			"manually override this option by providing the access key id as an " \
			"argument.`$"
		# set aws_secret_access_key help
		aws_secret_access_key_help = "Normally, the AWS Access Key ID would " \
			"be loaded from the .aws/credentials file, however, you may choose to " \
			"manually override this option by providing the access key id as an " \
			"argument.`$"
	else:
		# set verbose help
		verbose_help = optparse.SUPPRESS_HELP
		# set aws_access_key_id help
		aws_access_key_id_help = 'AWS Access Key ID override. ' \
			'*(use "--help" for more details)`$'
		# set aws_secret_access_key help
		aws_secret_access_key_help = 'AWS Secret Access Key override. ' \
			'*(use "--help" for more details)`$'


	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")

	runtime.add_option("-b", "--boto-config", action="store", type="string",
					 default='', metavar='[PATH]', dest='boto_config',
					 help="")

	runtime.add_option("-c", "--config-file", action="store", type="string",
					 default='', metavar='[PATH]', dest='config',
					 help="")

	runtime.add_option("-C", "--credentials-file", action="store", type="string",
					 default='', metavar='[PATH]', dest='credentials',
					 help="")


	runtime.add_option("-p", "--profile", action="store", type="string",
					 default='default', metavar='[PROFILE]', dest='profile',
					 help="If you have multiple profiles, you can configure " \
					 "additional, named profiles by using the -p, --profile option.`$")

	parser.add_option_group(runtime)


	# -------------------------------------------------------------------------
	# variable setting
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")

	vars.add_option("-a", "--access-key-id", action="store", type="string",
					 default='', metavar='[STRING]', dest='aws_access_key_id',
					 help=aws_access_key_id_help)

	vars.add_option("-s", "--secret-access-key", action="store", type="string",
					 default='', metavar='[STRING]', dest='aws_secret_access_key',
					 help=aws_secret_access_key_help)

					#help='Optional name to save configuration into a section.  *(use "--help" for more help)')

	parser.add_option_group(vars)
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging")



	dbgroup.add_option("-V", "--verbose", action="store_true",
					 default=True, dest='verbose',
					 help=verbose_help)


#	parser.add_option("-l", "--logging", action="store_true", default=False, help="Enable Logging")

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits)")

	dbgroup.add_option("-v", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()

	if opts.debug:
		main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__, \
			os.path.abspath(filename))
	else:
		pass

	parser.set_usage(main.__doc__)

	if opts.quiet: opts.verbose = False

	old_version = opts.version
	opts.version = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	opts.version = old_version


	if opts.version:
		return PyTis.version(__version__)


	try:
		aws_path = subprocess.check_output(["which", "aws"])
	except subprocess.CalledProcessError as e:
		errors.append("This program requires awscli " \
			"<https://github.com/aws/aws-cli>.\n" \
			"Please ask your administrator for assistance.")

	if len(args) == 0 and not errors:
		return parser.print_usage()

	if not errors and len(args):
		try:
			data = check_access(opts,args)
		except (PyTis.QuitNow,KeyboardInterrupt) as e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return

	log.debug(data)

	if not errors and len(args):
		try:
			data = check_input(opts,args)
		except (PyTis.QuitNow,KeyboardInterrupt) as e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return

	if not errors and len(args):
		try:
			retval = run(opts, args)
		except KeyboardInterrupt as e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return
		else:
			if not retval:
				log.info("Done.")
			return retval
	else:
		if errors and len(args):
			parser.print_usage()
			log.error(str("\n".join(errors)))
			return 
		elif errors:
			return parser.print_help(errors)
		else:
			return parser.print_usage()

	parser.print_help("ERROR: Unknown, but invalid input.")
	sys.exit(0)

if __name__ == '__main__':
		sys.exit(main())



