#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 1.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2014 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 10:37 05 May, 2014            #
############################################################################## #
"""pysql-backup
============
"""

import os
import sys
import glob
import getpass
import optparse
import datetime
import subprocess

import pytis as PyTis
from pylib import configobj as COBJ

if not getattr(os,'touch',None):
	if sys.version_info >= (3, 3):
		def touch(fname, times=None, ns=None, dir_fd=None):
			if os.path.isfile(fname) and os.path.exists(fname): return False
			with os.open(fname, os.O_APPEND, dir_fd=dir_fd) as f:
				os.utime(f.fileno() if os.utime in os.supports_fd else fname,
					times=times, ns=ns, dir_fd=dir_fd)
			return True
	else:
		def touch(fname, times=None):
			if os.path.isfile(fname) and os.path.exists(fname): return False
			with file(fname, 'a'):
				os.utime(fname, times)
			return True
	os.touch = touch

__author__ = 'Josh Lee'
__copyright__ = 'PyTis.com'
__created__ = '02:01pm 09 Sep, 2013'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__version__ = '0.9' # not version 1, until I get the full help in


__default_port__ = 3306 
__default_host__ = 'localhost'

def find_user():
	global log
	log.debug('No user provided, attempting to retrieve current system user')
	user = getpass.getuser()
	log.debug('Found: %s' % user)
	return user

def test_pgsql(pgsql,pgsql_for_log,db='postgres'):
	global log
	exe = "echo 'SELECT 1;' | %s %s"%(pgsql,db)
	exe_log = "echo 'SELECT 1;' | %s %s"%(pgsql_for_log,db)
	log.debug('test_pgsql(pgsql,pgsql_for_log): %s' % exe_log)
	#log.debug('test_pgsql(pgsql,pgsql_for_log): %s' % exe)
	p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
		shell=True)
	while True:
		retcode = p.poll()
		line = p.stdout.readline()
		if line:
			if line.strip().startswith('psql: FATAL:  password authentication ' \
			'failed for user') or line.strip().startswith('FATAL:  password ' \
			'authentication failed for user'):
				log.warn(line.strip())
				sys.exit(1)
			elif line.strip() == '?column?':
				return True
			elif db=='postgres':
				log.warn('Unknown error, but connection to pgsql could not be ' \
					'established.')
				log.debug('line: %s' % line.strip())
				sys.exit(1)
		if retcode is not None:
			break
	log.debug('Unknown connection failure')
	return False

def test_mysql(mysql,mysql_for_log,db=''):
	global log
	exe = "echo 'SELECT 1;' | %s %s"% (mysql,db)
	exe_log = "echo 'SELECT 1;' | %s %s"% (mysql_for_log, db)
	log.debug('test_mysql(mysql,mysql_for_log): %s' % exe_log)
	p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
		shell=True)
	while True:
		retcode = p.poll()
		line = p.stdout.readline()
		if line:
			if line.strip().startswith('ERROR 1045 (28000): Access denied for user'):
				log.warn(line.strip())
				sys.exit(1)
			elif line.strip() == '1':
				return True
			elif not db:
				log.warn('Unknown error, but connection to mysql could not be ' \
				'established.')
				log.debug('line: %s' % line.strip())
				sys.exit(1)
		if retcode is not None:
			break
	log.debug('Unknown connection failure')
	return False

__mysql_bag__ = []
__pgsql_bag__ = []

def pgsql_line(section, opts, command='psql'):
	global __pgsql_bag__, log
	if __pgsql_bag__:
		for_log='%s %s' % (__pgsql_bag__[2],__pgsql_bag__[0])
		line='%s %s' % (__pgsql_bag__[1], __pgsql_bag__[0])
		return (line,for_log)
	else:
		r=[]
		r.append(command)
		section.user = section.user or find_user()
		r.append('-U%s'%section.user)
		host = '-h%s' % section.host if section.host else ''
		if host: r.append(host)
		port = '-p%s' % section.port if section.port else ''
		if port: r.append(port)
		if command == 'pg_dump' and section.flags:
			r.append(section.flags)
		base=' '.join(r)

		# password
		password=section.password or \
			getpass.getpass('Password for %s: ' % section.user)

		section.password=password
		if section.password:
			x='*'*8
			fakepass="PGPASSWORD=%s" % x
			password='PGPASSWORD=%s'%section.password
		else:
			fakepass = ''
			password = ''
		__pgsql_bag__=[base,password,fakepass]
		return pgsql_line(section, opts)


def mysql_line(section, opts,command='mysql'):
	global __mysql_bag__, log

	if __mysql_bag__:
		for_log='%s%s' % (__mysql_bag__[0],__mysql_bag__[2])
		line='%s%s' % (__mysql_bag__[0],__mysql_bag__[1])
		return (line,for_log)
	else:
		r=[]
		r.append(command)
		section.user = section.user or find_user()
		r.append('-u%s'%section.user)
		host = '-h%s' % section.host if section.host else ''
		if host: r.append(host)
		port = '-P%s' % section.port if section.port else ''
		if port: r.append(port)
		if command == 'mysqldump' and section.flags:
			r.append(section.flags)
		base=' '.join(r)
		
		# password
		password=section.password or \
			getpass.getpass('Password for %s: ' % section.user)

		section.password=password
		if section.password:
			x='*'*8
			fakepass=" -p%s" % x
			password=' -p%s'%section.password
		else:
			fakepass = ''
			password = ''
		__mysql_bag__=[base,password,fakepass]
		return mysql_line(section, opts, command)

def execute(exe):
	global log
	p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
		shell=True)
	while True:
		retcode = p.poll()
		line = p.stdout.readline()
		if line:
			yield line.strip()
		if retcode is not None:
			break


def prune(log_label,directory,count,TEST_NOW,db, opts,acceptable_date=None): 
	global log

	for fpath in glob.glob(os.path.join(directory,'*.tar.gz')):
		f = os.path.basename(fpath)
		if f.endswith("%s.tar.gz" % db):
			pass
		else:
			continue

		if count == 0:
			if TEST_NOW and not opts.force:
				log.info("%s count is set to 0, {%s} would be deleted" % (log_label.title(),f))
			elif not TEST_NOW or (TEST_NOW and opts.force):
				os.unlink(fpath)
				log.info("%s count is set to 0, {%s} [ removing ]" % (log_label.title(),f))
		elif not count:
			log.warn("Count not set at all, but filename match found.  No files will be pruned.")
		else:
			try:
				fyear = int(f[0:4])
				fmonth = int(f[4:6])
				fday = int(f[6:8])
			except (ValueError,IndexError), e:
				# XXX-TODO log it though, like a warning
				pass #skip because it must be someone elses tarbarll
			else:
				your_date = datetime.date(fyear,fmonth,fday)
				if your_date < acceptable_date:
					if TEST_NOW and not opts.force:
						log.info("file {%s} is more than %s %s old, and would be deleted" % (f,count,log_label))
					elif not TEST_NOW or (TEST_NOW and opts.force):
						log.info("file {%s} is more than %s %s old [ removing ]" % (f,count,log_label))
						os.unlink(fpath)
				else:
					if TEST_NOW and opts.force:
						log.info("%s - file dates checked: [ skipping ]" % f)
					else:
						log.debug("%s - file dates checked: [ skipping ]" % f)

def purge(opts, section, db):
	if section.purge is None:
		return
	else:
		now=datetime.datetime.now()
		acceptable_date = PyTis.relative_date(now,days=-section.purge).date()
		root = os.path.abspath(section.target)

		prune('days',root,section.purge,
			section.action=='test', db, opts,
			acceptable_date)


def run(cfile, opts):
	"""pysql-backup run doc help
	"""
	global log, __mysql_bag__,__pgsql_bag__

	sections = PyTis.identify_sections(cfile.config)
	opts.section = PyTis.trim(opts.section)
	TESTALL = False
	if opts.action == 'test':
		TESTALL = True
	#field_keys = self.field_settings.keys()
	#field_keys.sort()

	if sections:
		for section_name, section in sections:
			if opts.section and opts.section.lower()==section_name.lower():
				# a section was specified on the command line, so we are only going
				# to handle this one, skipping all others.
				if opts.action and opts.action.lower() != 'ignore':
					# keep going, we aren't being told to ignore
					# so if it did say ignore in the config, they just overrode it.
					# so go ahead and pass through, allowing validation below to occur
					log.debug("# -- running %s only" % opts.section)
				# a section wasn't given on STDIN
				elif PyTis.trim(section.get('action','use')).lower() == 'ignore':
					# STDIN command line action was not overridden, and the config file
					# says ignore, so we should continue on to the next section,
					# skipping this one.  they did not tell the STDIN to ignore, and
					# the config file says to ignore, so we will skip
					continue
			elif opts.section:
				# as I said above, a section was specified on the command line, so we
				# continue over this one, because this one's name isn't the same as
				# the one specified.
				# it was specified on STDIN and it isn't the one we are in
				continue
			elif PyTis.trim(section.get('action','use')).lower() == 'ignore' and \
				( opts.action and opts.action.lower() == 'test'):
				# this is okay, you can test an ignored section
				pass
			elif PyTis.trim(section.get('action','use')).lower() == 'ignore' and \
				( opts.action and opts.action.lower() in ('use', 'run') ):
				# this is okay, you can test an ignored section
				log.info('# -- SERVER: %s - is ignored in the config [ skipping ]' % section_name)
				continue
			else:
				# a section was not specified on the command line, so we should
				# run all of them
				log.debug("# -- running %s" % section_name)
			

			section = cfile.config[section_name]

			target = section.target or os.getcwd()

			try:
				test_target(target)
			except PyTis.DieNow, e:
				log.error(e)
				return

			__mysql_bag__ = []
			__pgsql_bag__ = []
			
			if section.driver.lower() == 'mysql':
				sql,sql_for_log=mysql_line(section, opts)

				if not test_mysql(sql,sql_for_log):
					log.warn("Connection Failed.")
					sys.exit(1)

				if not section.database: 
					exe = "echo 'SHOW DATABASES;' | %s" % sql
					exe_log = "echo 'SHOW DATABASES;' | %s" % sql_for_log

				__mysql_bag__ = []
				sql,sql_for_log=mysql_line(section, opts, 'mysqldump')

			elif section.driver.lower() in ('postgresql','pgsql'):
				sql,sql_for_log=pgsql_line(section, opts)

				if not test_pgsql(sql,sql_for_log):
					log.warn("Connection Failed.")
					sys.exit(1)

				if not section.database: 
					exe="echo 'SELECT datname FROM pg_database;' | %s postgres" % sql
					exe_log="echo 'SELECT datname FROM pg_database;' | %s postgres" % sql_for_log

				__pgsql_bag__ = []
				sql,sql_for_log=pgsql_line(section, opts, 'pg_dump')

			log.info("# -- SERVER: %s -- TARGET: ( %s )" % (section_name,
				section.target))
			log.debug('# -- HOST IS: %s' % section.host)


			#log.info(list(lines))
			if section.database: 
				lines=[section.database]
			else: 
				log.debug(exe_log)
				lines = execute(exe)
				lines = list(lines)
				if lines: 
					if section.driver.lower() == 'mysql':
						lines = lines[1:]
					elif section.driver.lower() in ('postgresql','pgsql'):
						lines = lines[2:len(lines)-2]



			errors = []
			os.chdir(section.target)
			lines.sort()

			for db in (lines):
				if db.lower().strip() in [f.lower().strip() for f in section.excludes]:
					log.info("%s [excluding] " % db)
					continue
				else:
					log.debug("%s not in %s" % (db,section.excludes))


				prefix = str(datetime.datetime.now().strftime("%Y%m%d_%I%M"))

				fname = '%s-%s.sql' % (prefix,db)
				fpath = os.path.abspath(os.path.join(section.target, fname))

				backup_cmd = "%s %s > %s" % (sql,db,fname)
				cmd_4_log = "%s %s > %s" % (sql_for_log,db,fpath)

				log.debug("%s" % cmd_4_log)

				if section.action == 'test' or TESTALL:

					if section.driver.lower() == 'mysql':

						__mysql_bag__ = []
						test_sql,test_sql_for_log=mysql_line(section, opts)
						if not test_mysql(test_sql,test_sql_for_log, db):
							log.info("%s [failed] " % db)
							sys.exit(1)
							continue
						else:
							purge(opts, section, db)
							log.info("%s [passed] " % db)
							continue

					elif section.driver.lower() in ('postgresql','pgsql'): 
						__pgsql_bag__ = []
						test_sql,test_sql_for_log=pgsql_line(section, opts)
						if not test_pgsql(test_sql,test_sql_for_log, db):
							log.info("%s [failed] " % db)
							sys.exit(1)
							continue
						else:
							purge(opts, section, db)
							log.info("%s [passed] " % db)
							continue

				else:
					purge(opts, section, db)
					log.info("%s [dumping] " % db)
				
				try:
					err = list(execute(backup_cmd))
				except KeyboardInterrupt, e:
					log.info("\nKeyboard-Interrupt, bye!")
					os.unlink(fname)
					return

				if len(err) > 1:
					errors.append('error in "%s"' % db)
					errors.extend(err)
					break
				elif len(err)==1 and str(err[0]).find('Access denied for user')!=-1:
					errors.append('error in "%s"' % db)
					errors.append(str(err[0]))
					continue
				elif err:
					errors.append('error in "%s"' % db)
					errors.extend(err)
					os.unlink(fname)
					break
				else:
					pass


				#sort
				newfile = "%s-%s.tar.gz" % (prefix,db)
				newpath = os.path.abspath(os.path.join(section.target,newfile))
				tar_cmd = "tar cvzf %s %s" % (newfile,fname)
				err = list(execute(tar_cmd))
				log.debug("%s" % tar_cmd)


				if len(err) > 1:
					errors.append('error in "%s"' % db)
					errors.extend(err)
					break
				elif len(err) == 1:
					if str(err[0]) == fname:
						pass
					else:
						errors.append('error in "%s"' % db)
						errors.append(str(err[0]))
						continue
				elif err:
					errors.append('error in "%s"' % db)
					errors.extend(err)
					break
				else:
					pass
				os.unlink(fname)


				if errors:
					log.error(str("\n\n".join(errors)))
				else:
					log.debug('Created: %s' % os.path.exists(fpath))

	else:
		log.error("No sections were found in the config file: %s" % cfile.filename)
		return

def test_target(target):
	target = os.path.abspath(target)

	if not os.path.exists(target) or not os.path.isdir(target):
		try:
			os.makedirs(target)
		except (OSError, IOError), e:
			error = 'Target directory "%s" does not exist, and we could not create ' \
			'it for you.' % target + "\n%s" % str(e)
			log.error(error)
			raise PyTis.DieNow(str(error))
	fname = "%s.tmp" % PyTis.microtime()
	fpath = os.path.join(target,fname)
	try:
		os.touch(fpath)
	except (OSError, IOError):
		error = 'Target directory "%s" is not writable, and we could not create ' \
		'a file in it.' % target + "\n%s" % str(e)
		log.error(error)
		raise PyTis.DieNow(str(error))
	else:
		os.unlink(fpath)


def exclude_accumulator():
	"""Return an optParser callback and a getter to grab final results.
	The callback is an accumulator that will continuesly add new excludes,
	as many times it is called.	Additionally, it can be presented with commas,
	so that it only need be called one time.	This will split on commas.
	"""
	dirs = []
	def get_excludes():
		return dirs
	def my_callback(option, opt, value, parser):
		if ',' in value:
			values = value.split(',')
		else:
			values = [value]
		for value in values:
			if value not in dirs:
				dirs.append(value)
	return my_callback, get_excludes
exclude_accumulator, get_excludes = exclude_accumulator()



def main():
	"""usage: pysql-backup"""
	global log, __default_port__, __default_host__

	helpishere=False
	for a in sys.argv:
		if a == '--help':
			helpishere=True

	filename = os.path.abspath(os.path.join(PyTis.__configdir__, 
		'%s.ini' % os.path.basename(os.path.abspath(sys.argv[0]))))
	errors=[]
	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	

	parser.extra_txt = """Usage: pysql-backup	 ...<options>

 -S, --save
	Save information for future use? **Please note this by default will save configuration options to the global section of the INI	file, unless the -s/--section is specified, then options will only be saved to that section.


examples:	
	pysql-backup -N serverx -c0 -S
	pysql-backup test serverx
	pysql-backup test serverx databasea
	pysql-backup run

SEE ALSO:
	pysync
	pybkup

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

HISTORY:
	Original Author

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	parser.set_description(__doc__)


	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")

	# XXX-TODO
	# Not used yet, but we should end up using it, allowing an ignored section to "forcibly" be ran if requested on the command line as a one time thing.
	runtime.add_option("-F", "--force", 
									action="store_true",
									default=False,
									#help='Force a server to run in the all within the all section, when asked to run stand alone. *(use "--help" for more help)')
									help='Force a server to prune when test mode.')

	runtime.add_option("-c", "--clean", 
									type="int", 
									action='store',
									default=None, 
									dest='purge',
									metavar='[INT <None, 0 - 999>]',
									help="How many days worth of backups (if any) should be "
									"purged/removed from the target directory, before we get to "
									"the meat and tators.  Default None (off by default).")


	runtime.add_option("-l", "--list", 
									action='store_true',
									default=False, 
									dest='list',
									help="List all sections available from configuration file, "
									"and their current action.  "
									"This may be used in conjunction with [-N/--section] "
									"to print out to screen a section's configuration and exit." 
									)

	runtime.add_option("-n", "--nice", 
									type="int", 
									action='store',
									default=PyTis.MyThread.default_niceness, 
									dest='niceness',
									metavar='[INT <-20 - 19>]',
									help="Nicenesses range from -20.  "
									"Default %s" % PyTis.MyThread.default_niceness)

	parser.add_option_group(runtime)
	# -------------------------------------------------------------------------
	# variable setting
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")
	vars.add_option("-a", "--action", type="choice", action="store",
										default=None, 
										dest='action',
										choices=['ignore','run','test'],
										help="What to do with a saved section. Default 'run', "
												 "choices: <ignore,run,test>")

	vars.add_option("-N", "--section", action="store",
										metavar="[LOAD/SAVE-AS SECTION NAME]",
										type='string',
										dest='section',
										#dest='section_name',
										default=None, 
										help='Name to save configuration into a section. '
										' OR '
										'Name of configuration section to load the options from the config file.'
										'"*(use "--help" for more help)')

	vars.add_option("-S", "--save", action="store_true",
										default=False, 
										dest='save',
										help="Save cryptmount information for future use?")

	parser.add_option_group(vars)
	# ----------------------------
	sql = optparse.OptionGroup(parser, "SQL Connection Arguments")

	sql.add_option("", "--database", action="store",
					 default='',metavar="[DATABASE-NAME]", dest='database',
					 help="We do not recommend you use this flag, if you only want to backup one database, "
					 "you might as well just use mysqldump or pg_dump.  However, if you are just testing this tool,"
					 "then that is the only time I can think of, to specify a single database.  This option does "
					 "not get saved to the ini file.")

	sql.add_option("-d", "--driver", type='choice', action="store",
					 default='mysql',metavar="[DRIVER]", dest='driver',
					 choices=['mysql','postgresql'],
					 help="MySQL by default, you can also choose PostgreSQL (case in-sensative).")

	sql.add_option("-e", "--exclude-database", type='string', action="callback",callback=exclude_accumulator,
					 default='',metavar="[Exlude,Excludes]", dest='excludes',
					 help="An accumulator that will continuesly add new databases to exclude, as many times it "
								"is called.  Additionally, it can be presented with commas, so that it only need be "
								"called one time.  This will split on commas.")

	sql.add_option("-f", "--flags", action="store",
					 default='', metavar='[FLAGS]', dest='flags',
					 help="Flags to pass to mysqldump/pg_dump.")

	sql.add_option("-H", "--host", action="store",
					 default=__default_host__, metavar='[HOST]', dest='host',
					 help="Sets the hostname if other than localhost.")

	sql.add_option("-P", "--port", action="store", type="int",
					 default=__default_port__, metavar='[INT]', dest='port',
					 help="Use different port to connect to your MySQL db.")

	sql.add_option("-p", "--password", action="store",
					dest='password', metavar="[PASSWORD]",
					help="Password for connecting to the MySQL db."
					 "If one is not provided via STDIN, user will be prompted.")

	sql.add_option("-t", "--target", action="store",
					dest='target', metavar="[DIR PATH]",
					help='Target directory to store file to.  The name is auto-generated by this '
					 'program. *(use "--help" for more information)')

	sql.add_option("-u", "--user", action="store",
					 default=getpass.getuser(),metavar="[USER]", dest='user',
					 help="User to connect as. If no user is provided current user will be used.")

	parser.add_option_group(sql)
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging")

	if helpishere:
		dbgroup.add_option("-V", "--verbose", action="store_true",
						 default=True, dest='verbose',
						 help="Be more Verbose (make lots of noise)")
	else:
		dbgroup.add_option("-V", "--verbose", action="store_true",
						 default=True, dest='verbose',
						 help=optparse.SUPPRESS_HELP)

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits)")

	dbgroup.add_option("-v", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()
	if opts.debug:
		main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__,
			os.path.abspath(filename))
		parser.set_usage(main.__doc__)


	error = None
	cfile = PyTis.ConfigFile(opts)

	if opts.list and len(args) > 0 and not opts.section:
		opts.section = PyTis.trim(args[0])
	elif len(args) > 0 and not opts.action:
		for arg in args:
			if PyTis.trim(arg).lower() in ('test','run','use','ignore'):
				opts.action=PyTis.trim(arg).lower()
			elif not opts.section:
				opts.section = PyTis.trim(arg)
			elif not opts.database:
				opts.database = PyTis.trim(arg)
			else:

				if not opts.action:
					error = 'Invalid action "%s"' % PyTis.trim(arg)
				else:
					error = 'Action, section and database already set, ' \
						'unknown input "%s"' % PyTis.trim(arg)

	if not opts.action and not error and opts.section:
		try:
			opts.action = cfile.config[opts.section]['action']
		except KeyError, e:
			pass
		else:
			error = None

	opts.had_verbose = False
	if opts.verbose: opts.had_verbose = True
	if opts.quiet: opts.verbose = False

	if opts.action and opts.action.strip() and opts.action.strip().lower():
		opts.action = PyTis.trim(opts.action).lower()

	if opts.action == 'test' and not PyTis.trim(opts.quiet):
		opts.verbose=True

	# exclude_accumulator
	opts.excludes=get_excludes()
	if not opts.excludes: opts.excludes=[]

	if opts.quiet: opts.verbose = False

	old_version = opts.version
	opts.version = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	opts.version = old_version

	if error:
		log.error(error)
		return

	if opts.version:
		return PyTis.version(__version__)


	cfile.batchAddFields([
		dict(config_name='driver', required=False, default_value='mysql', 
			option=opts.driver, opt_parse_destination='driver', global_scope=False, 
			inherited=False, prompt=False, cast=str),
		dict(config_name='excludes', required=False, default_value='', 
			option=opts.excludes, opt_parse_destination='excludes', 
			global_scope=False, inherited=False, prompt=False, cast=list),
		dict(config_name='database', required=False, default_value='', 
			option=opts.database, opt_parse_destination='database', 
			global_scope=False, inherited=False, prompt=False, cast=str),
		dict(config_name='flags', required=False, default_value='', 
			option=opts.flags, opt_parse_destination='flags', global_scope=False, 
			inherited=False, prompt=False, cast=str),
		dict(config_name='host', required=False, default_value=__default_host__, 
			option=opts.host, opt_parse_destination='host', global_scope=False, 
			inherited=False,prompt=False,  cast=str),
		dict(config_name='password', required=True, default_value=None, 
			option=opts.password, opt_parse_destination='password', 
			global_scope=False, inherited=False, prompt=False, cast=str),
		dict(config_name='port', required=False, default_value=__default_port__, 
			option=opts.port, opt_parse_destination='port', global_scope=False, 
			inherited=False, prompt=False, cast=int),
		dict(config_name='purge', required=False, default_value=None, 
			option=opts.purge, opt_parse_destination='purge', global_scope=True, 
			inherited=True, prompt=False, cast=int),
		dict(config_name='niceness', required=False, 
			default_value=PyTis.MyThread.default_niceness, option=opts.niceness,
			opt_parse_destination='niceness', global_scope=True,
			inherited=True, prompt=False, cast=int),
		dict(config_name='action', required=True, default_value='run', 
			option=opts.action, opt_parse_destination='action', global_scope=False, 
			inherited=False, prompt=False, cast=str),
		dict(config_name='target', required=False, default_value=None, 
			option=opts.target, opt_parse_destination='target', global_scope=False, 
			inherited=False, prompt=False, cast=str),
		dict(config_name='user', required=False, default_value=getpass.getuser(), 
			option=opts.user, opt_parse_destination='user', global_scope=False, 
			inherited=False, prompt=False, cast=str)
	])


	# XXX-TODO Until the next XXX is found, between the two, I need to update
	# this to use the new format above, and the identify_sections.  I am going to
	# skip it for now though, so I am putting this comment here so that I don't
	# forget to come back and fix it.

	# Wrong, wrong, wrong.  IF you look closely below.  I test for the type(sub)
	# of the sub var, twould be the 'section' of section_name, section from
	# identify_sections.  However, identify_sections only returns actual
	# sections, whereas the code below, tests to see if a the type of the sub is
	# a section or not; even if it is not, it will still print it out, only as a
	# val to a key.  This allows a user to just list out the value of any
	# variable in the global scope of the config.  This would not be possible
	# using the identify_sections since it only returns sections, and not the
	# global variables.  Therefore, the original code is actually superior, in
	# this one instance.  I cannot actually foresee at this time any other cases
	# where this would be a better way of doing it, and identify_sections is the
	# right way to do it everywhere else that we use it, but for this one case,
	# for "list-out" we should not use it, and instead, stick to what we have
	# below.
	if cfile.exists:
		config = cfile.getConfig()
		if (opts.list and opts.section):
			try:
				sub = config[opts.section]
			except KeyError, e:
				log.error("Section not found, it is case-sensative.  Try the --list " \
					"command to see a list of available sections.")
				return
			else:
				if str(type(sub)) == "<class 'pylib.configobj.Section'>":
					print opts.section
					print '='*len(opts.section)
					for key in sub.keys():
						value = sub[key]
						if type(value) == type(list([])):
							print "%s: \n%s" % (key,"\n".join([" %s" % v for v in value]))
							print
						else:
							print "%s: %s" % (key,sub[key])
				else:
					print "%s: %s" % (opts.section, sub)
			return
		elif opts.list:
			L = []
			maxL = len('SECTION NAME')
			for server in config.keys():
				sub = config[server]
				if str(type(sub)) == "<class 'pylib.configobj.Section'>":
					try:
						action = sub['action']
					except KeyError, e:
						action = 'use'
					L.append((str(server),action))
					if maxL < len(str(server)):
						maxL = len(str(server))
			x=' '*(maxL/2)
			y="SECTION NAME%sACTION" % x
			print y
			print '='*len(y)
			L.sort()
			for s in L:
				print "%s%s%s%s" % (s[0],x,' '*(maxL-len(s[0])),s[1])
			return
	else:
		if opts.list:
			log.error("Nothing to list out, the configuration file does not yet ' \
				'exist or is missing.  %s" % filename)
			return
	# XXX


	if opts.save and not opts.section:
		log.warn('You specified the save option ("s/--save"), but did not ' \
			'specify a section.	If you are trying to save to a section, use the ' \
			'"--section" flag.')
		PyTis.toContinue()
		return


	if opts.save:
		# validate(opts, cfile, opts.section)

		excludes = []
		if cfile.exists: 
			title = 'updating config'

			if opts.section and config.get(opts.section) and str(type(config.get(opts.section))) == "<class 'pylib.configobj.Section'>" and config[opts.section].get('excludes',[]):
				excludes.extend(config[opts.section]['excludes'])
			elif config.get('excludes',[]):
				excludes.extend(config['excludes'])
		else:
			title = 'creating config'

		if opts.excludes and excludes:
			helptext= "Replace or merge excluded databases?  Press 'Y' to " \
				"REPLACE, 'N' to merge.   Replace [%s] with [%s]?" % \
				(','.join(excludes), ','.join(opts.excludes))
			try:
				if PyTis.getInputYN("Would you like to replace the excluded " \
				"databases with previously excluded databases ('N' to merge)?",
				helptext,option_always=[]):
					log.info("Excluded databases list replaced.")
				else:
					log.info("Excluded databases list merged.")
					opts.excludes.extend(excludes)
			except PyTis.QuitNow, e:
				log.info("bye!")
				sys.exit(0)

		# I like using the built in validate last, that way I don't undo the work
		# I did previous to writing this library feature.  This way I get to
		# utilize the more customized error messages above.

		# not sure I need to do this any futher, since the saveConfig technically
		# already calls validate_opt to get each value...
		# cfile.validateToSave(opts)

		cfile.saveConfig(opts, opts.section)
		log.info(title)
		log.info("your settings have been saved")

		return PyTis.toContinue()

	if not PyTis.trim(opts.action):
		log.warn('No options given.  To make sure this is not called by ' \
			'accident, by a user who is new to it, to simply run everything ' \
			'use "%s run".' % os.path.basename(sys.argv[0]))
		parser.print_usage()
		return

	cfile.validateToRun(opts)
	if PyTis.trim(opts.action) in ('use','run','test'):
		try:
			run(cfile, opts)
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return
		else:
			log.info("Done.")
			return
	elif opts.action and not PyTis.trim(opts.section):
		return parser.print_usage()
	elif PyTis.trim(opts.section):
		try:
			run(cfile, opts)
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return
		else:
			log.info("Done.")
			return
	else:
		parser.print_help("ERROR: Unknown, but invalid input.")
		sys.exit(0)

if __name__ == '__main__':
		main()

