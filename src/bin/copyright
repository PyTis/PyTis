#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		#
# 1.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							#
#		 http://www.PyTis.com/License/																						#
#																																							#
#		 Copyright (c) 2015 Josh Lee																							#
#																																							#
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the				 #
# License.																																		 #
#																																							#
# @auto-generated by the PyTis Copyright Tool on 05:54 06 Jun, 2015						#
############################################################################## #
"""copyright
=========
This tool will automatically edit files and add your copyright loaded from a 
template.	The use of this "template" can be over-ridden using the -t flag.

Features:
		*	Will not add copyright to file twice.
		*	Can determine best comment char to use for ini, html, php, and python.
		*	Manages multiple copyrights.
		*	Creates default copyright for you.

"""
import cStringIO
import datetime
import glob
import optparse
import os
import shutil
import sys
import pytis as PyTis

__author__ = 'Josh Lee'
__created__ = '06:14pm 09 Sep, 2009'
__copyright__ = 'PyTis'
__version__ = '1.5'
__configdir__ = '/home/ubuntu/.mycopyright'

comment_chars = {'php'					:	{'begin'	: '/*',
																		'middle' : '//',
																		'end'		: '*/',
																		'bin'		: 'php',
																		'ext'		: ['.php','.php4','.php5', 
																								'phtml']},
								 'javascript'	 :	{'begin'	: '/*',
																		'middle' : '//',
																		'end'		: '*/',
																		'bin'		: None,
																		'ext'		: ['.js']},
								 'ini'					:	{'begin'	: ';',
																		'middle' : ';',
																		'end'		: ';',
																		'bin'		: None,
																		'ext'		: ['.ini']},
								 'python'			 :	{'begin'	: '#',
																		'middle' : '#',
																		'end'		: '#',
																		'bin'		: 'python',
																		'ext'		: ['.py', '.pyw']},
								 'html'				 :	{'begin'	: '<!-- ',
																		'middle' : '-',
																		'end'		: ' -->',
																		'bin'		: None,
																		'ext'		: ['.html','.htm','.shtml',
																								'.dhtml','.xml']},
								 'css'					:	{'begin'	: '/*',
																		'middle' : '//',
																		'end'		: '*/',
																		'bin'		: None,
																		'ext'		: ['.css']}
}


# =============================================================================
# Begin Helpers
# -----------------------------------------------------------------------------

# I like this way more, but the other is easier to understand
def func(method):
		global comment_chars
		def _(func):
				comment_chars[func.__name__][method] = func
		return _

def apply(func):
		global comment_chars
		comment_chars[func.__name__]['apply'] = func

def check(func):
		global comment_chars
		comment_chars[func.__name__]['check'] = func

# -----------------------------------------------------------------------------
# End Helpers
# =============================================================================

# =============================================================================
# Begin Check Functions
# -----------------------------------------------------------------------------

def generic_check(fi,cp,lang):
		global comment_chars
		pcp = prettyCopyright(cp, comment_chars[lang])

		handle = open(fi,'r')
		lines = handle.readlines(-1)
		handle.seek(0)
		body = handle.read(-1)
		handle.close()

		if pcp in body:
				raise PyTis.DuplicateCopyright, "This file already has been " \
										"copyrighted with an identical copyright." 
		for line in lines:
				if 'copyright' in line.lower() or 'license' in line.lower():
						if comment_chars[lang]['begin'] in line or \
								comment_chars[lang]['middle'] in line:
								return False 
		else:
				return True

@check
def javascript(fi,cp):
		return generic_check(fi,cp,'javascript')

@check
def python(fi,cp):
		return generic_check(fi,cp,'python')

@check
def css(fi,cp):
		return generic_check(fi,cp,'css')

@check
def ini(fi,cp):
		return generic_check(fi,cp,'ini')

@check
def php(fi,cp):
		return generic_check(fi,cp,'php')

@check
def html(fi,cp):
		return generic_check(fi,cp,'html')

# -----------------------------------------------------------------------------
# End Check Functions
# =============================================================================

# =============================================================================
# Begin Apply Functions
# -----------------------------------------------------------------------------
@apply
def javascript(fi,cp):
		global comment_chars

		# create a backup incase we have some error writting the backup
		backup = os.path.abspath(os.path.join(os.path.dirname(fi),
																					".%s.bak" % os.path.basename(fi)))
		shutil.copy(fi,backup)

		# get the copyright ready
		pcp = prettyCopyright(cp,comment_chars['javascript'])

		try:
				handle = open(fi,'r')
				lines = handle.readlines(-1)
				handle.close()
				nhandle = open(fi,'wb')

				# BEGIN HANDLE EMPTY
				# simplest case, the file is empty.
				if not lines:
						nhandle.write(pcp)
				# END HANDLE EMPTY

				else:
						nhandle.write(pcp)
						nhandle.writelines(lines[0:])

		except Exception, e:
				print e 
				# we messed up, restore from backup
				try:
						handle.close()
				except:
						pass
				try:
						nhandle.close()
				except:
						pass
				shutil.move(backup, fi)
				raise Exception, str(e)
		else:
				nhandle.close()
				os.unlink(backup)
				return True
@apply
def ini(fi,cp):
		global comment_chars

		# create a backup incase we have some error writting the backup
		backup = os.path.abspath(os.path.join(os.path.dirname(fi),
																					".%s.bak" % os.path.basename(fi)))
		shutil.copy(fi,backup)

		# get the copyright ready
		pcp = prettyCopyright(cp,comment_chars['ini'])

		try:
				handle = open(fi,'r')
				lines = handle.readlines(-1)
				handle.close()
				nhandle = open(fi,'wb')

				# BEGIN HANDLE EMPTY
				# simplest case, the file is empty.
				if not lines:
						nhandle.write(pcp)
				# END HANDLE EMPTY

				else:
						nhandle.write(pcp)
						nhandle.writelines(lines[0:])

		except Exception, e:
				print e 
				# we messed up, restore from backup
				try:
						handle.close()
				except:
						pass
				try:
						nhandle.close()
				except:
						pass
				shutil.move(backup, fi)
				raise Exception, str(e)
		else:
				nhandle.close()
				os.unlink(backup)
				return True

@apply
def css(fi,cp):
		global comment_chars

		# create a backup incase we have some error writting the backup
		backup = os.path.abspath(os.path.join(os.path.dirname(fi),
																					".%s.bak" % os.path.basename(fi)))
		shutil.copy(fi,backup)

		# get the copyright ready
		pcp = prettyCopyright(cp,comment_chars['css'])

		try:
				handle = open(fi,'r')
				lines = handle.readlines(-1)
				handle.close()
				nhandle = open(fi,'wb')

				# BEGIN HANDLE EMPTY
				# simplest case, the file is empty.
				if not lines:
						nhandle.write(pcp)
				# END HANDLE EMPTY

				else:
						nhandle.write(pcp)
						nhandle.writelines(lines[0:])

		except Exception, e:
				print e 
				# we messed up, restore from backup
				try:
						handle.close()
				except:
						pass
				try:
						nhandle.close()
				except:
						pass
				shutil.move(backup, fi)
				raise Exception, str(e)
		else:
				nhandle.close()
				os.unlink(backup)
				return True


@apply
def html(fi,cp):
		global comment_chars

		# create a backup incase we have some error writting the backup
		backup = os.path.abspath(os.path.join(os.path.dirname(fi),
																					".%s.bak" % os.path.basename(fi)))
		shutil.copy(fi,backup)

		# get the copyright ready
		pcp = prettyCopyright(cp,comment_chars['html'])

		try:
				handle = open(fi,'r')
				lines = handle.readlines(-1)
				handle.close()
				nhandle = open(fi,'wb')

				# BEGIN HANDLE EMPTY
				# simplest case, the file is empty.
				if not lines:
						nhandle.write(pcp)
				# END HANDLE EMPTY

				else:

						# BEGIN HANDLE SHEBANG
						if '<!DOCTYPE' in lines[0]: # Kinda like the shebang line, 
																				# but could take a few lines.
								inline = 0
								while inline < len(lines):
										inline +=1
										if '>' in lines[inline]:
											 break

								nhandle.writelines(lines[0:inline])
								nhandle.write(pcp)
								nhandle.writelines(lines[inline:])
						# END HANDLE SHEBANG

						else:
								nhandle.write(pcp)
								nhandle.writelines(lines[0:])

		except Exception, e:
				print e 
				# we messed up, restore from backup
				try:
						handle.close()
				except:
						pass
				try:
						nhandle.close()
				except:
						pass
				shutil.move(backup, fi)
				raise Exception, str(e)
		else:
				nhandle.close()
				os.unlink(backup)
				return True

@apply
def python(fi,cp):
		global comment_chars

		# create a backup incase we have some error writting the backup
		backup = os.path.abspath(os.path.join(os.path.dirname(fi),
																					".%s.bak" % os.path.basename(fi)))
		shutil.copy(fi,backup)
		
		# little fix for encoding bug,...
		cp = cp.replace("\xa9", "(c)")


		# get the copyright ready
		pcp = prettyCopyright(cp,comment_chars['python'])

		try:
				handle = open(fi,'r')
				lines = handle.readlines(-1)
				handle.close()
				nhandle = open(fi,'wb')

				# BEGIN HANDLE EMPTY
				# simplest case, the file is empty.
				if not lines:
						nhandle.write(pcp)
				# END HANDLE EMPTY

				else:

						# BEGIN HANDLE SHEBANG
						if lines[0].startswith('#!/'): # shebangline
								nhandle.write(lines[0])
								nhandle.write(pcp)
								nhandle.writelines(lines[1:])
						# END HANDLE SHEBANG

						else:
								nhandle.write(pcp)
								nhandle.writelines(lines[0:])

		except Exception, e:
				print e 
				# we messed up, restore from backup
				try:
						handle.close()
				except:
						pass
				try:
						nhandle.close()
				except:
						pass
				shutil.move(backup, fi)
				raise Exception, str(e)
		else:
				nhandle.close()
				os.unlink(backup)
				return True


@apply
def php(fi, cp):
		global comment_chars
		# create a backup incase we have some error writting the backup
		backup = os.path.abspath(os.path.join(os.path.dirname(fi),
																					".%s.bak" % os.path.basename(fi)))
		shutil.copy(fi,backup)

		# get the copyright ready
		pcp = prettyCopyright(cp,comment_chars['php'])

		try:
				handle = open(fi,'r')
				lines = handle.readlines(-1)
				handle.close()
				nhandle = open(fi,'wb')

				# BEGIN HANDLE EMPTY
				# simplest case, the file is empty.
				if not lines:
						nhandle.write("<?\n")
						nhandle.write(pcp)
						nhandle.write("?>\n")
				# END HANDLE EMPTY

				else:

						# BEGIN HANDLE SHEBANG
						if lines[0].startswith('#!/'): # shebangline
								nhandle.write(lines[0])
								nhandle.write(pcp)
								nhandle.writelines(lines[1:])
						# END HANDLE SHEBANG
						
						# BEGIN HANDLE FILE STARTS IN HTML, or something other than PHP
						elif lines[0].find("<?") == -1:
								nhandle.write("<?\n")
								nhandle.write(pcp)
								nhandle.write("?>\n")
								nhandle.writelines(lines[0:])
						# END HANDLE FILE STARTS IN HTML, or something other than PHP

				# 3 cases left to handle, 
				# a <? on first line by itself
				# b <? on a line with code
				# c <? on a line that also has ?>
						
						# case c ( easier to do case b with an else
						elif '<?' in lines[0].strip() and '?>' in lines[0].strip():
								# just in case the are doing <?=$foo?> well just insert it on line 0
								nhandle.write("<?\n")
								nhandle.write(pcp)
								nhandle.write("?>\n")
								nhandle.writelines(lines[0:])

						# case a
						elif lines[0].strip() in ['<?', '<?php', '<?php4', '<?php5']:
								nhandle.write(lines[0])
								nhandle.write(pcp)
								nhandle.writelines(lines[1:])
								

						else: 
								nhandle.write("%s\n" % lines[0].split()[0])
								nhandle.write(pcp)
								nhandle.write("\n%s\n" % ' '.join(lines[0].split()[1:]))
								nhandle.writelines(lines[1:])

		except Exception, e:
				print e 
				# we messed up, restore from backup
				try:
						handle.close()
				except:
						pass
				try:
						nhandle.close()
				except:
						pass
				shutil.move(backup, fi)
				raise Exception, str(e)
		else:
				nhandle.close()
				os.unlink(backup)
				return True

# -----------------------------------------------------------------------------
# End Apply Functions
# =============================================================================

# =============================================================================
# Begin Copyright / License Applying functions
# -----------------------------------------------------------------------------

def loadCopyright(opts):
		"""
		Load a copyright from one of the template files.	Present a warning 
		if the file is empty.
		"""
		fi = tpath(opts,opts.file==None)
		try:
				handle = open(fi,'r')
		except (IOError, OSError), e:
				raise PyTis.FileNotFound, 'Template not found: %s' % fi

		body = handle.read(-1)
		handle.close()
		if not body.strip():
				raise PyTis.EmptyTemplate, "ERROR! The copyright template loaded " \
					"was empty.	Template file: %s" % os.path.abspath(fi)
		else:
			body = PyTis.ireplace('{year}',datetime.datetime.now().year,body)

		body = "%s\n@auto-generated by the PyTis Copyright Tool on %s" % (body, 
								datetime.datetime.now().strftime("%I:%M %m %b, %Y"))
		return body, fi

def prettyCopyright(cp,d):
		""" 
		Using data provided in the comment_chars, format the Copyright already
		loaded for it's filetype.
		"""

		b = cStringIO.StringIO()
		b.write(str("%s %s" % (d['begin'], d['middle']*80))[:80])
		b.write("\n")
		for line in cp.split("\n"):
				b.write("%s %s %s" % (d['middle'], 
													line.ljust(78- len(d['middle']*2) ),
													d['middle']))
				b.write("\n")

		b.write(str("%s %s" % (d['middle']*80, d['end']))[-80:])
		b.write("\n")
		return b.getvalue()

def fileType(fi):
		""" 
		For the given file :fi: find and return the dict object associated with
		this file defined in the above comment_chars.	If none is found return 
		none.
		"""
		def tryShebang(fi):
				# try to find a shebang line
				handle = open(os.path.abspath(fi),'r')
				lines = handle.readlines(-1)
				if lines:
						line = lines[0]
						for k,v in comment_chars.items():
								if v['bin'] and v['bin'] in line:
										return k,v
				return None, None

		try:
				ext = os.path.splitext(fi)[-1:][0]
		except IndexError, e:
				# no file extention, last resort
				return tryShebang(fi)

		for k,v in comment_chars.items():
				if ext in v['ext']:
						return k,v
						
		# not found in our data def comment_chars, try to find a shebang line
		return tryShebang(fi)


def checkCopyright(fi,data,cp):
		"""
		dispatch to correct checking func
		:fi: file in question
		:data: a bag of information about that file's language from comment_chars
		:cp: a copyright
		"""
		return data['check'](fi,cp)


def applyCopyright(fi, data, cp):
		"""
		For the given file :fi: insert the copyright text :cp: using the 
		appropriate comment strings defined in comment_chars and returned by the
		FileType function.
		"""
		return data['apply'](fi,cp)




def copyright(opts,args):
		""" 
		Do the nasty
		Errors to catch:
				class DuplicateCopyright(UserWarning): pass
				class EmptyTemplate(FileNotFound): pass
				class FileNotFound(UserWarning): pass
				class IdiotError(Exception): pass
				class QuitNow(Exception): pass
		"""
		cp, cpfile = loadCopyright(opts)
		files = PyTis.filesFromArgs(opts, args)
		log.info("FILES: %s" % files)
		if not files:
				raise PyTis.IdiotError, "No files to copyright" 

		force = False # if the user wants to force all
		fix = [] # a list of files that the user might want to check latter.a

		if cpfile in files or os.path.abspath(sys.argv[0]) in files:
				# The cannot copyright a the template file that the copyright was
				# loaded from, nor can they copyright this program, hell, they didn't
				# write it, I did.
				raise PyTis.IdiotError, "These files may not be copyrighted."

		def checkFoo():
				c = raw_input('[y/N/a (always) or q to quit] >>>').lower()
				if c not in ['y','n','q','a']:
						return checkFoo()
				if c == 'q':
						log.debug('user input quit')
						raise QuitNow, "User pressed quit."
				return c

		
		for f in files:
				ftype, data = fileType(f)
				log.info("File: %s" % f)
				log.info("ftype: %s" % ftype)
				log.info("data: %s" % data)

				if not ftype:
						msg = 'Skipping un-known filetype for: ', f
						log.info(msg)
						print msg
						continue
				try:
						if checkCopyright(f,data,cp):
								applyCopyright(f,data,cp)
						else:
								fix.append(f)
								if force:
										applyCopyright(f,data,cp)
								else:
										msg = "\nThis file appears to already have a copyright, " \
													"do you wish to add one anyway?\n\t%s" % f
										print msg
										log.debug(msg)
										c = checkFoo()
										if c == 'n':
												log.debug('user input no')
												continue
										elif c == 'a':
												log.debug('user input always')
												force = True
												applyCopyright(f,data,cp)
										elif c == 'y':
												log.debug('user input yes')
												applyCopyright(f,data,cp)
				
				except PyTis.DuplicateCopyright, e:
						log.info("duplicate, skipping: %s" % f)
						print '%s\nSkipping: %s' % (e,f)
				except PyTis.QuitNow, e:
						return False
		return fix

# -----------------------------------------------------------------------------
# End Copyright / License Applying functions
# =============================================================================

# =============================================================================
# Begin Path helper functions
# -----------------------------------------------------------------------------
def tpath(opts, default=False):
		"""
		template file path with file name
		"""
		global __configdir__
		if default:
				return os.path.abspath(os.path.join(__configdir__,'default.txt'))
		return os.path.abspath(os.path.join(__configdir__,"%s.txt" % \
		opts.file.strip().replace(' ', '_')))

def efpath(opts, default=False):
		"""
		edit template file path with file name
		"""
		global __configdir__
		if default:
				return os.path.abspath(os.path.join(__configdir__,'default.txt'))
		return os.path.abspath(os.path.join(__configdir__,"%s.txt" % \
		opts.edit.strip().replace(' ', '_')))

def nfpath(opts, default=False):
		"""
		new template file path with file name
		"""
		global __configdir__
		if default:
				return os.path.abspath(os.path.join(__configdir__,'default.txt'))
		return os.path.abspath(os.path.join(__configdir__,"%s.txt" % \
		opts.new.strip().replace(' ', '_')))

# -----------------------------------------------------------------------------
# End Path helper functions
# =============================================================================

# =============================================================================
# Begin Copyright creation / editing functions
# -----------------------------------------------------------------------------
def show(opts):
	cr, path= loadCopyright(opts)
	print cr
	return 

def tList(opts):
		global __configdir__
		print "Available Templates"
		print "==================="
		print
		i =1
		temps = {}
		for f in glob.glob(os.path.join(__configdir__,'*.txt')):
				n = os.path.basename(f).replace('.txt','')
				temps[str(i)]=n
				print " %s) %s" % (i,n)
				i+=1
		print 
		print "Enter a template number to edit, or any other key to quit"
		res = raw_input('>>> ').strip()

		if res in temps.keys():
				opts.edit = temps[res]
				fi = efpath(opts, False)
				print 'About to edit: ', fi
				PyTis.toContinue()
				return edit(fi, direct=True)
		else:
				return True

def createDefault(opts, fi=None):
		"""The contents of this file are subject to the YOUR COMPANY Public License Version
1.0 (the "License"); you may not use this file except in compliance with
the License. You may obtain a copy of the License at

		http://www.YOURSITE.com/License/
		
		Copyright \xa9 %s YOUR NAME

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the
License."""
		global __configdir__	
		if fi is None:
				fi = nfpath(opts, opts.new==None)
		if os.path.isfile(fi) and os.path.exists(fi):
			print "ERROR: A template with this name already exists in: %s.\n\n" \
			"**Please rename or remove this file first.\n" % __configdir__
			return PyTis.toContinue()

		handle = open(fi, 'wb')
		txt = createDefault.__doc__ % datetime.datetime.now().year
		handle.writelines(txt)
		handle.close()
		print 'The template "%s" has been created.' % fi
		edit(fi, direct=False)

def edit(fi, direct=False):
		"""
		Allows the user the option to edit a license/copyright template.
		"""
		ed = os.environ.get('EDITOR', os.environ.get('VISUAL')) 
		if direct:
				if ed:
						os.system("%s %s" % (ed, fi))
				else:
						print 'You may edit "%s" at any time.' % fi
				return PyTis.toContinue()
		else: 
				if raw_input('Would you like to edit the license/copyright '
										 'now? [y/N]').lower() in ['y','yes']:
						if ed:
								os.system("%s %s" % (ed, fi))
								print 'This license is now ready.'
						else:
								print 'You may edit "%s" at any time.' % fi
						return PyTis.toContinue()

				print 'You may edit "%s" at any time.' % fi
				return PyTis.toContinue()

# -----------------------------------------------------------------------------
# End Copyright creation / editing functions
# =============================================================================


# =============================================================================
# Begin Installation / Configuration Functions
# -----------------------------------------------------------------------------

def removeConfigDir(opath):
		for f in glob.glob(os.path.join(opath,'*.txt')):
				os.remove(f)
		try:
				os.rmdir(opath)
		except OSError, e:
				print
				print 'ERROR:'
				print 'Could not remove direcotry %s, this folder contains user files.'
				print

def addConfigDir(d):
		
		if raw_input('Create directory %s [y/N]: ' % d).lower().strip() == 'y':
				try:
						os.mkdir(d)
				except OSError, e:
						if 'File exists' in str(e):
								if raw_input('Directory already exists, use anyway? ' \
														 '[y/N]: ').lower().strip() == 'y':
										return True
								else:
										return False
						elif 'Permission denied' in str(e):
								print 'ERROR: You do not have permission to create this ' \
											'directory.'
								return False
						else:
								print e
								return 
				else:
						return True
		else:
				return False


def setConfig(d):
		global __configdir__
		mpath = os.path.abspath(sys.argv[0])
		handle = open(mpath, 'r')
		lines = handle.readlines(-1)
		handle.close()
		nfile_lines = []
		for line in lines:
				if line.startswith('__configdir__'):
						line = "__configdir__ = '%s'\n" % d
				nfile_lines.append(line)

		handle = open(mpath,'wb')
		handle.writelines(nfile_lines)
		handle.close()
		
def testConfig():
		global __configdir__
		if not __configdir__.strip() or \
		not os.path.exists(os.path.abspath(__configdir__)) or \
		not os.path.isdir(os.path.abspath(__configdir__)):
				return False
		return True

def config(opts):
		global __configdir__
		print
		oldpath = os.path.abspath(__configdir__)
		if __configdir__.strip()	and \
		os.path.isdir(os.path.abspath(__configdir__)) and \
		os.path.exists(os.path.abspath(__configdir__)):
				print 'CONFIG DIR was already set to:', oldpath
				if raw_input('Remove old CONFIG DIR? [y/N]').lower().strip() == 'y':
						removeConfigDir(oldpath)

		newpath = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),
																					 '.mycopyright'))
		print 'DEFAULT: %s' % newpath
		print "Path to data dir (leave blank to use default) q to quit "
		configdir = raw_input('>>>')
		if not configdir.strip():
				configdir = newpath

		if configdir == 'q':
				return sys.exit(0)
		if not addConfigDir(configdir):
				print "\nPlease try again."
				return config(opts)
		else:
				setConfig(configdir)
				createDefault(opts,
						os.path.abspath(os.path.join(configdir,'default.txt')))

# -----------------------------------------------------------------------------
# End Installation / Configuration Functions
# =============================================================================

def main():
		"""usage: copyright [optional: -t{TEMLATE}] [file(s)]"""
		global __configdir__
		global log
		hlp = __doc__
		if '-d' in sys.argv[1:] or '--debug' in sys.argv[1:]:
				hlp = "%s\n\n%s\n**Current template dir: '%s'**\n%s" % (hlp,
							'-'*80, __configdir__, '-'*80)

		parser = PyTis.MyParser()
		parser.extra_txt = """
CHANGE LOG:
	
	v1.5 MAJOR CHANGE
		Added in the [-s/--show] Option argument to allow the user to quickly 
		display a copyright template.

		No longer allows overwriting of an existing tempalte with the default one,
		if a user tries the [-n/--new] argument with an existing template name.
		This now throws a error to the user, prompting them to rename or remove 
		the existing template first.

	v1.4 MINOR CHANGE
		Added the ability to add a case-insensative {YEAR} variable into copyright
		templates. "{YEAR}" will be replaced with the current year.

		Added in this change log

	v1.3 No documentation available; However documentation may still exist in
	SourceForge PyTis SVN comments.

EXAMPLES:		
		copyright --newMyCopyright

		copyright -tMyCopyright *.php (apply MyCopyright to all php files in this 
				directory).

		copyright *.* -r (recursively apply default copyright to all files.

 """ 
		parser.set_description(hlp)
		parser.set_usage(main.__doc__)
		parser.formatter.format_description = lambda s:s
		# ----------------------------
		parser.add_option("-D", "--debug", action="store_true", default=False, 
										help="Enable debugging")

		parser.add_option("-v", "--version", action="store_true", default=False, 
											help="Display Version")

		parser.add_option("-V", "--verbose", action="store_true",
											default=False, 
											help="Be more Verbose")

		parser.add_option("-S", "--setup", action="store_true", default=False, 
											help="Runs setup to install this script")
		# ----------------------------
		temp = optparse.OptionGroup(parser, "Template Control")
		temp.add_option("-e", "--edit", action="store", default=None,
										metavar='[NAME]',
										help="Edit an existing Copyright/License Template file "
												 "using provided name.")

		temp.add_option("-l", "--list", action="store_true", default=False,
											help="List all available Copyright/License templates.")

		temp.add_option("-n", "--new", action="store", default=None,
										metavar='[NAME]',
										help="Generate a new Copyright/License Template file "
												 "using provided name.")

		temp.add_option("-s", "--show", action="store", default=None,
										metavar='[NAME]',
										help="Display a Copyright/License Template file "
												 "using provided name.")

		parser.add_option_group(temp)
		# ----------------------------
		prim = optparse.OptionGroup(parser, "Main")
		prim.add_option("-r", "--recursive", action="store_true", default=False,
											help="Recursively apply copyright to all files.")

		prim.add_option("-t", "--file", action="store", default=None,
										metavar='[NAME]',
										help="Template file to load your copyright from.	If "
												 "not specified the default will be used.")
		parser.add_option_group(prim)
		# ----------------------------

		(opts, args) = parser.parse_args()

		# Logging Configuration
		log = PyTis.set_logging(opts, 'copyright')

		log.debug("OPTS version: %s" % opts.version)
		log.debug("OPTS setup: %s" % opts.setup)
		log.debug("OPTS list: %s" % opts.list)
		log.debug("OPTS edit: %s" % opts.edit)
		log.debug("OPTS new: %s" % opts.new)
		log.debug("OPTS recursive: %s" % opts.recursive)
		log.debug("OPTS file: %s" % opts.file)

		if opts.version:
				return PyTis.version()
		try:
				if not testConfig():
						print "This tool is not configured properly, running setup."
						__configdir__ = None
						print 'INSTALLING'
						print '='*80
						return config(opts)

				if opts.setup:
						print 'INSTALLING'
						print '='*80
						return config(opts)

				if opts.new:
						return createDefault(opts)

				if opts.edit is not None:
						fi = efpath(opts, False)
						if not os.path.exists(fi) or not os.path.isfile(fi):
								print "Template not found: '%s'" % fi
								print "Try using the --list option to see available templates."
								return
						return edit(fi, direct=True)

				if opts.show:
					opts.file=opts.show
					return show(opts)

				if opts.list:
						return tList(opts)
				log.debug("args: %s" % args)
				if len(args) > 0:
						try:
								fix = copyright(opts, args)
						except (PyTis.EmptyTemplate, PyTis.FileNotFound), e:
								print str(e)
								sys.exit(1)
						except PyTis.IdiotError, e:
								print str(e)
						else:
								if fix:
										print '-'*80
										print "These files might have had a different copyright, " \
													"and you might want to \ncheck these files."
										print "\t", "\n\t".join(fix)
								return True
				return parser.print_help()

		except KeyboardInterrupt, e:
				print "\nbye!"
				return
		else:
				return

if __name__ == '__main__':
		main()

