# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		 #
# 1.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							 #
#		 http://www.PyTis.com/License/																						 #
#																																							 #
#		 Copyright (c) 2009 Josh Lee																							 #
#																																							 #
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the				 #
# License.																																		 #
#																																							 #
# @auto-generated by the PyTis Copyright Tool on 08:15 11 Nov, 2009						 #
############################################################################## #
""" This library started as a single file to hold just a few functions that I
repeatedly used.  Slowly it grew to include a universal config file loading,
saving, editing tool that is used by several of my scripts.  Eventually I wrote
a sub-class of the optparse.OptionParser, and my own logging file.  As with any
script library, this one has grown as my repetuir of scripts has.  Now I am
adding in several classes from pyservice.py Andrey Usov
(https://github.com/ownport/pyservice).  I tried to utilize his library for
daemonizing python scripts, but with no success.  I am going to have to
rewrite parts of it but I will be utilizing some of his classes.


"""
# builtin
import base64 as b64
import os
import re
import sys
import glob
import time
import errno
import pydoc
import atexit
import signal
import logging
import optparse
import resource
import itertools
import cStringIO
import traceback
#import thread
import threading
from UserDict import UserDict
from pprint import pprint


# internal (mine/yours/ours) 
from pylib import configobj as COBJ
from pylib import parse
import configure as pytis_configure # (imports configdir and logdir)
#from pylib import pyservice

__author__ = 'Josh Lee'
__created__ = '06:14pm 09 Sep, 2009'
__copyright__ = 'PyTis.com'
__configdir__ = pytis_configure.configdir # '/root/etc'
__logdir__ = pytis_configure.logdir # '/root/log'
__version__ = 4.1

__option_always__ = [False]
__input_options__ = ['y','N']

# #############################################################################
# Error Classes Below
# #############################################################################
class QuitNow(Exception): pass
class FileNotFound(UserWarning): pass
class EmptyTemplate(FileNotFound): pass
class DuplicateCopyright(UserWarning): pass
class IdiotError(Exception): pass
class FutureFeature(Exception): pass
class EmptyString(Exception): pass
class NoFiles(Exception): pass

class ArgumentError(UserWarning):
	opt_str=''
	val=''
	choices=()
	def __init__(self,message,opt_str='',val='',choices=()):
		UserWarning.__init__(self,message)
		self.opt_str=opt_str
		self.val=val
		self.choices=choices

	def __str__(self,errstr=None,opt_str='',val='',choices=()):
		if opt_str: self.opt_str=opt_str
		if val: self.val=val
		if choices: self.choices=choices
		buf = [] 
		if errstr:
			buf.append(str(errstr))
		if self.opt_str or self.val or self.choices:
			if self.choices:
				x = "(choose from %s)" % ','.join(["'%s'" % choice for choice in self.choices])
			else:
				x = ''
			buf.append("%s - ERROR: option %s: invalid choice: '%s' %s" % \
				(os.path.basename(sys.argv[0]),
				 self.opt_str,
				 self.val,
				 x))
		return "\n".join(buf)

# #############################################################################
# Custom Classes Below
# #############################################################################

# ============================================================================#
#class MyThread(threading.Thread):
class MyThread(object):

	_pid = None # Process ID
	_pidfile = None # Instance of Pidfile management class
	_callbacks = []
	_parent_file = None
	_parent_name = None
	_parent = None
	_opts = None 
	action = None
	default_frequency = 1
	running = False
	default_ioniceness = 4
	_ioniceness = None
	default_ioniceness_class = 2
	_ioniceness_class = None
	default_niceness = 10 
	_niceness = None

	def set_opts(self, opts):
		self._opts = opts
	def get_opts(self):
		if not self._opts: return optparse.Values()
		return self._opts
	opts = property(get_opts, set_opts)
	def setOpts(self,opts):
		self.opts=opts

	def set_parent_file(self, parent_file):
		self._parent_file = parent_file
	def get_parent_file(self):
		if not self._parent_file: self._parent_file = self.parent.__file__
		return self._parent_file
	parent_file = property(get_parent_file, set_parent_file)

	def set_parent_name(self, parent_name):
		self._parent_name = parent_name
	def get_parent_name(self):
		if not self._parent_name: 
			try:
				self._parent_name = os.path.basename(self.parent_file).split('.')[0]
			except: 
				self._parent_name = self.parent.__name__
		return self._parent_name
	parent_name = property(get_parent_name, set_parent_name)

	def set_parent(self, parent):
		self._parent = parent
	def get_parent(self):
		if not self._parent: self.parent = calling_module()
		return self._parent
	parent = property(get_parent, set_parent)

	def set_ioniceness_class(self, ioniceness_class):
		self._ioniceness_class = ioniceness_class
	def get_ioniceness_class(self):
		if not self._ioniceness_class: self.ioniceness_class = self.default_ioniceness_class
		return self._ioniceness_class
	ioniceness_class = property(get_ioniceness_class, set_ioniceness_class)

	def set_ioniceness(self, ioniceness):
		self._ioniceness = ioniceness
	def get_ioniceness(self):
		if not self._ioniceness: self.ioniceness = self.default_ioniceness
		return self._ioniceness
	ioniceness = property(get_ioniceness, set_ioniceness)

	def set_niceness(self, niceness):
		self._niceness = niceness
	def get_niceness(self):
		if not self._niceness: self.niceness = self.default_niceness
		return self._niceness
	niceness = property(get_niceness, set_niceness)

	def set_callbacks(self, i):
		self._callbacks.append(i)
	def get_callbacks(self):
		if not self._callbacks: return []
		return self._callbacks
	callbacks = property(get_callbacks,set_callbacks)

	def set_pid(self, pid):
		self._pid = pid
	def get_pid(self):
		if not self._pid: self.pidfile.pid
		return self._pid
	pid = property(get_pid, set_pid)

	def set_pidfile(self, pidfile):
		self._pidfile = pidfile
	def get_pidfile(self):
		if not self._pidfile: self._pidfile = Pidfile(self.parent_file)
		return self._pidfile
	pidfile = property(get_pidfile, set_pidfile)

	def __init__(self):
		global log
		if log is not None:
			self.setLogFile(log)
		atexit.register(self.stop)
		#threading.Thread.__init__(self)

	def start(self):
		''' You should override this method when you subclass Process.
It will be called before the process will be runned via when you call caplital 
Start. '''
		#self.log.debug('override start')
		pass

	def stop(self):
		''' You should override this method when you subclass Process.
It will be called after the process has been stopped or interupted by
signal.SIGTERM'''
		#self.log.debug('override stop')
		pass

	def setLogFile(self, log):
		self.log=log
	
	def control(self, action):
		action = action.lower().title()
		if action not in ('Start','Stop','Restart','Status'):
			log.error("Invalid control action, must be in <start,stop,restart,status>")
		try:
			getattr(self, action)()
		except RuntimeError, e:
			print >> sys.stderr, e

	def service(self, opts):
		''' alias for self.control with the "action" pulled out of opts and passed 
		in seperately
		'''
		try:
			self.action = opts.action
		except AttributeError,e:
			if type(opts) is type(str()) and  opts.lower() in ('start','stop',
			'restart','status'):
				self.action=opts
			else:
				raise ProgrammingError("optparse action is missing, to " \
					"use MyThread.service optparse must have a valid action " \
					"(start,stop,restart,status)")
		try:
			self.niceness = opts.niceness
		except AttributeError,e:
			self.niceness = self.default_niceness

		try:
			self.frequency = int(opts.frequency)
		except (AttributeError, NameError, ValueError), e:
			self.frequency = self.default_frequency

		return self.control(self.action)

	def register(self, run, *args,**kwargs):
		'''
    func - function to be called at exit
    targs - optional arguments to pass to func
    kargs - optional keyword arguments to pass to func
		'''
		c=Callback()
		c.setCallback(run)
		c.setArgs(*args)
		c.setKwArgs(**kwargs)
		self.callbacks = c

	def Start(self):
		stderr = sys.stderr
		old_pid = self.pidfile.validate()
		if old_pid:
			self.log.error("Error during service start:\n " \
				"Already running on PID %s (or pid file '%s' is stale)" % \
				(old_pid, self.pidfile.pidfile))
			return

		# Start the service
		self.log.info("starting the %s service now" % (self.parent_name))
		if self.daemonize():
			try:
				self.pidfile.create()
			except RuntimeError, err:
				# *IMPORTANT*  No matter what, this will not make it to the screen.
				# Even print statements won't make it to the screen from here.
				# This is already within the spawned child process with no open pipes
				# to the parent.  The best we can do is log.
				self.log.error("Error during service start: %s" % str(err))
				return

			atexit.register(self.remove_pid)
			self.start()
			try:
				self.keep_going = True
				self.running = True
#				thread.start_new_thread(self.Run, None, self.opts)
				t=threading.Thread(None,self.Run,None)
#				self.Run()
				t.start()
				#t.opts=self.opts
			#	t.join()
			except Exception, e:
				self.keep_going=False
				self.running=False
				self.log.error(e)
				#print >> sys.stderr, e
				raise Exception(e)
				return
			self.log.info('%s service started' % self.parent_name)
		else:
			self.log.info("Success, all done")
		return

	def _fork(self, fid):
		''' fid - fork id'''
		
		try:
			pid = os.fork()
		except OSError, e:
			self.log.error(
				"service._fork(), fork #%d failed: %d (%s)\n" % (fid, e.errno, e.strerror))
			raise OSError(e)
		return pid
	
	def daemonize(self):
		'''
do the UNIX double-fork magic, see Stevens' "Advanced
Programming in the UNIX Environment" for details (ISBN 0201563177)
http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
'''

		def _maxfd(limit=1024):
			''' Use the getrlimit method to retrieve the maximum file
descriptor number that can be opened by this process. If
there is not limit on the resource, use the default value
limit - default maximum for the number of available file descriptors.
'''
			maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
			if maxfd == resource.RLIM_INFINITY:
				return limit
			else:
				return maxfd
		
		def _devnull(default="/dev/null"):
			# The standard I/O file descriptors are redirected to /dev/null by default.
			if hasattr(os, "devnull"):
				return os.devnull
			else:
				return default

		def _close_fds(preserve=None):
			preserve = preserve or []
			for fd in xrange(0, _maxfd()):
				if fd not in preserve:
					try:
						os.close(fd)
					except OSError: # fd wasn't open to begin with (ignored)
						pass

		pid = self._fork(1) # first fork
		if pid == 0: # the first child
			os.setsid()
			pid = self._fork(2)
			if pid == 0: # the second child
				os.chdir("/")
				os.umask(0)
			else:
				os._exit(0)
			_close_fds(logging_file_descriptors())
		else:
			os._exit(0)

		os.open(_devnull(), os.O_RDWR)
		os.dup2(0, 1)	# standard output (1)
		os.dup2(0, 2)	# standard error (2)
		return True
    
	def remove_pid(self):
		if self.pidfile.validate():
			self.pidfile.unlink()
		self.log.info('the task completed, service was stopped')

	def _stop(self):
		self.keep_going=False
		self.stop()

	def Stop(self):
		pid = self.pidfile.validate()
		if not pid:
			self.log.error("pidfile %s does not exist. The %s service is not running." % (self.pidfile.pidfile, self.parent_name))
			return # not an error in a restart

		# Try killing the service process
		try:
			while 1:
				os.kill(pid, signal.SIGTERM)
				time.sleep(0.1)
		except OSError, err:
			err = str(err)
			if err.find("No such process") > 0:
				self.pidfile.unlink()
			else:
				self.log.error('Error during service stop, %s' % str(err))
				raise OSError(err)

		self.log.info('stopping %s [%s] service.' %(self.parent_name, pid))
		self.log.debug('service [%s] was stopped by SIGTERM signal' % pid)

	#def remove_pid(self):
	#	if self.pidfile.validate(): self.pidfile.unlink()

	def IsRunning(self):
		return bool(self.pidfile.validate())
	
	def RunningAndService(self):
		return self.running

	def Status(self):
		pid = self.pidfile.validate()
		if pid:
			try:
				os.kill(pid, 0)
				print 'process {} is running, pid: {}'.format(self.parent_name, pid)
				return
			except (OSError, TypeError):
				pass
		print "{} process is not running".format(self.parent_name)

	def Restart(self):
		self.log.info('restarting [%s] service.' % self.parent_name)
		self.Stop()
		self.Start()

	def Run(self):
		i=0
		os.nice(self.niceness)
		while self.keep_going:
			if not self.callbacks:
				self._run()
			else:	
				if self.frequency or ( not self.frequency and not i):
					for v in self.callbacks:
						callback = v.getCallback()
						args = v.getArgs()
						kwargs = v.getKwArgs()
						try:
							callback(*args,**kwargs)
						except (KeyboardInterrupt, QuitNow), e:
							print "\nbye!"
							self.keep_going = False
							self._stop()
							self.running=False
							return
						except Exception, e:
							self.log.error("Some error occured.")
							type_,value_,traceback_ = sys.exc_info()
							self.log.debug("type: %s" % type_)
							self.log.debug("type2: %s" %type(e))
							self.log.debug("value: %s" % value_)
							for tb_line in traceback.format_tb(traceback_):
								self.log.debug(tb_line)
							self.log.error(str(e))

				if not self.frequency and not i:
						self._stop()
						self.running=False
						return


			if self.frequency:
				time.sleep(self.frequency)
				
			try:
				if self.opts.debug:
					i+=1
					if i > 2: 
						self._stop()
						self.running=False
						return
			except (AttributeError, NameError), e:
				pass

	def _run(self):
		self.log.warn('running placeholder until callbacks are set')

# ============================================================================#
class Pidfile(object):
	''' Manage a PID file '''
	_filename = None  # just the name of the file with .pid extension on the end
	_pidfile = None # A.K.A. fullpath to file
	_path = None # path to save the PID file in, not including filename
	_name = None # name to create filename from, no extension
	_pid = None # PID (integer)
	log = None # log file

	caller = None

	def __init__(self, name=None):
		global log
		self.log = log
		self.name = os.path.basename(name)
		self.caller = calling_module()

	# --------------------------------------------------------------------------#
	# properties begin

	def set_log(self, log):
		self._log = log
	def get_log(self):
		if not self._log:
			global log; self._log=log
		return self._log
	log = property(get_log, set_log)
		# -------------------------------------- #
	def set_name(self, name):
		self._name = name
	def get_name(self):
		''' passed into new instance, or determined by the 'rename' method
		'''
		if not self._name: self.rename()
		return self._name
	name = property(get_name, set_name)
		# -------------------------------------- #
	def set_filename(self, filename):
		self._filename = filename
	def get_filename(self):
		''' self.name + .pid = filename
		'''
		if not self._filename: self._filename = "%s.pid" % self.name
		return self._filename
	filename = property(get_filename, set_filename)
		# -------------------------------------- #
	def set_path(self, path):
		self._path = path
	def get_path(self):
		''' determined based on OS, can be set on instance
		'''
		if not self._path:
			if os.name in ('posix'):
				rundir = '/run/'
			elif os.name in ('mac', 'os2', 'ce', 'riscos'):
				rundir = '/var/run/'
			elif os.name == 'nt':
				if self.caller is not None:
					rundir = os.path.join(os.path.dirname(self.caller.__file__), 'run/')
				else:
					rundir = os.path.join(os.path.dirname(__file__), 'run/')
			else:
				rundir = os.getcwd()
			self._path = os.path.abspath(rundir)
			if not os.path.isdir(self._path) or not os.path.exists(self._path):
				try:
					os.makedirs(self._path)
				except (OSError, IOError):
					self._path = os.path.join(self._path,'/user/')
					if not os.path.isdir(self._path) or not os.path.exists(self._path):
						os.makedirs(self._path)
				except (OSError, IOError):
					self._path = os.abspath(os.getcwd())
		return self._path
	path = property(get_path, set_path)
		# -------------------------------------- #
	def set_pidfile(self, pidfile):
		self._pidfile = pidfile
	def get_pidfile(self):
		''' if not set, use path + filename
		'''
		if not self._pidfile: 
			self._pidfile = os.path.abspath(os.path.join(self.path,self.filename))
		return self._pidfile
	pidfile = property(get_pidfile, set_pidfile)
		# -------------------------------------- #
	def set_pid(self, pid):
		self._pid = pid
	def get_pid(self):
		''' Actual Process ID as integer
		'''
		if not self._pid: self.pid=os.getpid()
		return self._pid
	pid = property(get_pid, set_pid)

	# properties end
	# --------------------------------------------------------------------------#
	# setter/getter methods begin

	def rename(self):
		self.caller = calling_module()
		if self.caller is not None:
			name = os.path.basename(self.caller.__file__)
		else:
			name = get_calling_file()
			if name is not None:
				name = os.path.basename(name)
		if name is None:
			name = self.__name__
		name=name.lower()
		try:
			self.name = name.split('.')[0]
		except IndexError, e:
			self.name = name

	def fixdirs(self):
		if not os.path.isdir(self._path) or not os.path.exists(self._path):
			try:
				os.makedirs(self._path)
			except (OSError, IOError):
				self.path = os.abspath(os.getcwd())
		return

	def fixpath(self,pidfile):
		self._pidfile=None
		self.fixdirs()
		try:
			pfile = open(pidfile,'w')
		except IOError, e:
			if self.caller is not None:
				rundir = os.path.join(os.path.dirname(self.caller.__file__), 'run/')
			else:
				rundir = os.path.join(os.path.dirname(__file__), 'run/')
			self.path = os.path.abspath(rundir)
			self.fixdirs()
			try:
				pfile = open(pidfile,'w')
			except IOError, e:
				self.path = os.path.abspath(os.getcwd())
			else:
				pfile.close()
		else:
			pfile.close()
		return

	# setter/getter methods end 
	# --------------------------------------------------------------------------#
	# begin methods 

	def create(self,attempt=0):
		''' create pid file
			Be very careful, simply accessing the path or pidfile property will set
			them, and in this case that is bad, because if this method finds the path
			set, and non-existant it will error out.  Accessing the pidfile accesses
			by-proxy, the path.
		'''

		pid = self.validate()
		if pid:
			if pid == os.getpid():
				# This, the current process/instance IS the PID, and it has already 
				# been created.
				return
			raise RuntimeError("Already running on PID %s " \
				"(or pid file '%s' is stale)" % (pid, self.pidfile))
				
		self.pid = os.getpid()

		# Write pidfile
		if self.path and not os.path.isdir(self.path):
			raise RuntimeError("%s doesn't exist. Can't create pidfile %s" % \
				(self.path, self.pidfile))

		try:
			pfile = open(self.pidfile,'w')
			pfile.write("%s\n" % self.pid)
			pfile.close()
		except IOError, e:
			self.fixpath(self.pidfile)
			if attempt > 1:
				raise RuntimeError(e)
			else:
				self.create(attempt+1)
		else:
			# set permissions to -rw-r--r--
			os.chmod(self.pidfile, 420)
			
	def unlink(self):
		""" delete pidfile"""
		try:
			#with open(self.pidfile, "r") as f:
			#	pid_in_file = int(f.read() or 0)
			os.unlink(self.pidfile)
		except:
			pass

	def validate(self):
		""" Validate pidfile and make it stale if needed"""
		if not self.pidfile or not os.path.exists(self.pidfile):
			return False
		try:
				pfile = open(self.pidfile, "r")
				pid = int(pfile.read(-1).strip())
				pfile.close()
				if pid <= 0:
					return
				try:
					os.kill(pid, 0)
					# old exiss, kill the old
					return pid
				except OSError, e:
					# could not kill the old for one reason or another
#					self.log.error("Pidfile.validate - OSError(%s)" % e)
					if e[0] == errno.ESRCH:
						return
					raise RuntimeError("Can not kill process [%s] or remove old PID file (%s), permission denied. - OSError(%s)" % (pid,self.pidfile,e))
		except IOError, e:
			self.log.error("Pidfile.validate - IOError(%s)" % e)
			if e[0] == errno.ENOENT:
				return
			raise RuntimeError("Pidfile.validate - IOError(%s)" % e)
		except ValueError, e:
			#self.log.info("likely the contents of the pid file could not be cast to an int: '%s'" % str(pid))
			self.log.debug("Pidfile.validate  - ValueError(%s)" % e)
			raise ValueError(e)

	# end methods
	# --------------------------------------------------------------------------#


# ============================================================================#
class ConfigFile(COBJ.ConfigObj):
	_filename = None
	_opts = {} 
	_fields = []
	_optional_fields = []
	_exists = None 

	config = None
	prompts = []

	'''
	def __getattr__(self,key):
		try:
			return dict.__getattr__(self, key)
		except AttributeError, e:
			try:
				return dict.__getitem__(self, key)
			except KeyError, e:
				return None
	'''
	# ###########################################################################
	# begin properties
	def set_exists(self):
		if os.path.exists(self.filename):
			self._exists = True
		else:
			self._exists = False
	def get_exists(self):
		if self._exists is None:
			self.set_exists()
		return self._exists
	exists = property(get_exists, set_exists)

	def set_fields(self, fields):
		self._fields = fields
	def get_fields(self):
		return self._fields
	fields = property(get_fields, set_fields)

	def set_optional_fields(self, optional_fields):
		self._optional_fields = optional_fields
	def get_optional_fields(self):
		return self._optional_fields
	optional_fields = property(get_optional_fields, set_optional_fields)

	def set_opts(self, opts):
		self._opts = opts
	def get_opts(self):
		return self._opts
	opts = property(get_opts, set_opts)

	def set_filename(self, fname=os.path.abspath(sys.argv[0])):
		self._filename=fname 
	def get_filename(self):
		if not self._filename:
			self.set_filename()
		return self._filename
	filename = property(get_filename, set_filename)
	# end properties
	# ###########################################################################

	def __init__(self, opts=None):
		self.filename = os.path.abspath(os.path.join(__configdir__, '%s.ini' % os.path.basename(os.path.abspath(sys.argv[0]))))
		if self.exists:
			self.config = self.getConfig(True)
		if opts:
			self.fields = opts.__dict__.keys()
			self.opts = dict(opts.__dict__.items())

	def honk(self):
		if self.config == None:
			if self.exists:
				self.config = self.getConfig()
			else:
				self.config = {}

	def __getitem__(self, key):
		self.honk()
		return self.config[key]
	
	def values(self):
		self.honk()
		return self.config.values()

	def keys(self):
		self.honk()
		return self.config.keys()

	def getConfig(self, force=False):
		self.config = COBJ.load(self.filename, force)
		return self.config

	def saveConfig(self, opts=optparse.Values, section=None):
		global log
		self.config = self.getConfig(True)
		if section:
			try:
				config = self.config[section]
			except KeyError, e:
				self.config[section] = {}
				config = self.config[section]
		else:
			config = self.config

		for k in self.opts.keys():
			if self.opts[k] is None or k not in self.fields:
				del self.opts[k]

		for fld in config.keys():
			sub = config[fld]
			if str(type(sub)) == "<class 'pylib.configobj.Section'>":
				pass
			elif self.exists and fld not in self.fields:
				del config[fld]
		
		for prompt in self.prompts:
			if self.opts.get(prompt, None) is not None:
				if not getInputYN("Are you sure you wish to save the %s?" % prompt, "This is not encrypted."):
					if prompt in self.opts.keys():
						del self.opts[prompt]
					if self.exists and prompt in config.keys():
						del config[prompt]
		
		try:
			if opts.debug:
				log.debug("Saving options to: '%s'" % self.filename)
		except (AttributeError, NameError), e:
			pass

		if section:
			self.config.update(self.opts)
		else:
			config.update(self.opts)
		#config.update(self.opts)
		self.config.save()

# ============================================================================#
class MyLogger(logging.Logger):
	opt_debug = False
	opt_full_verbose = False
	opt_verbose = False
	opt_had_verbose = False
	opt_quiet = False
	had_error = False
	had_warning = False

	def setopts(self, opts):
		try:
			self.opt_full_verbose = opts.totally_verbose
		except AttributeError as e:
			try:
				self.opt_full_verbose = opts.verbose
			except AttributeError as e:
				pass

		try:
			self.opt_verbose = opts.verbose
		except AttributeError as e:
			pass
		try:
			self.opt_debug = opts.debug
		except AttributeError, e:
			pass
		try:
			self.opt_quiet = opts.quiet
		except AttributeError, e:
			pass
		try:
			self.opt_had_verbose = opts.had_verbose
		except AttributeError, e:
			pass


	@property
	def hadWarning(self):
		return self.had_warning

	@property
	def hadErrors(self):
		return self.had_error

	def _log(self, level, msg, args, exc_info=None):
		"""
		Low-level logging routine which creates a LogRecord and then calls
		all the handlers of this logger to handle the record.
		"""
		if level == logging.ERROR:
			print >> sys.stderr, 'ERROR: ', msg
			self.had_error = True
		if level == logging.WARN and not self.opt_quiet:
			print 'WARNING: ', msg
			self.had_warning = True
		if level == logging.INFO and self.opt_verbose:
			print msg
		#if level == logging.DEBUG and self.opt_verbose and self.opt_debug:
		#	print msg
		#if level == logging.DEBUG and self.opt_full_verbose and self.opt_debug:
		#if level == logging.DEBUG and self.opt_verbose and self.opt_debug:
		if level == logging.DEBUG and self.opt_full_verbose and self.opt_debug:
			print( msg)

		if logging._srcfile:
			fn, lno, func = self.findCaller()
		else:
			fn, lno, func = "(unknown file)", 0, "(unknown function)"
		if exc_info:
			if type(exc_info) != types.TupleType:
				exc_info = sys.exc_info()
		record = self.makeRecord(self.name, level, fn, lno, msg, args, exc_info)
		self.handle(record)

# ============================================================================#
class MyParser(optparse.OptionParser):
	extra_txt = None
	helpishere = False
	py_args = []
	py_opts = []
	"""
	The below variable is new, but I want to have backwards compatability.  If you
	turn this variable on, and make set it to True then the print_help will hide the
	default help page which lists well formatted options and their help messages.  I
	choose to do this because while in the extra_txt, I usually provide additional
	help, in the current program I am working on the extra_txt represents an entire
	man page with greater detail on each individual option.  Therefore I do not wish
	to show the built-in, auto-generated help message as well.  Lastly, you won't
	actually set this variable directly, I am creating a setter and getter method to
	treat it as a property, which you should find under the __init__.
	"""
	_full_help_available = False

	def setFullHelpAvaiable(self):
		self._full_help_available=True


	'''
	def set_helpishere(self,b=True):
		self._full_help_available=b
	def get_full_help_available(self):
		return self._full_help_available
	full_help_available = property(get_full_help_available, set_full_help_available)
	'''

	def set_full_help_available(self,b):
		self._full_help_available=b
	def get_full_help_available(self):
		return self._full_help_available
	full_help_available = property(get_full_help_available, set_full_help_available)

	def __init__(self,
							 usage=None,
							 option_list=None,
							 option_class=optparse.Option,
							 version=None,
							 conflict_handler="error",
							 description=None,
							 formatter=None,
							 add_help_option=True,
							 prog=None,
							 epilog=None):

		optparse.OptionParser. __init__(self,
							 usage, option_list, option_class, version, conflict_handler, 
							 description, formatter, add_help_option, prog, epilog)


	def print_out(self, txt):
		import curses

		repstr = "\n"
		# repstr = ''
		# if '--help' in sys.argv: repstr = "\n"
		txt = txt.replace("`$",repstr)
		#txt = txt.replace("`$","")
		win=curses.initscr()
		max_x, max_y = win.getmaxyx()
		curses.endwin()
		if len(txt.split("\n")) > max_x:
			pager = pydoc.getpager()
			pager(txt)
		else:
			print txt


	def print_help(self, errors=None):
		"""
		NAME
		SYNOPSIS
		DESCRIPTION
		OPTIONS
		COMMANDS
		ENVIRONMENT
		SEE ALSO
		AUTHOR
		HISTORY
		VERSION
		"""
		buf = cStringIO.StringIO()
		sys.stdout = buf

		if not '--help' in sys.argv and self.extra_txt is not None:
			self.set_usage("%s\n%s" % (self.get_usage(), "*** USE '--help' for the full help page. ***"))

		if not (self.full_help_available and '--help' in sys.argv and self.extra_txt is not None):
			optparse.OptionParser.print_help(self)


		extras = ''
		if '--help' in sys.argv and self.extra_txt is not None and errors is None:
			"""
			try: extras = "Created: %s\n" % __created__
			except NameError: pass
			try: extras = "%sAuthor: %s\n" % (extras,__author__)
			except NameError: pass
			try: extras = "%sCopyright: %s\n" % (extras,__copyright__)
			except NameError: pass
			try: extras = "%sVersion: %s\n" % (extras,__version__)
			except NameError: pass
			if extras:
				self.extra_txt = "\n%s\n\n%s" % (self.extra_txt, extras)
			"""
			#print self.extra_txt
			self.print_out(self.extra_txt)
		if not errors:
			errrors = []
		elif not isinstance(errors, list):
			errors = [errors]

		if errors:
			print
			for error in errors:
				print "ERROR: %s" % error

		sys.stdout = sys.__stdout__
		self.print_out(buf.getvalue().replace("Options:\n","  -- OPTIONS:\n"))

# ============================================================================#
class Callback(object):
	def __init__(self):
		self.cb = None
		self.a = [] 
		self.k = {}

	def setCallback(self,cb): self.cb=cb
	def getCallback(self): return self.cb
	def setArgs(self,*a): self.a=a
	def getArgs(self): return self.a
	def setKwArgs(self,**k): self.k=k
	def getKwArgs(self): return self.k


class ImmutableDict(UserDict):
	""" This is a dictionary that enforces as set once and only once policy.
	Then if you try to overwrite a key with a new value, it will still maintain
	it's original value.

	The one and only option that gives this any flexibility, is to allow keys
	with empty values (None or '') to be re-assigned non-empty values, however
	this feature must be enabled.

	"""
	_reassign_empties = False

	def set_reassign_empties(self, b):
		self._reassign_empties =b 
	def get_reassign_empties(self):
		return self._reassign_empties
	reassign_empties = property(get_reassign_empties, set_reassign_empties)

	def __init__(self, **kwargs):
		self._keys = []
		UserDict.__init__(self, dict(kwargs))

	def __setitem__(self, key, item):
		if key in self._keys: 
			if not self.reassign_empties: return
			else:
				old_item = self.__getitem__(key)
				if old_item is None or (type(old_item) is str and old_item == ''):
					pass
				else: return

		UserDict.__setitem__(self, key, item)
		if key not in self._keys: self._keys.append(key)

	def setdefault(self, key, failobj = None):
		if key in self._keys: 
			if not self.reassign_empties: return
			else:
				old_item = self.__getitem__(key)
				if old_item is None or (type(old_item) is str and old_item == ''):
					pass
				else: return

		UserDict.setdefault(self, key, failobj)
		if key not in self._keys: self._keys.append(key)


class OrderedDict(UserDict):
	def __init__(self, dict = None):
		self._keys = []
		UserDict.__init__(self, dict)

	def __delitem__(self, key):
		UserDict.__delitem__(self, key)
		self._keys.remove(key)

	def __setitem__(self, key, item):
		UserDict.__setitem__(self, key, item)
		if key not in self._keys: self._keys.append(key)

	def clear(self):
		UserDict.clear(self)
		self._keys = []

	def copy(self):
		dict = UserDict.copy(self)
		dict._keys = self._keys[:]
		return dict

	def items(self):
		return zip(self._keys, self.values())

	def keys(self):
		return self._keys

	def popitem(self):
		try:
			key = self._keys[-1]
		except IndexError:
			raise KeyError('dictionary is empty')

		val = self[key]
		del self[key]

		return (key, val)

	def setdefault(self, key, failobj = None):
		UserDict.setdefault(self, key, failobj)
		if key not in self._keys: self._keys.append(key)

	def update(self, dict):
		UserDict.update(self, dict)
		for key in dict.keys():
			if key not in self._keys: self._keys.append(key)

	def values(self):
		return map(self.get, self._keys)
# ============================================================================#

# #############################################################################
# Util functions Below
# #############################################################################

def column_from_csv_file(fname, headers=False, col=0):
	col=column(col)
	lines=parse_csv_file(fname, headers) 
	#return list(itertools.izip_longest(*lines))[col]
	ret= list(itertools.izip_longest(*lines))[col]
	print ret
	return ret
		

def parse_csv_file(fname, headers=False):
	try:
		handle = open(os.path.abspath(fname),'r')
	except PermissionError as e:
		raise PermissionError(e)
	except (IOError, OSError) as e:
		raise FileNotFound('CSV File not found: %s' % fname)
	else:
		lines = handle.readlines(-1)
		records=[parse(l) for l in lines if parse(l) is not None and len(parse(l))]
		if headers and records:
			del(records[0])
		# I think we can just call del records[0] if headers but I want to test
		# this out a little first

	return records

def get_calling_file():
	""" Needs error checking """
	try:
		1/0
	except ZeroDivisionError:
		t = sys.exc_info()[2]
		return t.tb_frame.f_back.f_back.f_globals['__file__']
	return None

def calling_module():
	import inspect
	i=0
	while i < 10:
		try:
			frame,filename,line_number,function_name,lines,index=\
				inspect.getouterframes(inspect.currentframe())[i]
			if (filename != __file__):
				a=0
				b=0
				max_a=max_b=10
				while a < max_a: 
					try:
						frm = inspect.stack()[a]
					except IndexError, e:
						max_a = a
					mod = inspect.getmodule(frm[b])
					if mod.__file__ != __file__:
						return mod
					a+=1
					if a == max_a:
						a=0
						b+=1
					if b == max_b:
						break
		except IndexError, e:
			break
		i+=1
	return None

def getVersion(mod=None):
		if not mod: mod=calling_module()
		try:
				return mod.__version__
		except AttributeError, e:
				print >> sys.stderr, "Version not found."
		return 0.1

def optional_arg(arg_default,choices=[]):
	if choices and arg_default not in choices:
		raise IdiotError("Your arg_default was not in your supplied list of choices.")
	def func(option,opt_str,value,parser):
		if value:
			val=value
		else:
			if parser.rargs and not parser.rargs[0].startswith('-'):
				val=parser.rargs[0]
				parser.rargs.pop(0)
			else:
				val=arg_default
		if choices and val not in choices:
			parser.print_usage()
			buf = []
			metavar = option.metavar or "[%s]" % str(option.dest).upper()
			if option._short_opts:
				buf.append("%s %s" % (option._short_opts[0], metavar) )
			if option._long_opts:
				buf.append("%s=%s" % (option._long_opts[0], metavar) )
			buf=', '.join(buf)

#-A [ACTION], --action=[ACTION]
			print "\n%s\n\t %s\n" % (buf,option.help)
			print "%s - ERROR: option %s: invalid choice: '%s' (choose from %s)" % (os.path.basename(sys.argv[0]),opt_str,val,','.join(["'%s'" % choice for choice in choices]))
			sys.exit(0)
			#x = ArgumentError(None,opt_str,val,choices)
			#raise x
# cryptwatch: error: option -a: invalid choice: 'foo' (choose from 'start', 'stop', 'restart', 'status')
		if not str(val).strip():
			val = '_empty_val_trick_'
		setattr(parser.values,option.dest,val)
	return func

def getInput(question, helptext='No help for this command',example_or_hint=None,default=None,required=False):
	"""
	Full Name - press Enter for default: root
	if helptext:
		if required:
			Full Name [i.e. John Smith (required)]:
		else:
			Full Name [i.e. John Smith (or leave blank)]:
	else:
		if required:
			Full Name (required):
		else:
			Full Name:
	"""

	if helptext == 'No help for this command' or not helptext.strip():
		h=''
	else:
		h = '/?'

	if example_or_hint:
		if required:
			txt = '%s %s%s ' % (question,example_or_hint,h)
		else:
			txt = '%s %s (or leave blank)%s ' % (question,example_or_hint,h)
	else:
		if default and required and not example_or_hint:
			example_or_hint='(default "%s")' % default
		txt = '%s %s%s ' % (question,example_or_hint,h)

	try:
		res = raw_input("%s>>> " % (txt))
	except (KeyboardInterrupt,EOFError), e:
		print "\nInvalid input, press 'q' to quit or 'h' for help."
		return getInput(question,helptext,example_or_hint,default,required)

	if not res.strip() and required:
		if default:
			__option_always__ = [False]
			if getInputYN('Use default: %s?' % (default),
					'This will set the %s to the system default of "%s"' % (question,default),
					__input_options__,[]):
				return default
			else:
				if not example_or_hint: 
					example_or_hint='(default "%s")' % default
				return getInput(question,helptext,example_or_hint,default,required)

		else:
			print
			print 'Nothing entered "%s" is required, please try again.' % question
			print
			if not example_or_hint:
				example_or_hint='(default "%s")' % default
			return getInput(question,helptext,example_or_hint,default,required)

	if res.strip().lower() in ['h','?']:
		print "\nHELP (q to quit)" 
		print "\n\t? or "+'"h"'+" for this help"
		print "\ty for Yes"
		print "\tn for No"
		if helptext:
			if required:
				r="\t\tREQUIRED -\n "
			else:
				r=''
			print "\n%s" % fixWidth("%s%s"%(r,helptext))
		return getInput(question,helptext,example_or_hint,default,required)
	if res.strip().lower() == 'q':
		raise QuitNow, question
	else:
		return res


def getInputYN(question, helptext='No help for this command',input_options=__input_options__,option_always=__option_always__):

	if len(option_always):
		if option_always[0]:
			return True
		if 'a' not in input_options:
			input_options.append('a')

	if helptext == 'No help for this command' or not helptext.strip():
		pass
	elif '?' not in input_options:
		input_options.append('?')
	options = '/'.join(input_options)

	try:
		res = raw_input("%s [%s]>>> " % (question,options))
	except (KeyboardInterrupt,EOFError), e:
		print "\nInvalid input, press 'q' to quit or 'h' for help."
		if 'q' in input_options:
			if 'h' not in input_options:
				input_options.append('h')
		if 'q' not in input_options:
			input_options.append('q')
		return getInputYN(question,helptext,input_options,option_always)

	if not res.strip():
		print "Nothing entered, please try again."
		return getInputYN(question, helptext,input_options,option_always)
	if len(option_always) and res.strip().lower() == 'a':
		option_always[0] = True
		return True
	if res.strip().lower() == 'y':
		return True
	if res.strip().lower() == 'n':
		return False
	if res.strip().lower() in ['h','?']:
		print "\n\t? or h for this help"
		print "\ty for Yes"
		print "\tn for No"
		if len(option_always):
			print '\ta for always (skipping prompt from now on, always assuming yes.)'
		print "\nHELP (q to quit): \n%s\n" % fixWidth(helptext)
		return getInputYN(question, helptext,input_options,option_always)
	if res.strip().lower() == 'q':
		raise QuitNow, question
	else:
		print "Invalid input, please try again."
		return getInputYN(question, helptext,input_options,option_always)

def to80(s): return fixWidth(s)

def fixWidth(st):
	buf = list(st.split(" "))
	lines = []
	cur = ''
	for word in buf:
		if word=="\n":
			lines.append(cur)
			cur = ''
		elif len('%s %s' % (cur, word)) >= 79:
			lines.append(cur)
			cur = ''
		if cur:
			cur = "%s %s" % (cur,word)
		else:
			cur = word
	if cur:
		lines.append(cur)
	return "\n".join(lines)

def version(v):
	print "%s version: %s" % (os.path.basename(sys.argv[0]), v)

def set_logging(opts, name, __logdir__=__logdir__):
	global log
	if opts.debug:
		level=logging.DEBUG
		log_file = '%s.log' % name
	else: 
		level=logging.INFO
		log_file = 'pytis_tools.log'
	logging.basicConfig(
		filename = os.path.abspath(os.path.join(os.path.abspath(__logdir__), log_file )),
		level=level,
		format='%(asctime)s %(name)-10s %(levelname)-8s %(message)s',
		datefmt="%m.%d.%Y %H:%M:%S")
	logging.setLoggerClass(MyLogger)
	log = logging.getLogger(name)
	log.setopts(opts)
	
	try:
		version = opts.version
	except AttributeError as e:
		version = False
	if version != True:
		log.info("Starting %s at %s" % (name,prettyNow())) 

	try:
		totally_verbose = opts.totally_verbose
	except AttributeError as e:
		totally_verbose = True
	
	if not totally_verbose:
		buf = cStringIO.StringIO()
		sys.stdout = buf

	log.debug('-'*80) 
	# I want the output alphabatized, so I am going to create a list of tuples,
	# sort them, no wait, you know what would be faster? to just grab the keys,
	# sort those, request each value by key.
	opt_keys = list(opts.__dict__.keys())
	opt_keys.sort()
	for opt in opt_keys:
		value = opts.__dict__[opt]
	#for opt, value in opts.__dict__.items():
		if type(value) == type(str('')):
			if value.strip() == '_empty_val_trick_':
				value = ''
		if str(opt).lower() in ('cloud_checker_access_key','sr_secret_access_key',
			'db_password'):
			value = protect(value)

		log.debug("OPTION %s: %s" % (opt,value))
	log.debug('-'*80) 

	if not totally_verbose:
		sys.stdout = sys.__stdout__
		del buf
	return log

def homedir():
	""" Get Home directory path in Python for Windows and Linux
	"""
	#homedir = os.path.expanduser('~')
	# ...works on at least windows and linux. 
	# In windows it points to the user's folder 
	#	(the one directly under Documents and Settings, not My Documents)
	# In windows, you can choose to care about local versus roaming profiles.
	# You can fetch the current user's through PyWin32.
	#
	# For example, to ask for the roaming 'Application Data' directory:
	#	(CSIDL_APPDATA asks for the roaming, CSIDL_LOCAL_APPDATA for the local one)
	#	(See microsoft references for further CSIDL constants)
	try:
		from win32com.shell import shellcon, shell
		homedir = shell.SHGetFolderPath(0, shellcon.CSIDL_APPDATA, 0, 0)
	except ImportError: # quick semi-nasty fallback for non-windows/win32com case
		homedir = os.path.expanduser("~")
	return homedir

def prettyNow():
	import datetime
	return datetime.datetime.now().strftime("%I:%M%%s %m %b, %Y") % datetime.datetime.now().strftime("%p").lower()

def testFind(path):
	"""
	"""
	f=[]
	for root, dirs, files in os.walk(os.path.abspath(path), topdown=False):
		for name in dirs:
			fpath = os.path.abspath(os.path.join(root,name))
			for fname in glob.glob(os.path.join(fpath, '*.png')):
				f.append(fname)
	pprint(f)
	return f

def filesFromArgs(opts, args):
	""" 
	XXX:TODO unix only, need to make this so it would work on windows.
	XXX:TODO this thing needs sserious work, with recursive an no . in filenames
	import glob
	"""
	if opts.recursive:
		re = ''
	else:
		re = '-maxdepth 1'
	cd=os.curdir
	files = []
	for arg in args:
		if ('/' in arg or '\\' in arg):
			if (os.path.isfile(os.path.abspath(os.path.join(cd,arg))) and os.path.exists(os.path.abspath(os.path.join(cd,arg)))):
				files.append(os.path.abspath(os.path.join(cd,arg)))
				return files
			elif(os.path.isdir(os.path.abspath(os.path.join(cd,arg))) and os.path.exists(os.path.abspath(os.path.join(cd,arg)))):
				cmd = "find %s %s" % (re,os.path.abspath(arg))
			else:
				cmd = "find %s %s" % (re,arg)
		elif arg == '.':
			cmd = "find . * %s" % re
		else:
			cmd = "find . %s -type f -iname %s | grep -v .svn" % (re,arg)
		log.debug("CMD IS: %s" % cmd)
		cmd_out = os.popen(cmd).readlines(-1)
		for line in cmd_out:
			line = line.strip()
			if line and os.path.abspath(line) not in files \
				and os.path.isfile(line) and os.path.exists(line):
				files.append(os.path.abspath(line))
	return files

def fileTest(f):
	# ensure it is a valid real existing file 
	if not f.strip(): return False
	f = os.path.abspath(f)
	if not os.path.exists(f) or not os.path.file(f): return False
	return True

def dirTest(d):
	# ensure it is a valid real existing directory 
	if not d.strip(): return False
	d = os.path.abspath(d)
	if not os.path.exists(d) or not os.path.isdir(d): return False
	return True

def toContinue():
	""" Prompt the user to press a key to continue. Should probably use a pager
	most of the time though.
	"""
	if sys.platform in ('win32', 'win64'):
		os.system('PAUSE')
		sys.stdout.write("\n")
	elif sys.stdin.isatty():
		import tty
		sys.stdout.write('Press any key to continue . . .')
		tty.setraw(sys.stdin.fileno())
		try:
			sys.stdin.read(1)
		finally:
			os.system("stty sane")
		sys.stdout.write("\n")
	return

def dos2unix(fi):
	handle = open(fi,'r')
	contents = handle.read(-1)
	handle.close()
	nhandle = open(fi,'wb')
	nhandle.write(contents.replace("\r$","").replace("\r",''))
	nhandle.close()

def clearScreen():
	sys.stdout.write("\n")
	if sys.platform in ('win32', 'win64'):
		os.system('cls')
	elif sys.stdin.isatty():
		os.system('clear')
	return

def hello():
	import inspect
	i=0
	while i < 10:
		try:
			#print 'i',i
			frame,filename,line_number,function_name,lines,index=\
				inspect.getouterframes(inspect.currentframe())[i]
			print 'frame', frame
			print 'filename', filename
			print 'line_number',line_number
			print 'function_name',function_name
			print 'lines',lines
			print 'index',index
			print 'basename of filename', os.path.basename(filename)
			print '__file__', __file__
			if (filename != __file__):
				a=0
				b=0
				max_a = 5
				while a < max_a: 
					try:
						frm = inspect.stack()[a]
					except IndexError, e:
						max_a = a

					print dir(frm)

					mod = inspect.getmodule(frm[b])
					if '__FINDME__' in dir(mod):
						print '='*80
						print sys.argv[0]
						print 'FOUND IT'
						print 'filename', filename
						print 'i', i
						print 'a', a
						print 'b', b
						print 'FINDME = ', mod.__FINDME__
						print mod
						print dir(mod)
						print 'VERSION vvv'
						print mod.__version__
						print 'VERSION ^^^'
						print '='*80
						return mod
					print mod
					print dir(mod)
					a+=1
					if a == max_a:
						a=0
						b+=1
					if b == 5:
						break

			print '*'*80
		except IndexError, e:
			break
		i+=1

def traceCaller():
    i=0
    while i < 10:
        try:
            frame,filename,line_number,function_name,lines,index=\
                inspect.getouterframes(inspect.currentframe())[i]
            if (filename != __file__):
                a=0
                b=0
                max_a=max_b=10
                while a < max_a: 
                    try:
                        frm = inspect.stack()[a]
                    except IndexError, e:
                        max_a = a
                    mod = inspect.getmodule(frm[b])
                    if mod.__file__ != __file__:
                        return mod
                    a+=1
                    if a == max_a:
                        a=0
                        b+=1
                    if b == max_b:
                        break
        except IndexError, e:
            break
        i+=1
    return None

def logging_file_descriptors():
	''' logging file descriptors are used in core.Service.daemonize() '''
	return [handler.stream.fileno() for handler in [wr() for wr in
			logging._handlerList] if isinstance(handler, logging.FileHandler)]

def unique(L):
	ret = []
	for l in L:
		if l not in ret: ret.append(l)
	return ret

def protect(s,trim_len=4):
	""" padd a password and only show the remaining "trim_len" 
	example: protect('this now', 2) >> '******ow'
	example: protect('my password', 0) >> '**********'
	"""
	global log
	if len(s) == 0:
		return "''"
		#return '*'*8
	elif trim_len >= len(s):
		log.warn("Programming error in PyTis.protect; trim len passed is " \
			"actually longer than string passed.")
		return '*'*len(s)
	else:
		return '%s%s'%('*'*(len(s)-trim_len),s[(len(s)-trim_len):])

col2num = lambda col: reduce(lambda x, y: x*26 + y, [ord(c.upper()) - ord('A') + 1 for c in col])

def column(str_or_int):
	try:
		r = int(str_or_int)
	except ValueError:
		r = col2num(str_or_int)-1
	finally:
		return r

def simpleDecode(s=''):
	bencoded_txt = s.strip().encode('ascii')
	bdecoded_txt = b64.b64decode(bencoded_txt)
	return bdecoded_txt.decode('ascii')

def simpleEncode(s=''):
	bencoded_txt = s.strip().encode('ascii')
	return (b64.b64encode(bencoded_txt).decode('ascii'))

ireplace=lambda f,r,s: re.sub(r'(?i)%s'%str(f),str(r),str(s))


def main(): #global __version__
	print("PyTis toolkit library, version: %s" % str(__version__))
if __name__ == '__main__': sys.exit(main())



