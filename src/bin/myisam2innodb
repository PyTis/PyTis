#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		#
# 1.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							#
#		 http://www.PyTis.com/License/																						#
#																																							#
#		 Copyright (c) 2008-2013 Josh Lee																				 #
#																																							#
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the				 #
# License.																																		 #
#																																							#
# @auto-generated by the PyTis Copyright Tool on 03:06 08 Aug, 2013						#
############################################################################## #
"""myisam2innodb
================
"""

# built in 
import os
import sys
import getpass
import optparse
import subprocess
# third party
import pytis as PyTis


__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee'
__created__ = '11:25pm 08 Aug, 2013'
__copyright__ = 'PyTis.com'
__version__ = 2.5

def get_all_tables(opts):
	mysql,mysql_for_log=mysql_line(opts)
	exe = "echo 'SHOW TABLES;' | %s" % mysql
	exe_log = "echo 'SHOW TABLES;' | %s" % mysql_for_log
	log.debug('get_all_tables(opts): %s' % exe_log)
	p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=True)
	while True:
		retcode = p.poll()
		line = p.stdout.readline()
		if line:
			yield line.strip()
		if retcode is not None:
			break

def find_user():
	log.info('No user provided, attempting to retrieve current system user')
	user = getpass.getuser()
	log.info('Found: %s' % user)
	return user

def test_mysql(opts):
	mysql,mysql_for_log=mysql_line(opts)
	exe = "echo 'SELECT 1;' | %s"%mysql
	exe_log = "echo 'SELECT 1;' | %s"%mysql_for_log
	log.debug('test_mysql(opts): %s' % exe_log)
	p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=True)
	while True:
		retcode = p.poll()
		line = p.stdout.readline()
		if line:
			if line.strip().startswith('ERROR 1045 (28000): Access denied for user'):
				log.warn(line.strip())
				sys.exit(1)
			elif line.strip() == '1':
				return True
			else:
				log.warn('Unknown error, but connection to mysql could not be established.')
				log.debug('line: %s' % line.strip())
				sys.exit(1)
		if retcode is not None:
			break
	log.debug('Unknown connection failure')
	return False
	

__bag__ = []

def mysql_line(opts):
	global __bag__
	if __bag__:
		for_log='%s%s' % (__bag__[0],__bag__[2])
		line='%s%s' % (__bag__[0],__bag__[1])
		return (line,for_log)
	else:
		r=[]
		r.append('mysql')
		opts.user = opts.user or find_user()
		r.append('-u%s'%opts.user)
		host = '-h%s' % opts.host if opts.host else ''
		if host: r.append(host)
		port = '-P%s' % opts.port if opts.port else ''
		if port: r.append(port)
		r.append(opts.database)
		# password
		base=' '.join(r)
		password=opts.password or getpass.getpass('Password for %s: ' % opts.user)
		opts.password=password
		if opts.password:
			x='*'*8
			fakepass=" -p%s" % x
			password=' -p%s'%opts.password
		else:
			fakepass = ''
			password = ''
		__bag__=[base,password,fakepass]
		return mysql_line(opts)

def run(opts):
	global log, __bag__
	opts.user = opts.user or find_user()
	mysql,mysql_for_log=mysql_line(opts)
	if not test_mysql(opts):
		log.warn("Connection Failed.")
		sys.exit(1)
	
	if opts.backup:
		if opts.backup_file:
			fname = os.path.abspath(opts.backup_file)
		else:
			fname = os.path.abspath(os.path.join(os.getcwd(), '%s.sql' % opts.database))
		host = '-h%s' % opts.host if opts.host else ''
		exe='mysqldump -u%s%s %s %s > %s' % (opts.user,__bag__[1],host,opts.database,fname)
		log.debug("# %s" % exe)
		p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=True)
		while True:
			retcode = p.poll()
			line = p.stdout.readline()
			if line:
				log.debug(line.strip())
			if retcode is not None:
				break

	if opts.all:
		tables = get_all_tables(opts)
		tables = list(tables)[1:]
	else:
		tables = opts.table
	commands = []
	doit=False
	if opts.force: doit=True
	for table in tables:
#		command = "ALTER TABLE LIKE `%s` ENGINE=INNODB;" % table
		command = "ALTER TABLE `%s` ENGINE=INNODB;" % table
		if opts.force or getInputYN('Convert table `%s`' % table,"\n Do you want to run the following command? \n %s" % command):
			commands.append(command)
	cmds = "\t".join(commands)
	exe = "echo '%s' | %s" % (cmds,mysql)
	exe_log = "echo '%s' | %s" % (cmds,mysql_for_log)
	log.debug('run(opts): %s' % exe_log)
	if opts.dryrun:
		print cmds.replace("\t","\n")
	else: 
		p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=True)
		while True:
			retcode = p.poll()
			line = p.stdout.readline()
			if line:
				log.debug(line.strip())
			if retcode is not None:
				break
	return

def getInputYN(q,h=None):
	try:
		return PyTis.getInputYN(q,h)
	except KeyboardInterrupt, e:
		print "\nInvalid input, press 'q' to quit or 'h' for help."
		return getInputYN(q,h)

def tables_from_stdin(opts,args):
	t = []
	if len(args):
		for arg in args:
			if ',' in arg:
				for a in arg.split(','):
					t.append(a)
			elif ' ' in arg:
				for a in arg.split(' '):
					t.append(a)
			else:	
				t.append(arg)

	for arg in opts.table:
		if ',' in arg: 
			for a in arg.split(','):
				t.append(a)
		elif ' ' in arg:
			for a in arg.split(' '):
				t.append(a)
		else:	
			t.append(arg)

	t.sort()
	return t
	
def main():
	"""usage: %prog -d[DATABASE] -u[USER] <options>"""
	global log
	errors=[]
	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	parser.extra_txt = """

This tool was designed to convert databases to InnoDB, so that when done, I 
could move it to an encrypted hard drive, then link it back into the data dir.

After running this tool I generally run the following commands:

	(root@Dallas)-(/var/lib/mysql)-(02:07 PM Thu Oct 03)->
	> service mysql stop
	mysql stop/waiting

	(root@Dallas)-(/var/lib/mysql)-(02:09 PM Thu Oct 03)->
	> mv [dbname]/ /secret_drive/mysql/

	(root@Dallas)-(/var/lib/mysql)-(02:09 PM Thu Oct 03)->
	> ln -s /secret_drive/mysql/[dbname] .

	(root@Dallas)-(/var/lib/mysql)-(02:09 PM Thu Oct 03)->
	> chown -R mysql:mysql [dbname]

	(root@Dallas)-(/var/lib/mysql)-(02:09 PM Thu Oct 03)->
	> chown -h mysql:mysql [dbname]

	(root@Dallas)-(/var/lib/mysql)-(02:09 PM Thu Oct 03)->
	> service mysql start
	mysql start/running, process 19643

** Please note, I have written movedb to now run these commands for me.

examples:	

	myisam2innodb -uroot -p [dbname] --all >> prompts each table [y/N]
	myisam2innodb -uroot -p [dbname] -t[tablename] >> prompts for table [y/N]

	myisam2innodb -uroot -p [dbname] -f (FORCES) >> no prompts, but no tables

	** with the -f --force flag, you must specify -a,--all for all tables or a 
	-t[tablename]

	myisam2innodb -uroot -p [dbname] -f --all >> no prompts, all tables
	myisam2innodb -uroot -p [dbname] -f -t[tablename] >> no prompts, one table
		only

SEE ALSO:
	movedb

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

HISTORY:
	Original Author

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	parser.set_description(__doc__)
	parser.set_usage(main.__doc__)

	runtime = optparse.OptionGroup(parser, "Runtime Arguments")

	runtime.add_option("-a", "--all", action="store_true",
					 default=False, dest='all',
					 help="Convert all tables found on database.")

	runtime.add_option("-B", "--backup-file", action="store",
					 default=None, dest='backup_file',
					 help="Filename for database backup, only applies when used with -b/--backup.")

	runtime.add_option("-b", "--backup", action="store_true",
					 default=False, dest='backup',
					 help="Backup the database first, before altering.  If a backup name is not given to the -B/--backup-file then the database name will be used.")

	runtime.add_option("--dry-run", action="store_true",
					 default=False, dest='dryrun',
					 help="Do not actually alter the database, instead print the alter commands to STDOUT when done.")

	runtime.add_option("-f", "--force", action="store_true",
					 default=False, dest='force',
					 help="Dissable prompts. Commonly used when called by other programs, this will force "
						 "the program to run without asking for user input, attempting to run with "
						 "whatever input is given. Only errors are output.")

	runtime.add_option("-d", "--database", action="store",
					 default='', metavar='[DATABASE]', dest='database',
					 help="Database name, because this is required no flag is needed.")

	runtime.add_option("-t", "--table", action="append",
					 default=[], metavar='[TABLE]', dest='table',
					 help="Unless converting entire database, use this argument to specify a single table.")
	parser.add_option_group(runtime)
	# ----------------------------
	mysql = optparse.OptionGroup(parser, "MySQL Connection Arguments")

	mysql.add_option("-H", "--host", action="store",
					 default='localhost', metavar='[HOST]', dest='host',
					 help="Sets the hostname if other than localhost.")

	mysql.add_option("-P", "--port", action="store", type="int",
					 default=3306, metavar='[INT]', dest='port',
					 help="Use different port to connect to your MySQL db.")

	mysql.add_option("-p", "--password", action="store",
					dest='password', metavar="[PASSWORD]",
					help="Password for connecting to the MySQL db."
					 "If one is not provided via STDIN, user will be prompted.")

	mysql.add_option("-u", "--user", action="store",
					 default='',metavar="[USER]", dest='user',
					 help="User to connect as. If no user is provided current user will be used.")

	parser.add_option_group(mysql)
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "Debug")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging")

	dbgroup.add_option("-V", "--verbose", action="store_true",
					 default=False, dest='verbose',
					 #help=optparse.SUPPRESS_HELP)
					 help="Be more Verbose (make lots of noise)")

#	dbgroup.add_option("-q", "--quiet", action="store_true",
#					 default=False, dest='quiet'
#					 help="be vewwy quiet (I'm hunting wabbits)")

	dbgroup.add_option("-v", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")
	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()
#	if opts.quiet: opts.verbose=False

	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))

	if opts.version:
		return PyTis.version(__version__)

	if not opts.database and len(args):
		opts.database = args[0]
		del args[0]
	elif not opts.database:
		errors.append("ERROR: invalid input, look at the examples provided ( no database provided).")
	tables = tables_from_stdin(opts,args)
	opts.table=tables
	
	if not tables and not opts.all:
		errors.append("ERROR: no table(s) provided via argument or STDIN and the --all argument was not given.  No tables found to convert.")

	if errors:
		if len(args) == 0:
			return parser.print_usage()
		return parser.print_help(errors)
	try:
		
		log.debug("OPTS: %s" % opts)
		log.debug("ARGS: %s" % args)
		retcode = run(opts)
		log.debug("RAN run, return code of '%s'"%retcode)
		return retcode
	except PyTis.QuitNow, e:
		#if opts.verbose: print "Exiting now, bye!"
		print "\n"
		log.info("Exiting now, bye!")
	except KeyboardInterrupt, e:
		#if opts.verbose: print "\nbye!"
		print "\n"
		log.info("bye!")
	else:
		parser.print_help("ERROR: Unknown, but invalid input.")
		sys.exit(0)

if __name__ == '__main__':
	main()
