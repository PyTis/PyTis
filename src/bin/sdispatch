#!/usr/bin/env python
"""
This tool is useful for walking a project and finding web dispatch directories
quickly. It's output could be easily parsed to be used by another tool, to
update cherrypy configuration. 
"""
import datetime
import os
import sys
from cStringIO import StringIO
from optparse import OptionParser


def defaults():
    """By default, what directories are searched for?
    """
    return ['CSS', 'JS', 'IMAGES', 'IMGS', 'IMG']


def find_dirs(start, search_list):
    """
    :start: a path
    Return all directories that name are in the search list.
    Be Non-Case sensative.
    Be recursive in nature, walking directories stating from the start path.
    """
    results=[]
    for root, dirs, files in os.walk(os.path.abspath(start), topdown=False):
        for name in dirs:
            if name.upper() in [n.upper() for n in search_list]:
                fname = os.path.abspath(os.path.join(root,name))
                results.append(fname)
    return results


def lrm(ops, arg):
    """Remove an item from a list.
    :ops: an incomming list
    :arg: an item
    """
    return [x for x in ops if x.upper() <> arg.upper()]

def parse_options(parser, search_list):
    """Return a new list, removing certian directory names from that list.
    Also return the outbound filename.
    """
    (options, args) = parser.parse_args()
    if options.nocss:
        search_list = lrm(search_list, 'CSS')
    if options.nojs:
        search_list = lrm(search_list, 'JS')
    if options.noimage:
        search_list = lrm(search_list, 'IMAGES')
        search_list = lrm(search_list, 'IMGS')
    meta = dict(filename=options.filename,
                extended=options.extended)
    return search_list, meta

def options():
    """Set up an option parser.
    """
    parser = OptionParser()
    parser.add_option("-f", "--file", dest="filename",
                      help="write report to FILE", metavar="FILE")

    parser.add_option("-c", "--nocss", dest="nocss", default=False,
                      action="store_const", const=True,
                      help="Do not scan for CSS directories.")

    parser.add_option("-j", "--nojs", dest="nojs", default=False,
                      action="store_const", const=True,
                      help="Do not scan for JS directories.")


    parser.add_option("-i", "--noimage", dest="noimage", default=False,
                      action="store_const", const=True,
                      help="Do not scan for Image directories.")

    parser.add_option("-x", "--extended", dest="extended", default=None,
                      action="store", type='string',
                      help="Extended Functionality: Prints a web "\
                           "dispatch prefix in front of output.")

    parser.add_option("-d", "--directories", dest="dirs", type='string',
                      help='Also look for these directories. (Non case '\
                           'sensitive)',
                      action="callback", callback=dirs_accumulator)
    return parser

def dirs_accumulator():
    """Return an optParser callback and a getter to grab final results.
    The callback is an accumulator that will continuesly add new directories,
    as many times it is called.
    """
    dirs = []
    def get_dirs():
        return dirs
    def my_callback(option, opt, value, parser):
        if value not in dirs:
            dirs.append(value)
    return my_callback, get_dirs
dirs_accumulator, get_dirs = dirs_accumulator()

def out2file(output, fname):
    """Write the results to a file.
    """
    handle = open(fname, 'w')
    handle.write("%s" % output)
    handle.close()
    return

def process_out(results, meta):
    """Print the results to screen.
    """
    i = 0

    for path in results:
        if meta['extended']:
            dname = path.replace(os.path.abspath(os.curdir), '')
            if dname.startswith('/'):
                dname = dname[1:]
            opath = os.path.join(meta['extended'], dname)
            if i<len(opath):
                i = len(opath)

    handle = StringIO()
    handle.write("# AUTOGENERATED by sdispatch ON '%s'\n" % \
        datetime.datetime.now())
    handle.write("# sdispatch %s\n" % ' '.join(sys.argv[1:]))
    for path in results:
        if meta['extended']:
            dname = path.replace(os.path.abspath(os.curdir), '')
            if dname.startswith('/'):
                dname = dname[1:]
            opath = os.path.join(meta['extended'], dname)
            spaces = i - len(opath) + 5
            handle.write("%s%s" % (opath, " "*spaces))
        handle.write("%s\n" % path)
    return handle.getvalue()

def main(extra_dirs=get_dirs):
    parser = options()
    scan_dir = os.path.abspath(os.curdir)
    search_list = defaults()
    #print 'defaults', search_list

    search_list, meta = parse_options(parser, search_list)
    #print 'restricted', search_list

    dirs = extra_dirs()
    #print 'dirs', dirs


    search_list.extend(dirs)
    #print 'final', search_list

    results = find_dirs(scan_dir, search_list)
    output = process_out(results, meta)
    if meta['filename']:
        return out2file(output, meta['filename'])
    else:
        print output
        return

if __name__ == '__main__':
    main()
