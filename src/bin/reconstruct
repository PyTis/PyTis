#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version  #
# 1.0 (the "License"); you may not use this file except in compliance with   #
# the License. You may obtain a copy of the License at             #
#                                       #
#   http://www.PyTis.com/License/                      #
#                                       #
#   Copyright (c) 2009 Josh Lee                       #
#                                       #
# Software distributed under the License is distributed on an "AS IS" basis,  #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   #
# for the specific language governing rights and limitations under the     #
# License.                                   #
#                                       #
# @auto-generated by the PyTis Copyright Tool on 05:08 11 Nov, 2009      #
############################################################################## #
"""reconstruct
===========

So one of my databases has been corrupted. To make matters worse, apparently
the code was broke for the last month, causing the last month of backups to be
practically worthless.

This tool will break my task up into parts, and do the
job for me. First, this must know how to connect to the database, and which
database is the "master." That is what the -d, -u, and -p flags are for. 
However, for convenience, you may instead simply provide a configuration like
INI file. For help with the format of this file, simply use this program to
generate a blank INI file. 

Example:

	reconstruct --ini=config.ini
Whereas config.ini does not actually exist, it
will however, as soon as you press enter. Then simply open and edit the file.

# reconstruct -uut3hax -dut3hax -T -s/home/ut3hax/backups -t/home/ut3hax/fixingnow
#            help="Run Mode, extracting the backups from a source to a "
             "destination, this is step one of our "
             "reconstruction." /home/ut3hax/fixingnow/home/ut3hax/backups
"""

import cStringIO, datetime, glob, optparse, os, shutil, sys
import pydoc
import logging; log=logging.getLogger('reconstruct')

from pprint import pprint
import MySQLdb
import pylib.configobj as COBJ

__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee'
__created__ = '06:02pm 11 Nov, 2009'
__copyright__ = 'PyTis'
__version__ = '1.0'

def version():
  print __version__

class MyParser(optparse.OptionParser):
  def print_help(self, errors=None):
    buf = cStringIO.StringIO()
    sys.stdout = buf
    print '='*80

    optparse.OptionParser.print_help(self)
    print """
examples:  
 """
    if errors:
      print errors 

    sys.stdout = sys.__stdout__
    pager = pydoc.getpager()
    pager(buf.getvalue())


# =============================================================================
# Begin Helpers
# -----------------------------------------------------------------------------
_table_handlers = {}
def setTableHandler(table, func, handlers=_table_handlers):
  _table_handlers[table] = func
def getTableHandler(table, handlers=_table_handlers):
  return _table_handlers.get(table, None)

def handle(proc):
  setTableHandler(proc.__name__, proc)
  
HOST=None
USER=None
PASS=None
DB=None

def dbconn(*a, **k):
  global HOST, USER, PASS, DB
  def new_conn():
    conn = MySQLdb.connect(HOST,USER,PASS,DB)
    try:
      cursor = conn.cursor(*a, **k)
      cursor.execute("SHOW TABLES")
      cursor.execute("SET AUTOCOMMIT=1;")
      cursor.close()
    except (MySQLdb.OperationalError, AttributeError):
      return new_conn()
    else:
      return conn
  return new_conn()

def createINI(opts):
  config = COBJ.fload(opts.ini)
  config.update({'HOST' : 'localhost', 'USER' : '', 'PASS' : '', 'DB' : ''})
  config.save()

def iniPath(opts):
  """ After step 1, to save the user from having to enter the username and
  password in again and again, plus because it would be anoying, we are going
  to save this information, which can be removed after the final step.
  """
  # so where do we save it to?
  return os.path.abspath(os.path.join(os.path.dirname(os.path.dirname(__file__)), '.recon.ini'))

def saveINI(opts):
  global HOST, USER, PASS, DB
  config = COBJ.fload(iniPath(opts))
  
  # case 1, step 1
  if opts.target is not None:
    config.update({'dest' : opts.target})
  # case 2, step 2
  else:
    config.update({'HOST' : HOST, 'USER' : USER, 'PASS' : PASS, 'DB' : DB})
  config.save()
  # finally, step 3 uses this stuff then deletes this file.

def loadINI(opts):
  global HOST, USER, PASS, DB
  config = COBJ.fload(opts.ini)
  HOST = config['HOST']
  USER = config['USER']
  PASS = config['PASS']
  DB = config['DB']
  return
  
def removeINI(opts):
  os.unlink(iniPath(opts))

# -----------------------------------------------------------------------------
# End Helpers
# =============================================================================

# =============================================================================
# Begin Work 
# -----------------------------------------------------------------------------
# -- STEP ONE --
def untars(opts):
  """ Untar the backups first
  We are going to make sure that our source dir and dest dir exist first
  """
  if not opts.source:
    print "Please specify a source directory."
    return False
  if not os.path.isdir(os.path.abspath(opts.source)):
    print "The source directory does not exist: %s" % os.path.abspath(opts.source)
    return False
  if not opts.target:
    print "please specify a target directory."
    return False
  if not os.path.isdir(os.path.abspath(opts.target)):
    print "The target directory does not exist: %s" % os.path.abspath(opts.target)
    return False

  tars = glob.glob(os.path.join(os.path.abspath(opts.source), '*.tar.gz'))
  for tar in tars:
    dest = os.path.abspath(os.path.join(os.path.abspath(opts.target), os.path.basename(tar)))
    shutil.copy(tar, dest)
    os.chdir(os.path.dirname(dest))
    cmd = "tar xvzf %s" % dest
    os.system(cmd)
    os.unlink(dest)

# -- STEP TWO --
def testRootCon(opts):
  """ make sure we have root access to the mysql db because we will be 
  creating and removing databases.
  """
  try:
    conn = dbconn()
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    cursor.execute("CREATE database foo_bunny_kangaroo;")
    cursor.execute("DROP database foo_bunny_kangaroo;")
    cursor.close()
  except MySQLdb.OperationalError, e:
    print 'ERROR: %s\nERROR NO: %s' % (e[1], e[0])
    sys.exit(0)

def testCon(opts):
  global HOST, USER, PASS, DB

  if opts.ini is None and not opts.password:
    opts.password = raw_input('password for user `%s`: ' % opts.user)

  if opts.ini:
    config = COBJ.load(os.path.abspath(opts.ini))
    try:
      HOST = config['HOST']
      USER = config['USER']
      PASS = config['PASS']
      DB = config['DB']
    except KeyError, e:
      return False
  else:
    HOST = opts.host
    USER = opts.user
    PASS = opts.password
    DB =  opts.database
  if not HOST:
    print 'No HOST specified'
    return False
  if not USER:
    print 'No Username specified'
    return False
  if not PASS:
    print 'No Password specified'
    return False
  if not DB:
    print 'No DB specified'
    return False

  if opts.verbose: print 'Connecting to master DB'
  conn = dbconn()
  if opts.verbose: print 'Status OK'

  return True

# -- STEP THREE --
def aServer(rec, cursor):
  check_sql = "SELECT * FROM servers WHERE server_id=%s AND customer_id=%s" % (rec['server_id'], rec['customer_id'])
  cursor.execute(check_sql)
  results = cursor.fetchall()
  print results

def primaryKey(opts, conn, database, table):

  msg = "examining '%s.%s'" % (database, table)
  log.debug(msg)
  if opts.verbose: print msg

  cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
  cursor = conn.cursor()
  sql = "DESC `%s`.`%s`;" % (database, table)
  cursor.execute(sql)
  rows = cursor.fetchall()
  msg = "Table: %s has no primary key, please create a manual table handler for migration" % table
  try:
    for r in rows:
      if r[3].strip():
        return r[0]
  except IndexError:
    raise KeyError, msg
  raise KeyError, msg


@handle
def hkey(opts, table, conn, new_db, temp_db): pass

@handle
def servers(opts, table, conn, new_db, temp_db): 
  key = primaryKey(opts, conn, temp_db, table)
  if key:
    print 'table %s key %s' % (table, key)
  else:
    print 'table %s missing key' % table

@handle
def zipcodes(opts, table, conn, new_db, temp_db): pass

@handle
def logs(opts, table, conn, new_db, temp_db): pass


def genericTable(opts, table, conn, new_db, temp_db):
  """
  msg = "examining '%s.%s'" % (temp_name, table[0])
  log.debug(msg)
  if opts.verbose: print msg
  sql = "DESC `%s`.`%s`;" % (temp_name, table[0])
  cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
  cursor.execute(sql)
  description = cursor.fetchall()
  print description
  pprint(description)
  """

  try:
    key = primaryKey(opts, conn, temp_db, table)
  except KeyError, e:
    print str(e)
    return
  else:
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    """
    CREATE TABLE `new_ut3hax`.`acl_temp` 
      ( `acl_id` bigint( 20 ) NOT NULL auto_increment , 
       `acl_name` varchar( 254 ) collate latin1_general_ci NOT NULL default '', 
       `acl_type` enum( 'GENERAL', 'MENU', 'OTHER' ) collate latin1_general_ci NOT NULL default 'GENERAL',
       `displayed_name` varchar( 255 ) collate latin1_general_ci NOT NULL default '', 
       `directory` varchar( 255 ) collate latin1_general_ci NOT NULL default '', 
       `link` varchar( 254 ) collate latin1_general_ci NOT NULL default '', 
       `image` varchar( 255 ) collate latin1_general_ci NOT NULL default '', 
       `admin_menu` enum( 'YES', 'NO' ) collate latin1_general_ci NOT NULL default 'NO',
       `top_menu` enum( 'YES', 'NO' ) collate latin1_general_ci NOT NULL default 'NO',
       `side_menu` enum( 'YES', 'NO' ) collate latin1_general_ci NOT NULL default 'NO',
       `side_menu_item` bigint( 20 ) unsigned NOT NULL default '0',
       `default_policy` enum( 'ALLOW', 'DENY' ) collate latin1_general_ci NOT NULL default 'ALLOW',
       `target` varchar( 255 ) collate latin1_general_ci NOT NULL default '' COMMENT 'Enter Null to use the default',
       `time_modified` timestamp NOT NULL default CURRENT_TIMESTAMP ,
       KEY `acl_id` ( `acl_id` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 COLLATE = latin1_general_ci PACK_KEYS =0 COMMENT = 'System';
       
       INSERT INTO `new_ut3hax`.`acl_temp` SELECT * FROM `ut3hax`.`acls`;
    """
    cursor.execute("SELECT * FROM %s WHERE %s = " % (table, key))
    print 'table %s missing key' % table



def handleTable(opts, table, conn, new_db, temp_db):
  """ Migrate all the records from the temp_db.table to the new_db.table
  """
  if getTableHandler(table):
    return getTableHandler(table)(opts, table, conn, new_db, temp_db)
  else:
    return genericTable(opts, table, conn, new_db, temp_db)

def run(opts):
  global HOST, USER, PASS, DB
  loadINI(opts)
  ini_path = iniPath(opts)
  log.debug('INI Path: %s' % ini_path)

  config = COBJ.load(ini_path)
  log.debug('loaded config')
  dest = config['dest']
  log.debug('sql directory: %s' % config['dest'])
  pat = os.path.abspath(os.path.join(os.path.abspath(config['dest']), '*.sql'))
  log.debug('glob pattern: %s' % pat)
  files = glob.glob(pat)
  files.sort()
  new_db = "new_%s" % DB
  for sqlfile in files:
    log.debug("found sql file: %s" % sqlfile)
  
    temp_name = "temp_%s_%s" % (DB, 
      os.path.splitext(os.path.basename(sqlfile))[0].replace('-','_'))

    conn = dbconn()
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    cursor.execute("SET AUTOCOMMIT=1;")
    cursor.execute("CREATE DATABASE IF NOT EXISTS %s;" % new_db)
    conn.commit()
    conn.close()
    DB = new_db
    conn = dbconn()
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    try:
      msg = 'createing temporary database: %s' % temp_name
      if opts.verbose: print msg; log.debug(msg)
      # create temp db
      cursor.execute("CREATE DATABASE IF NOT EXISTS %s;" % temp_name)

      try:

        msg = 'processing: %s' % sqlfile
        if opts.verbose: print msg; log.info(msg)
        cmd = "mysql -u%s -p%s %s < %s" % (USER, 
                          PASS,
                          temp_name,
                          os.path.abspath(sqlfile))
        conn.commit()
        #conn.close()
        # extract to temp db
        os.system(cmd)
        # get list of tables
        sql = "USE %s" % temp_name
        cursor.execute(sql)
        sql = "SHOW TABLES"
        cursor = conn.cursor()
        cursor.execute(sql)
        tables = cursor.fetchall()
        print 'tables'
        for table in tables:
          table = table[0]
          handleTable(opts, table, conn, new_db, temp_name)
          print "TABLE", table
          if table not in ('servers','Servers'):
            continue
          
        #for rec in cursor.fetchall():
        #  aServer(rec, cursor)
        ###############################################################
        # this is where YOUR customization goes.           |
        # -------------------------------------------------------------
        # for each table get primary key
        #sql = "SELECT * FROM `%s`.`servers`" % temp_name
        #cursor.execute(sql)
        #for rec in cursor.fetchall():
        #  aServer(rec, cursor)

        # for each table, for each record update or add to master db.
        return

      except MySQLdb.OperationalError, e:
        print 'ERROR: %s\nERROR NO: %s' % (e[1], e[0])
    finally:
      conn = dbconn()
      cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
      cursor.execute("DROP DATABASE IF EXISTS %s;" % temp_name)
      conn.commit()
      conn.close()

# -----------------------------------------------------------------------------
# End Work 
# =============================================================================

def main():
  """usage: reconstruct [optional: -t{TEMLATE}] [file(s)]"""
  hlp = __doc__

  parser = MyParser()
  parser.set_description(hlp)
  parser.set_usage(main.__doc__)
  parser.formatter.format_description = lambda s:s
  # ----------------------------
  parser.add_option("-D", "--debug", action="store_true",
           default=False, help="Enable debugging")
  parser.add_option("-v", "--version", action="store_true",
           default=False, help="Display Version")
  parser.add_option("-m", "--mode", action="store", type="int",
          default=0, metavar='[INT]',
          help="Mode, for which step to focus on, 1,2 or 3.")
  parser.add_option("-V", "--verbose", action="store_true", metavar='BOOLEAN', 
          default=False,
          help="Be more verbose")
  # ----------------------------
  prim = optparse.OptionGroup(parser, "Step 1: These are used when the mode declared is 1")
  prim.add_option("-s", "--source", action="store", metavar='[DIR]', 
          default=None,
          help="Source Directory")

  prim.add_option("-t", "--target", action="store", metavar='[DIR]', 
          default=None,
          help="Target Directory")

  parser.add_option_group(prim)
  # ----------------------------
  dbase = optparse.OptionGroup(parser, "Step 2: These are used when the mode declared is 2")
  dbase.add_option("-i", "--ini", action="store", metavar='[FILE]', 
          default=None,
          help="INI config of database information")

  dbase.add_option("-d", "--database", action="store", metavar='[DB]',
          default=None, help="Database")
  dbase.add_option("-o", "--host", action="store", metavar='[HOST]',
          default='localhost', help="Default: localhost")
  dbase.add_option("-p", "--password", action="store", metavar='[PASSWORD]',
          default=None, help="Password")
  dbase.add_option("-u", "--user", action="store", metavar='[USERNAME]',
          default=None, help="User Name")
  parser.add_option_group(dbase)
  # ----------------------------
  oboy = optparse.OptionGroup(parser, "Step 3: These are used when the mode declared is 3")

  parser.add_option_group(oboy)
  # ----------------------------
  (opts, args) = parser.parse_args()

  # Logging Configuration
  log.setLevel(0) 
  formatter = '%(levelname)-8s %(message)s'

  if opts.debug:
    logging.basicConfig(filename='/%s/reconstruct.log' % __curdir__,
              level=logging.DEBUG, 
              format=formatter)
  else:
    logging.basicConfig(filename='/%s/reconstruct.log' % __curdir__,
              level=logging.INFO,
              format=formatter)



  if opts.version:
    return version()
  if opts.mode not in (1,2,3):
    return parser.print_help("Invalid Mode.")


  if opts.mode == 1:

    msg = 'begining data extraction process'
    if opts.verbose: print msg; log.info(msg)

    untars(opts)

    msg = 'step one complete'
    if opts.verbose: print msg; log.info(msg)

    saveINI(opts)

    return

  if opts.mode == 2:
    if opts.ini is not None:
      try:
        if not testCon(opts):
          sys.exit(0)
      except MySQLdb.OperationalError, e:
        print 'ERROR: %s\nERROR NO: %s' % (e[1], e[0])
        sys.exit(0)
      except AttributeError, e:
        print str(e)
        sys.exit(1)
      except OSError, e:
        print str(e)
        createINI(opts)
        print "%s created, you may now edit this file" % opts.ini
        sys.exit(0)
      else:
        testRootCon(opts)
        saveINI(opts)
        print 'You are now ready to begin step 3.'
        return
    else:
      try:
        if not testCon(opts):
          sys.exit(0)
      except MySQLdb.OperationalError, e:
        print 'ERROR: %s\nERROR NO: %s' % (e[1], e[0])
        sys.exit(0)
      except AttributeError, e:
        print str(e)
        sys.exit(1)
      else:
        testRootCon(opts)
        saveINI(opts)
        print 'You are now ready to begin step 3.'
        return

  
  if opts.mode == 3:
    return run(opts)
  
  
  parser.print_help()

if __name__ == '__main__':
  main()
