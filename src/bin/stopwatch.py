#!/usr/bin/python
# encoding=utf-8
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 2.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2009 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 11:55 PM - 09 Sept, 2014      #
############################################################################## #
""" This is a simple class that is used to time how long commands take to run.

EXAMPLE CODE:
  # Passing True into the constructor, tells the stopwatch to reset it's timer
  # each and every time it is used/called.
  s=StopWatch(True)


  print("DynamoDB cleanup is now running %s " % \\
    datetime.datetime.now().strftime("%I:%M%%s %m %b, %Y") % \\
    datetime.datetime.now().strftime("%p").lower())
  sts_session, dynamo_client = gather_resources(account_number, region, s)
  print("obtaining dynamodb client - %s" % s)
  dynamo_client = sts_session.client('dynamodb')
  print("deleting resource dynamodb table: '%s' - %s" % (table_name, s))
  dynamo_client.delete_table(TableName=table_name)
  print('please wait (up to 2 minutes) - ', s)
  oops_count = 0
  while does_it_still_exist(dynamo_client, table_name, s) == True:
    sys.stdout.write('.')
    time.sleep(1)
    oops_count+=1
    if oops_count > 120:
      break
    sys.stdout.flush()
  sys.stdout.flush()
  print("\\ntable %s has been deleted - ( it took %s) " % (table_name, s))

EXAMPLE OUTPUT:
->./cleanup.py
  DynamoDB cleanup is now running 12:46pm 02 Feb, 2020
  creating STS connection
  STS connection created - 0.304 seconds
  obtaining dynamodb client -  27.22024918 miliseconds OR 0.0272 seconds
  obtaining dynamodb client - 0.0001 Âµ microseconds
  deleting resource dynamodb table: 'test_users' - 3.63469124 miliseconds OR
  0.0036 seconds
  please wait (up to 2 minutes) -  0.214 seconds
  ...........................................................
  table test_users has been deleted - ( it took 60.9334 seconds)

"""
import time

__all__ = ('StopWatch','Stopwatch')

# copied from my  (PyTis) library, slightly modified for Verizon Wireless.
__copyright__ = 'PyTis.com'
__author__ = 'Josh Lee'
__created__ = '06:14pm 09 Sep, 2014'
__modified__ '09:11am 02 Feb, 2020'
__version__ = 1.1


# Copied from my personal coding library.
class StopWatch():
  """
  Refer to __init__ for more documentation.
  """
  # the exact time this class was initialized, or time since reset was called.
  t = 0
  # there is a way to pause this, I don't know why I coded it, I'm not going
  # any further (adding in start, restart, etc.).
  _stopped=False
  # do you want this to show the total time since initialized, or since last
  # used?  If since last used, then pass True into the instance as you
  # initialize it.
  reset_each_call=False

  # decimals is used when formatting the output to be more "human-readable"
  decimals=4

  def __init__(self,reset_each_call=False):
    """

    The intention is for this class's instance to be treated as almost a
    singleton.  Look closely at the internal methods that I am overridding.

    Args:
      reset_each_call (boolean) : Tells this class instnace if it should call
        self.reset() each time the instance is referenced, even printed (look
        at the self.__str__ and self.__repr__) as examples.

    Returns:
      None

    Example usage:
      sw = StopWatch()
      print(dosomething(), sw)
      print(dosomething_else(), sw)
      print(and_done(), sw)

    Example (copy/paste) of REAL output:

     --> ./dynamodb.py
 >> Event Id: 07c3cbee-ec83-4451-963c-d80d85000ef6...0.0 Âµ microseconds..
 >> DynamoDB auto remediation function has been called 0.0001 Âµ microseconds
 >> obtaining dynamodb client - 7.6639 seconds
 >> obtaining dynamodb resource - 23.67544174 miliseconds OR 0.0237 seconds
 >> grabbing 'test_users' to read - 14.90569115 miliseconds OR 0.0149 seconds
 >> dynamodb.Table(name='test_users')
 >> describing table 'test_users' - 2.56061554 miliseconds OR 0.0026 seconds


    """
    self.t=time.time()
    self.reset_each_call=reset_each_call

  def __call__(self):
    """
    this could be a shortcut to stop or reset this timer
    """
    pass

  def __str__(self):
    """
    Print the time as a string (human readable / formatted)
    """
    return self.beautify(self.read())

  def __repr__(self):
    """
    Print the time as a string (unformatted)
    """
    return str(self.read())

  def read(self):
    """
    Calculate the current value from the timer, then reset the timer if the
    reset_each_call option is selected. 
    """
    if self._stopped:
      return self.t
    else:
      if self.reset_each_call: 
        r=(time.time()-self.t)
        self.reset()
        return r
      return (time.time()-self.t)

  def reset(self):
    """
    pretty self explanitory here.
    we evaluate how much time has been tracked, then reset the timmer it is
    running again.
    """
    self.t=time.time()
    self._stopped=False

  def stop(self):
    """
    pretty self explanitory here.
    we evaluate how much time has been tracked, then tell the timmer it is
    stopped.
    """
    self.t=time.time()-self.t
    self._stopped=True

  def beautify(self, t):
    """
    Args:
      t (float) : float representation of time.time instnace value

    Returns:
      Human readable value of time tracked.

    Make the output human friendly / readable.  
    Examples of Output:
      > 14.8730278 miliseconds OR 0.0149 seconds
      > 24.6193409 miliseconds OR 0.0246 seconds
      > 16.13354683 miliseconds OR 0.0161 seconds
      > 0.2569 seconds
      > 20.0882 seconds
    """
    t=float(t)

    if t > 0.1: return "%s seconds" % round(t, self.decimals)

    if t >= 0.001:
      if float(t) == float(0.001): label = ''
      else: label = 's'
      return "%s milisecond%s OR %s seconds" % (round(1000*t, self.decimals+4),
        label, round(t, self.decimals))

    if t >= 0.000001:
      if float(t) == float(0.000001): label = " Âµs microsecd"
      else: label = 'Âµ microseconds'
      return "%s %s" % (round(t,4), label)
Stopwatch=StopWatch

if __name__ == '__main__':
  import pydoc, sys
  pydoc.doc('stopwatch')
  sys.exit(0)

