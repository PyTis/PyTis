#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 2.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at:                        #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2009 - 2016 Josh Lee                                       #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 08:33 04 Apr, 2016            #
############################################################################## #
"""copytest
========

NAME:
  copytest

SYNOPSIS:
	copytest [--options] [-H] [-V] [-D]

DESCRIPTION:
	Simple program that helps me quickly open each file in vim, one after
	another.  I can press 'q' at any time to quit.  

CODE:

EXAMPLES:	
	copytest '*.php'

	copytest '*.php' -r << Notice the single quotes, '*.php' is passed into this
		program as an argument, so that the --recursive flag can be used.
	
	copytest .

	find . -iname '*.py' | xargs copytest

	copytest *.py << notice no single quotes, this is handled by the OS, and the
		[-r/--recursive] flag will not be used/usefull.


"""

import optparse
import os
import sys
import subprocess
import pytis as PyTis

__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee'
__copyright__ = 'PyTis'
__created__ = '04:55am 04 Apr, 2016'
__version__ = '1.0'

def get_editor():
	if sys.platform in ('win32', 'win64'):
		return 'notepad.exe'
	else:
		for line in os.popen('which vim').readlines(-1):
			line=line.strip()
			if line: return line
		for line in os.popen('which vi').readlines(-1):
			line=line.strip()
			if line: return line
		for line in os.popen('which nano').readlines(-1):
			line=line.strip()
			if line: return line
	return None

def myContinue(fi=None):
	if fi:
		txt = "About to edit: %s\nPress ENTER to continue... (or q to quit | " \
			"or s to skip)" % os.path.abspath(fi)
	else:
		txt = "Press ENTER to continue... (or q to quit | or s to skip)"

	try:
		res = raw_input("%s>>> " % (txt))
	except (KeyboardInterrupt,EOFError), e:
		print "\nInvalid input, press 'q' to quit or 'h' for help."
		return myContinue()
	else:
		if res.lower().strip() == 'q':
			raise PyTis.QuitNow()
		elif res.lower().strip() == 's':
			return False
		elif res.lower().strip() == 'h':
			print 'Enter "h" for help, "q" to quit, or any other key to continue ' \
				'to the next file.'
		else:
			return True

def run(opts,files):
	"""copytest run doc help"""
	for fi in files:
		PyTis.clearScreen()
		edit(fi)

def edit(fi):
	"""
	Allows the user the option to edit a license/copyright template.
	"""
	global log

	ed = os.environ.get('EDITOR', os.environ.get('VISUAL')) 
	if not ed: ed = get_editor()
	if ed:
		if not myContinue(fi):
			return
		os.system("%s %s" % (ed, fi))
	else:
		log.error('No editor could be found.')
		raise PyTis.QuitNow()
	return

def main():
	"""usage: copytest"""
	global __author__, __created__,__copyright__,__version__
	global __configdir__
	global log
	

	config_filename = os.path.abspath(os.path.join(PyTis.__configdir__, 
		'%s.ini' % os.path.basename(os.path.abspath(sys.argv[0]))))
	
	errors=[]
	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	parser.extra_txt = "\n\n%s\n" % run.__doc__ + """

SEE ALSO:

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

HISTORY:
	Original Author

CHANGE LOG:

CREATED:
	%(created)s

VERSION:
	%(version)s

""" % help_dict

	helpishere=False
	if '--help' in sys.argv: helpishere=True

	parser.formatter.format_description = lambda s:s
	if helpishere:
		parser.set_description(__doc__%help_dict)
	else: parser.set_description('')
	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")
	
	runtime.add_option("-R", action="store_true", default=False,
		metavar='recursive',
		help="Alias of the [-r/--recursive] flag.")
             
	runtime.add_option("-r", "--recursive", action="store_true", default=False,
		metavar='recursive',
		help="Default behavior: non-recursive, specify this to traverse " \
						"into sub-directories")
             
	runtime.add_option("-f", "--force", action="store_true", default=False,
	help="Dissable prompts. Commonly used when called by other programs, or in "
		"a cron job.  This will force the program to run without asking for user "
		"input, attempting to run with whatever input is given. Only errors are "
		"output.")

	parser.add_option_group(runtime)
	# -------------------------------------------------------------------------
	# variable setting
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")
	parser.add_option_group(vars)

	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging")

	dbgroup.add_option("-V", "--verbose", action="store_true",
					 default=True, dest='verbose',
					 help="Be more Verbose (make lots of noise)")

	# This is a little trick to tell if the user entered the -V/--verbose flag.
	# We want verbosity on by default, but we also want to know if the user
	# entered it for debug items, and providing end messages vs informed output.
	dbgroup.add_option("", "--totaly-verbose", action="store_true",
		default=False, dest='totally_verbose', 
		help=optparse.SUPPRESS_HELP)

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits)")

	dbgroup.add_option("-v", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()
	if opts.verbose: 
		opts.totally_verbose = True
	if opts.quiet: opts.verbose = False
	if not opts.quiet:
		opts.verbose = True

	if opts.debug:
		main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__, \
			os.path.abspath(config_filename))
	else:
		pass

	parser.set_usage(main.__doc__)

	old_version = opts.version
	opts.version = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	opts.version = old_version

	if opts.version: return PyTis.version(__version__)


	files = PyTis.filesFromArgs(opts,args)
	new_files = [f for f in files if not f.endswith('.swo') and \
		not f.endswith('.bak') and \
		not f.endswith('.pyc') and \
		not f.endswith('.swp') and \
		not f.endswith('.lvimrc') and not f.endswith('.htaccess')]
	new_files.sort()

	if len(new_files) == 0 and not errors:
		return parser.print_usage()
	elif not errors and new_files:
		try:
			run(opts, new_files)
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return 0
		except PyTis.QuitNow,e:
			if not opts.quiet:
				log.info("\nbye!")
			return 1
		else:
			log.info("Done.")
			return 0
	else:
		parser.print_usage()
		if errors:
			log.error(str("\n".join(errors)))
		return parser.print_help(errors)

	parser.print_help("ERROR: Unknown, but invalid input.")
	sys.exit(0)

if __name__ == '__main__':
		main()

