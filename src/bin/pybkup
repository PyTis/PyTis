#!/usr/bin/env python
"""pybkup
======

	 -T, --files-from FILE
				 get names to extract or create from FILE

	 -X, --exclude-from FILE
				 exclude patterns listed in FILE

Mind melting brainfuck on this, I cannot seem to stay focused.  What should
have taken a few hours, has turnned into a few weeks.  I am not sure why, but
it is obviously a flawed design, or lack thereof.  An issue has been brought to
my attention.  In the future these will all run from configurations pulled from
the databases, be it sqlLite3, MySQL or PostgreSQL is of no consiquence.
Either way we will want the data in a similar format, and still have to
validate it.  That being said, we will want to code for easy migration.  The
valid_config_values, valdiate, validate_opt, get_value, have all become a blur, with
out a defined reason or distinction between them.  I am not going to start from
scratch, but just look over it all from the beginning.  Let's see where that
takes us.  

"""

import os
import sys
import glob
import shutil
import optparse
import tempfile
import subprocess
import datetime

import pytis as PyTis
from pylib import configobj as COBJ

__author__ = 'Josh Lee'
__copyright__ = 'PyTis'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__created__ = '12:54am 03 Mar, 2014'
__version__ = '1.0'

__default_tar_flags__ = 'cvzf'

# ***IMPORTANT!*** 
# IF YOU ARE GOING TO EDIT THE DEFAULT COUNTERS BELOW, PLEASE REMOVE OR UPDATE
# THIS COMMENT BLOCK
# Default below would keep:
# daily for 2 weeks
# weekly for 2 months
# monthly for 2 years
# and no further (no yearly copies)
__default_days__ = 14
__default_weeks__ = 8
__default_months__ = 2
__default_years__ = 0
# *** END DEFAULT COUNTS ***

def valid_config_values(config):
	""" This function is to ensure that all data provided via the config file, is
	valid. Ensure that variables to represent files or directories, represent 
	files or directories that exist, that variables that represnt numbers, are 
	valid numbers, and not alpha charecters, etc.
	Additionally, ensure that each Named section has all of the critera required,
	in order to be a valid working section.

	Okay, clarifying something here.  This function only verifies that values
	within the configuration are proper.  In other words, it tests the values.
	If they aren't set it doesn't care, if it can't find one in a section, who
	cares.  It just verifies values that are set.  It checks for type cast, it
	checks for directories and files.

	"""
	global log, __default_days__, __default_weeks__, __default_months__
	global __default_years__
	errors = []
	global_to_exclude = config.get('to_exclude',[])
	global_test_local = config.get('test_local',None)
	global_daily_dir = config.get('daily_dir',None)
	global_weekly_dir = config.get('weekly_dir',None)
	global_monthly_dir = config.get('monthly_dir',None)
	global_yearly_dir = config.get('yearly_dir',None)
	global_daily_count = config.get('daily_count',__default_days__)
	global_weekly_count = config.get('weekly_count',__default_weeks__)
	global_monthly_count = config.get('monthly_count',__default_months__)
	global_yearly_count = config.get('yearly_count',__default_years__)
	global_flags = config.get('flags','')
	global_niceness = config.get('niceness',None)

	if global_niceness and not is_int(global_niceness):
		errors.append("The default nice variable must be an integer.")

	if type(global_to_exclude) == type(''):
		errors.append("The to_exclude variable in the global section is a string, and should be a list.  It may be missing the trailing comma.")

	if trim(global_test_local) and (not os.path.isfile(os.path.abspath(global_test_local)) and not os.path.exist(os.path.abspath(global_test_local))):
		log.debug("valid_config_values(config): The global local test file does not appear to exist.")

	if trim(global_daily_dir) and (not os.path.isdir(os.path.abspath(global_daily_dir)) or not os.path.exists(os.path.abspath(global_daily_dir))):
		try:
			os.makedirs(os.path.abspath(global_daily_dir))
		except (OSError, IOError): 
			errors.append('The Daily Directory does not exist, and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % os.path.abspath(global_daily_dir))
		else:
			log.warn('The Daily Directory "%s" did not exist, but we were able to create it for you.' % os.path.abspath(global_daily_dir))

	if trim(global_weekly_dir) and (not os.path.isdir(os.path.abspath(global_weekly_dir)) or not os.path.exists(os.path.abspath(global_weekly_dir))):
		try:
			os.makedirs(os.path.abspath(global_weekly_dir))
		except (OSError, IOError): 
			errors.append('The Weekly Directory does not exist, and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % os.path.abspath(global_weekly_dir))
		else:
			log.warn('The Weekly Directory "%s" did not exist, but we were able to create it for you.' % os.path.abspath(global_weekly_dir))

	if trim(global_monthly_dir) and (not os.path.isdir(os.path.abspath(global_monthly_dir)) or not os.path.exists(os.path.abspath(global_monthly_dir))):
		try:
			os.makedirs(os.path.abspath(global_monthly_dir))
		except (OSError, IOError): 
			errors.append('The Monthly Directory does not exist, and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % os.path.abspath(global_monthly_dir))
		else:
			log.warn('The Monthly Directory "%s" did not exist, but we were able to create it for you.' % os.path.abspath(global_monthly_dir))

	if trim(global_yearly_dir) and (not os.path.isdir(os.path.abspath(global_yearly_dir)) or not os.path.exists(os.path.abspath(global_yearly_dir))):
		try:
			os.makedirs(os.path.abspath(global_yearly_dir))
		except (OSError, IOError): 
			errors.append('The Yearly Directory does not exist, and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % os.path.abspath(global_yearly_dir))
		else:
			log.warn('The Yearly Directory "%s" did not exist, but we were able to create it for you.' % os.path.abspath(global_yearly_dir))

	if global_daily_count and not is_int(global_daily_count):
		errors.append("The default days variable must be an integer.")

	if global_weekly_count and not is_int(global_weekly_count):
		errors.append("The default weeks variable must be an integer.")

	if global_monthly_count and not is_int(global_monthly_count):
		errors.append("The default months variable must be an integer.")

	if global_yearly_count and not is_int(global_yearly_count):
		errors.append("The default years variable must be an integer.")



	
	if trim(global_flags) and type(global_flags) == type([]):
		errors.append("Global flags must be presented as a string, not a list.")
	
	if config.get('action',None):
		errors.append('You may not specify a default "action" variable in the global config.  The "action" variable must be in a section.')

	if config.get('to_backup',None):
		errors.append('You may not put the "to_backup" variable in the global config.  It must be in a section.')

	for section_name, sections in PyTis.identify_sections(config):
		section = config[section_name]
		action = section.get('action','use')
		to_backup = trim(section.get('to_backup',[]))
		to_exclude = section.get('to_exclude',global_to_exclude)
		test_local = section.get('test_local',None)
		daily_dir = section.get('daily_dir',global_daily_dir)
		weekly_dir = section.get('weekly_dir',global_weekly_dir)
		monthly_dir = section.get('monthly_dir',global_monthly_dir)
		yearly_dir = section.get('yearly_dir',global_yearly_dir)

		daily_count = section.get('daily_count',global_daily_count)
		weekly_count = section.get('weekly_count',global_weekly_count)
		monthly_count = section.get('monthly_count',global_monthly_count)
		yearly_count = section.get('yearly_count',global_yearly_count)

		flags = section.get('flags',global_flags)
		nicity = section.get('niceness',global_niceness)

		if trim(action).lower() != 'ignore':
			if not to_backup:
				errors.append('The "%s" section has nothing to backup.  For now it should be ignored *(use "--help" and see "--action").' % section_name)

		if trim(action).lower() not in ('ignore','use','test','run'):
			errors.append('Invalid action, "%s" in section "%s".' % (action,section_name))

		if nicity and not is_int(nicity):
			errors.append("The default nice variable must be an integer.")

		if type(to_exclude) == type(''):
			errors.append("The to_exclude variable in the global section is a string, and should be a list.  It may be missing the trailing comma in section: %s." % section_name)

		if trim(test_local) and (not os.path.isfile(os.path.abspath(test_local)) and not os.path.exist(os.path.abspath(test_local))):
			log.debug("valid_config_values(config): The local test file does not appear to exist.")

		if trim(daily_dir) and (not os.path.isdir(os.path.abspath(daily_dir)) or not os.path.exists(os.path.abspath(daily_dir))):
			try:
				os.makedirs(os.path.abspath(daily_dir))
			except (OSError, IOError): 
				errors.append('The Daily Directory for section "%s" does not exist, and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % (section_name, os.path.abspath(daily_dir)))
			else:
				log.warn('The Daily Directory "%s" for section "%s" did not exist, but we were able to create it for you.' % (os.path.abspath(daily_dir, section_name)))
		elif is_int(daily_count) and daily_count and not trim(daily_dir):
			errors.append("You have not provided a daily backup directory for section \"%s\", and there isn't even one in the global configuration to inherit from.  Perhaps for now this section should be set to ignore *(use \"--help\" and see \"--action\")." % section_name)

		if trim(weekly_dir) and (not os.path.isdir(os.path.abspath(weekly_dir)) or not os.path.exists(os.path.abspath(weekly_dir))):
			try:
				os.makedirs(os.path.abspath(weekly_dir))
			except (OSError, IOError): 
				errors.append('The Weekly Directory does not exist for section "%s", and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % (section_name,os.path.abspath(weekly_dir)))
			else:
				log.warn('The Weekly Directory "%s" for section "%s" did not exist, but we were able to create it for you.' % (os.path.abspath(weekly_dir), section_name))
		elif is_int(monthly_count) and monthly_count and not trim(weekly_dir):
			errors.append("You have not provided a weekly backup directory for section \"%s\", and there isn't even one in the global configuration to inherit from.  Perhaps for now this section should be set to ignore *(use \"--help\" and see \"--action\")." % section_name)

		if trim(monthly_dir) and (not os.path.isdir(os.path.abspath(monthly_dir)) or not os.path.exists(os.path.abspath(monthly_dir))):
			try:
				os.makedirs(os.path.abspath(monthly_dir))
			except (OSError, IOError): 
				errors.append('The Monthly Directory does not exist for section "%s", and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % (section_name,os.path.abspath(monthly_dir)))
			else:
				log.warn('The Monthly Directory "%s" for section "%s" did not exist, but we were able to create it for you.' % (os.path.abspath(monthy_dir), section_name))
		elif is_int(monthly_count) and monthly_count and not trim(monthly_dir):
			errors.append("You have not provided a monthly backup directory for section \"%s\", and there isn't even one in the global configuration to inherit from.  Perhaps for now this section should be set to ignore *(use \"--help\" and see \"--action\")." % section_name)




		if trim(yearly_dir) and (not os.path.isdir(os.path.abspath(yearly_dir)) or not os.path.exists(os.path.abspath(yearly_dir))):
			try:
				os.makedirs(os.path.abspath(yearly_dir))
			except (OSError, IOError): 
				errors.append('The Yearly Directory for section "%s" does not exist, and we failed in our attempt to create it for you, please create "%s" and ensure that this program has write access.' % (section_name, os.path.abspath(yearly_dir)))
			else:
				log.warn('The Yearly Directory "%s" did not exist for section "%s", but we were able to create it for you.' % (os.path.abspath(yearly_dir), section_name))
		elif is_int(yearly_count) and yearly_count and not trim(yearly_dir):
			errors.append("You have not provided a yearly backup directory for section \"%s\", and there isn't even one in the global configuration to inherit from.  Perhaps for now this section should be set to ignore *(use \"--help\" and see \"--action\")." % section_name)

		if daily_count and not is_int(daily_count):
			errors.append("The default days variable must be an integer.")
		if weekly_count and not is_int(weekly_count):
			errors.append("The default weeks variable must be an integer.")
		if monthly_count and not is_int(monthly_count):
			errors.append("The default months variable must be an integer.")
		if yearly_count and not is_int(yearly_count):
			errors.append("The default years variable must be an integer.")
		
		if trim(global_flags) and type(global_flags) == type([]):
			errors.append("Global flags must be presented as a string, not a list.")

		if errors:
			raise PyTis.ConfigurationError(errors) 
		return True


def is_int(i):
	try:
		int(str(i))
	except ValueError:
		return False
	return True

def trim(item):
	""" 
	"""
	if type(item) == type(str('')):
		if item: item=item.strip()
		else: item = ''
	elif type(item) == type([]):
		return [f.strip() for f in item]
	else:
		if not item:
			item = '' 
	return item

def config_file():
	etc = PyTis.__configdir__
	fname=os.path.basename(sys.argv[0])
	fpath = "%s.ini" % os.path.abspath(os.path.join(etc,fname))
	return fpath

def load_config(config_file=config_file()):
	global config
	config = COBJ.load(config_file, True)
	return config


def get_value(opts, config, key, server=None):
	global log

	if server:
		try:
			section = config[server]
			#log.debug("found server in config: %s" % server)
		except KeyError, e:
			section = config
			#log.debug("server not found, using root of config")
	else:
		section = config
	
	try:
		retval = section[key] 
		#log.debug("found %s in config" % key)
		#log.debug("value of: %s" % retval)
	except KeyError, e:
		try:
			retval = config[key]
		except KeyError, e:
			pass
		else:
			return retval
	else:
		return retval

	error = 'Cannot find "%s" in config, nor was it passed in as an option on STDIN.' % key
	try:
		retval =	getattr(opts,key)
		#log.debug("found %s in opts" % key)
		#log.debug("value of: %s" % retval)
	except AttributeError, e:
		#log.warn(error)
		retval = None
		pass
#		raise PyTis.EmptyString(str(error))
	else:
		if not retval:
			#log.warn(error)
			pass

	if not retval:
		raise PyTis.EmptyString(str(error))
	return retval

def validate_opt(opts,cfile,key, section=None):
	""" To clarify, this is just to make sure that the option can be found, if
	not as an option argument, then in the section's configuration, and if not
	there, then look to the global configuration settings.  If a required field
	cannot be found, raise an empty string error. """
	global __default_tar_flags__, __default_days__, __default_weeks__
	global __default_months__,__default_years__, log
	conf_path = os.path.abspath(config_file())
	dig_config=False
	title = key.replace('_',' ').title()
	#log.debug("attempting to validate '%s' in section: %s" % (key,section))
	try:
		opt_val = getattr(opts,key)
	except AttributeError,e:
		# doesn't even have the attribute in options, the look to config
		dig_config=True
	else:
		if type(opt_val) == type(str('')) and opt_val=='=' or not trim(opt_val): 
			opt_val=''
			dig_config=True
		if type(opt_val) is type(list([])) and not trim(opt_val):
			opt_val = []
			dig_config=True
		# if it does exist in the options as an attribute, but only because it is
		# the default, then we need to really look to the configuration
		if trim(key).lower() == 'flags' and \
				trim(opt_val) == trim(__default_tar_flags__):
			dig_config=True
		if trim(key).lower() == 'daily_count' and \
				trim(opt_val) == trim(__default_days__):
			dig_config=True
		if trim(key).lower() == 'weekly_count' and \
				trim(opt_val) == trim(__default_weeks__):
			dig_config=True
		if trim(key).lower() == 'monthly_count' and \
				trim(opt_val) == trim(__default_months__):
			dig_config=True
		if trim(key).lower() == 'yearly_count' and \
				trim(opt_val) == trim(__default_years__):
			dig_config=True


	errs = []
	# doesn't have attribute in options or options attribute is blank/not set
	if dig_config or not getattr(opts,key):
		try:
			if section:
				try:
					cfile[section]
				except KeyError, e:
					raise PyTis.EmptyString('Section "%s" provided, and could not be " \
						"found in the config file.' % section)
				else:
					try:
						value = cfile[section][key]
					except KeyError, e:
						try:
							value = cfile[key]
							if key.lower() == 'action' and trim(value):
								raise PyTis.ConfigurationError("Somebody directly edited the " \
									"configuration ini file (%s).  You may specify an action in" \
									" the global section." % conf_path)
						except KeyError, e:
							if key.lower() == 'action':
								value='use'
								return value
							errs.append('"%s" not found in the configuration file under " \
								"section: %s.' % (title,section))
							errs.append('"%s" not found in the global section of the " \
								"configuration file.' % title)
					else:
						if key.lower() == 'to_exclude':
							try:
								val2 = cfile[key]
							except KeyError, e:
								pass
							else:
								if val2 and type(val2) != type(list([])):
									val2 = [val2]
									value.extend(val2)
								elif val2 and type(val2) == type(list([])):
									value.extend(val2)

			else:
				try:
					value = cfile[key]
				except KeyError, e:
					errs.append('"%s" not found in the global section of the " \
						"configuration file.' % title)

			if errs:
				try:
					value = opt_val
				except UnboundLocalError, e:
					print 'key', key
					print 'section', section
					print e
					sys.exit(1)

				if not trim(value) and key not in cfile.optional_fields:
					errs.append('%s not provided as an STDIN option, and could not be " \
						"found in the config file.' % title)
					raise PyTis.EmptyString("\n".join(errs))
		except OSError,e:
			raise PyTis.EmptyString('%s not provided, and a config file could not ' \
				'me found.' % title)
	else:
		value = opt_val
		if not trim(value):
			del opts.__dict__[key]
			return validate_opt(opts,cfile,key,section)
	return value


def validate(opts, config):
	""" Very similar to what will occur within the run function.  This function
	will ensure that the required data for all of the sections (or only one
	section, if only one is specified to be ran/tested via the optional attribute
	"--section=[NAME OF SECTION]").  If the required data cannot be found in
	the parsed arguments/options (or can be found, but is simply a default
	value), then look to the config.  If it cannot be found within the section,
	then look globally within the config.  Lastly, unless the action and section
	were sprecifically specified within the STDIN optional arguments, then this
	may skip over sections who have the ignore flag set.

	This makes sure that when this runs for a cronjob, that each section that
	could run, will.  In other words, each section that is not explicedly set to
	"ignore" have all required variables set, or can be inherited.
	
	"""
	config.fields=['daily_dir','weekly_dir','monthly_dir','yearly_dir','daily_count',
		'weekly_count','monthly_count','yearly_count','to_exclude','to_backup',
		'flags','test_local']
	config.optional_fields = ['test_local']
	sections = PyTis.identify_sections(config)


	opt_keys=opts.__dict__.keys()
	opt_keys.sort()
	for section_name, section in sections:
		if(opts.section_name and trim(opts.section_name).lower() == section_name) \
			or not trim(opts.section_name):
			if not trim(opts.section_name) and trim(section.get('action','use')).lower() == 'ignore':
				continue
			#for opt, value in opts.__dict__.items():
			for opt in opt_keys:
				value=opts.__dict__[opt]
				if opt.lower() in config.fields:
					#log.info('looking for %s in %s' % (str(opt.lower()),section_name))
					value = validate_opt(opts,config,opt.lower(),section_name)	
					log.debug("VALIDATED OPTIONS [%s] %s: %s" % (section_name,opt,value))

	log.debug('-'*80) 

def run(opts, config, TEST_NOW):
	"""pybkup run doc help"""
	global log, __default_days__, __default_weeks__, __default_months__
	global __default_years__
	errors = []
	timestamp = PyTis.fileStampNow()

	for section_name, section in PyTis.identify_sections(config):
		section_name=section_name.lower()

		if trim(opts.section_name) and (section_name.lower() != trim(opts.section_name).lower()):
			continue
		action=validate_opt(opts,config,'action',section_name.lower())
		if trim(opts.section_name) and trim(opts.action).lower() == 'use' and action.lower() == 'ignore' and not opts.force:
			log.error("You may not run a section that was specifically ignored.  At most you may test it, this has bee put in place for safety reasons.")
		elif trim(opts.section_name) and trim(opts.action).lower() == 'use' and action.lower() == 'ignore' and opts.force:
			log.warn("You may run this section this time ONLY because you used the force flag.  Please not normally, this section would be ignored, as that is what this section's action attribute is set to.")

		if TEST_NOW:
			log.info('TESTING SECTION: %s' % section_name)

		to_backup = trim(section.get('to_backup',[]))
		if type(to_backup) is type(str('')):
			if trim(to_backup): to_backup = [to_backup]
			else: to_backup = []

		to_exclude = validate_opt(opts,config,'to_exclude',section_name)
		if type(to_exclude) is type(str('')):
			if trim(to_exclude): to_exclude = [to_exclude]
			else: to_exclude = []

		daily_dir		= os.path.abspath(validate_opt(opts,config,'daily_dir',section_name))
		weekly_dir	= os.path.abspath(validate_opt(opts,config,'weekly_dir',section_name))
		monthly_dir	= os.path.abspath(validate_opt(opts,config,'monthly_dir',section_name))
		yearly_dir	= os.path.abspath(validate_opt(opts,config,'yearly_dir',section_name))

		daily_count		= int(validate_opt(opts,config,'daily_count', section_name))
		weekly_count	= int(validate_opt(opts,config,'weekly_count',section_name))
		monthly_count = int(validate_opt(opts,config,'monthly_count',section_name))
		yearly_count = int(validate_opt(opts,config,'yearly_count',section_name))

		flags = validate_opt(opts,config,'flags',section_name)
		nicity = validate_opt(opts,config,'niceness',section_name)
		
		root_dir = opts.root
		root_dir = section.get('root', config.get('root', root_dir))

		root_dir = None

		if len(to_backup) == 1:
			to_b = os.path.abspath(to_backup[0])
			base = "%s_%s" % (os.uname()[1].lower(),os.path.basename(to_b))
			include = to_b 
			if os.path.isfile(to_b):
				could_b = os.path.dirname(os.path.dirname(to_b))
			else:
				could_b = os.path.dirname(to_b)
			if not root_dir or root_dir.startswith(could_b) and os.path.abspath(root_dir) != os.path.abspath(could_b):
				root_dir=could_b
		elif len(to_backup) > 1:
			base = "%s_%s" % (os.uname()[1].lower(),section_name.lower())
			for to_b in to_backup:
				if not to_b: continue
				to_b = os.path.abspath(to_b)
				if os.path.isfile(to_b):
					could_b = os.path.dirname(os.path.dirname(to_b))
				else:
					could_b = os.path.dirname(to_b)

				if not root_dir or root_dir.startswith(could_b) and os.path.abspath(root_dir) != os.path.abspath(could_b):
					root_dir=could_b
		else:
			include = ''

		if len(to_exclude) == 1:
			ex = os.path.abspath(to_exclude[0])
			exclude = "--exclude='%s'" % ex
			if os.path.isfile(ex):
				could_b = os.path.dirname(os.path.dirname(ex))
			else:
				could_b = os.path.dirname(ex)
			if not root_dir or root_dir.startswith(could_b) and os.path.abspath(root_dir) != os.path.abspath(could_b):
				root_dir=could_b
		elif len(to_exclude) > 1:
			for ex in to_exclude:
				if not ex: continue
				ex = os.path.abspath(ex)
				if os.path.isfile(ex):
					could_b = os.path.dirname(os.path.dirname(ex))
				else:
					could_b = os.path.dirname(ex)
				if not root_dir or root_dir.startswith(could_b) and os.path.abspath(root_dir) != os.path.abspath(could_b):
					root_dir=could_b
		else:
			exclude = ''

		if not root_dir:
			root_dir = '/'

		os.chdir(os.path.abspath(root_dir))

		if len(to_backup) > 1:
			includes_tempname = None
			include_temp = tempfile.NamedTemporaryFile(delete=False)
			includes_tempname = include_temp.name
			include = '--files-from="%s"' % os.path.abspath(includes_tempname)
			for to_b in to_backup:
				if not to_b: continue
				include_temp.write("%s\n" % to_b.strip().replace(root_dir,'')[1:])
			include_temp.flush()
			include_temp.seek(0)

		if len(to_exclude) > 1:
			excludes_tempname = None
			exclude_temp = tempfile.NamedTemporaryFile(delete=False)
			excludes_tempname = exclude_temp.name
			exclude = '--exclude-from="%s"' % excludes_tempname
			for ex in to_exclude:
				if not ex: continue
				exclude_temp.write("%s\n" % ex.strip().replace(root_dir,'')[1:])
			exclude_temp.flush()
			exclude_temp.seek(0)


		target_base = "%s.tar.gz" % base	
		target = "%s-%s" % (timestamp, target_base)
		daily_file	= os.path.abspath(os.path.join(daily_dir,target))
		weekly_file	= os.path.abspath(os.path.join(weekly_dir,target))
		monthly_file= os.path.abspath(os.path.join(monthly_dir,target))
		yearly_file	= os.path.abspath(os.path.join(yearly_dir,target))

		cmd = "tar %(flags)s %(target)s %(exclude)s %(source)s" % dict(flags=flags,
			target=daily_file, exclude=exclude, source=include)
		if len(to_backup) > 1:
			include_temp.seek(0)
			log.debug("\nINCLUDE (included files read from file):\n========")
			log.debug("\t%s\n" % "\n\t".join([tem.strip() for tem in include_temp.readlines(-1)]))
		if len(to_exclude) > 1:
			log.debug("\nEXCLUDE (excluded files read from temp file):\n========")
			log.debug("\t%s\n" % "\n\t".join([tem.strip() for tem in exclude_temp.readlines(-1)]))
		log.debug("COMMAND:")
		if TEST_NOW:
			log.info("#The following command would have run if not in TEST mode.")
			log.info("#%s" % cmd)
			log.debug("This would have created: %s" % daily_file)
		else:
			ret = execute(cmd)
			if ret: ret = list(ret)
			else: ret = 'None'
			log.debug(cmd)
			if not os.path.isfile(daily_file) or not os.path.exists(daily_file):
				[log.warn(r) for r in ret]
			log.debug("Should have created: %s" % daily_file)

		now=datetime.datetime.now()

		# now, that we have our daily copy, if it is a Friday, copy this to the weekly backups.
		if not TEST_NOW and weekly_count and now.weekday() == 4:
			shutil.copy(daily_file,weekly_file)

		if not TEST_NOW and monthly_count and now.day == 1:
			shutil.copy(daily_file,monthly_file)

		if not TEST_NOW and yearly_count and now.day == 1 and now.month == 1:
			shutil.copy(daily_file,yearly_file)

		# - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # -
		# now prune the daily folder
		if daily_count:
			acceptable_date = PyTis.relative_date(now,days=-daily_count).date()
		else:
			acceptable_date = None
		prune('days',daily_dir,daily_count,target_base,TEST_NOW,acceptable_date)

		# - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # -
		# now prune the weekly folder

		if weekly_count:
			if now.weekday() == 4: # this is a friday.
				acceptable_date = PyTis.relative_date(now, weeks= -weekly_count).date()
			else: # not a friday, find last one
				acceptable_date = PyTis.relative_date(now - datetime.timedelta(days=now.weekday() + 3), weeks= -weekly_count).date()
		else:
			acceptable_date = None
		prune('weeks',monthly_dir,weekly_count,target_base,TEST_NOW,acceptable_date)


		# - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # -
		# now prune the monthly folder
		if monthly_count:
			acceptable_date = PyTis.relative_date(now.replace(day=1),months=-monthly_count).date()
		else:
			acceptable_date = None
		prune('months',monthly_dir,monthly_count,target_base,TEST_NOW,acceptable_date)

		# - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # -
		# now prune the yearly folder
		if yearly_count:
			#acceptable_date = PyTis.relative_date(now.replace(day=1),years=-yearly_count).date()
			year = now.year-yearly_count
			acceptable_date = datetime.date(now.year,1,1)
		else:
			acceptable_date = None
		prune('years',yearly_dir,yearly_count,target_base,TEST_NOW,acceptable_date)


		if(len(to_backup)) > 1:
			include_temp.close()
		if(len(to_exclude)) > 1:
			exclude_temp.close()

def prune(log_label,directory,count,target_base,TEST_NOW,acceptable_date=None): 
	global log
	for fpath in glob.glob(os.path.join(directory,'*.tar.gz')):
		f = os.path.basename(fpath)
		if not f[13:] == '-%s' % target_base:
			log.debug("%s - filename pattern non-match: [ skipping ]" % fpath)
			continue
		else:
			log.debug("%s - filename pattern match" % fpath)

		if count == 0:
			if TEST_NOW:
				log.info("%s count is set to 0, {%s} would be deleted" % (log_label.title(),f))
			else:
				os.unlink(fpath)
				log.info("%s count is set to 0, {%s} [ removing ]" % (log_label.title(),f))
		elif not count:
			log.warn("Count not set at all, but filename match found.  No files will be pruned.")
		else:
			try:
				fyear = int(f[0:4])
				fmonth = int(f[4:6])
				fday = int(f[6:8])
			except (ValueError,IndexError), e:
				# XXX-TODO log it though, like a warning
				pass #skip because it must be someone elses tarbarll
			else:
				your_date = datetime.date(fyear,fmonth,fday)
				if your_date < acceptable_date:
					if TEST_NOW:
						log.info("file {%s} is more than %s %s old, and would be deleted" % (f,count,log_label))
					else:
						log.info("file {%s} is more than %s %s old" % (f,count,log_label))
						os.unlink(fpath)
				else:
					log.debug("%s - file dates checked: [ skipping ]" % f)

def execute(exe):
	p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=True)
	while True:
		retcode = p.poll()
		line = p.stdout.readline()
		if line:
			yield line.strip()
		if retcode is not None:
			break

def get_count(opts, attr_name, default, update_with, errors=[]):

	opts_attr = getattr(opts,attr_name,None)

	if trim(opts_attr) and not is_int(opts_attr):
		# optional command line argument passed via STDIN, but is not an integer,
		# raise an error
		errors.append('If you specify the %s flag, you must provide an integer *(use "--help" for more information).' % attr_name.replace('_','-'))
	elif opts_attr and is_int(opts_attr) and int(opts_attr) != default:
		# updating with priority, because command line override in STDIN via
		# optional argument
		update_with.update({attr_name:opts_attr})
	elif opts_attr and is_int(opts_attr) and int(opts_attr) == default: 
		# it is in the optional arguments, and MAY have been provided via STDIN,
		# but was likely not, because it is the default value
		if not trim(opts.section_name) and config.get(attr_name,None) is None:
			# no section given, and it isn't set globally, let's set it for them
			update_with.update({attr_name:default})
		if trim(opts.section_name) and not config.get(trim(opts.section_name),None):
			# they gave us a section after all, but it doesn't exist, they are likely
			# creating it for the first time right now.
			if config.get(attr_name,None) is None:
				# it is not set globally either, so lets set one for this section. 
				update_with.update({attr_name:default})
			else:
				# there is already a global value within the config that this section
				# can inherit from, lets leave this new section's attr_count value
				# blank, allowing the value to be pulled from the global config.
				# "Simple is better than complex." 
				pass
		elif trim(opts.section_name) and config.get(trim(opts.section_name),None):
			# they gave us a section, and it does already exist in the config, treat
			# this as if they are editing an existing section
			if config[trim(opts.section_name)].get(attr_name,None) is None and config.get(attr_name,None) is None:
				# there is not already a global value within the config that this
				# section can inherit from,  therefore we will set this new section's
				# attr _count value
				update_with.update({attr_name:default})
	return errors,update_with

def main():
	"""usage: pybkup {ACTION} [OPTIONS]"""
	global __default_tar_flags__, log, __default_days__, __default_weeks__
	global __default_months__, __default_years__
	main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__,os.path.abspath(config_file()))
	errors=[]
	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	

	parser.extra_txt = """Usage: pybkup	 ...<options>

	tar.gz

Daily for 2 weeks
leave.
> 2 weeks, leave if on friday.
weekly for 2 months
> 2 months, leave 1 per month....

Named Sections to manage each set of configuration variables.

monthly for 2 years.


examples:	
	xxx

SEE ALSO:
	xxx

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

HISTORY:
	Original Author

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	parser.set_description(__doc__)
	parser.set_usage(main.__doc__)

	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")
	runtime.add_option("-L", "--list-out", 
									action='store',
									default=None, 
									dest='list_out',
									metavar='[NAME]',
									help="Print out to screen a section's configuration and exit.")

	runtime.add_option("-l", "--list", 
									action='store_true',
									default=False, 
									dest='list',
									help='List all sections available from configuration file, and their current action.')

	runtime.add_option("-F", "--force", 
									action='store_true',
									default=False, 
									dest='force',
									help='For forcing an ignored section to run.')


	runtime.add_option("-n", "--nice", 
									type="int", 
									action='store',
									default=PyTis.MyThread.default_niceness, 
									dest='niceness',
									metavar='[INT <-20 - 19>]',
									help="Nicenesses range from -20.	Default 10")
	parser.add_option_group(runtime)
	# -------------------------------------------------------------------------
	# variable setting
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")

	vars.add_option("-A", "--action",
									action='store',
									choices=['ignore','use','run','test'],
									default=None, 
									dest='action',
									metavar='[ACTION]', 
									type="choice", 
									help="choices: <'ignore', 'test', 'run', 'use' (run is an alias for use)  *(use \"--help\" for more help)")

	vars.add_option("-f", "--tar-flags", action="store",
									default=__default_tar_flags__, 
									dest='flags',
									metavar="[PATH]",
									type='string',
									help="Flags to pass to rsync, default flags are: '%s'" % __default_tar_flags__)

	vars.add_option("-N", "--section", 
									action="store",
									default=None, 
									dest='section_name',
									metavar="[LOAD/SAVE-AS SECTION NAME]",
									type='string',
									help='Name to save configuration into a section. '
									' OR '
									'Name of configuration section to load the options from the config file.'
									'"*(use "--help" for more help)')

	vars.add_option("-S", "--save", 
									action="store_true",
									default=False, 
									dest='save',
									help="Save information for future use?")

	vars.add_option("-t", "--test-file-local", 
									action='store',
									default=None, 
									dest='test_local',
									metavar='[LOCAL FPATH]', 
									type='string',
									help='Full path of testfile on local server. *(use "--help" for more help)')

	vars.add_option("-d", "--daily-dir", action="store",
									dest='daily_dir',
									metavar="[PATH]",
									type='string',
									help="Where to place the daily backups.")

	vars.add_option("-w", "--weekly-dir", action="store",
									dest='weekly_dir',
									metavar="[PATH]",
									type='string',
									help="Where to place the weekly backups.")

	vars.add_option("-m", "--monthly-dir", action="store",
									dest='monthly_dir',
									metavar="[PATH]",
									type='string',
									help="Where to place the monthly backups.")

	vars.add_option("-y", "--yearly-dir", action="store",
									dest='yearly_dir',
									metavar="[PATH]",
									type='string',
									help="Where to place the yearly backups.")

	vars.add_option("", "--daily-count", action="store",
									default=__default_days__, 
									dest='daily_count',
									metavar="[PATH]",
									type='int',
									help="How many days of backups to keep, default is: %s" % __default_days__)

	vars.add_option("", "--weekly-count", action="store",
									default=__default_weeks__, 
									dest='weekly_count',
									metavar="[PATH]",
									type='int',
									help="How many weeks of backups to keep, default is: %s" % __default_weeks__)

	vars.add_option("", "--montly-count", action="store",
									default=__default_months__, 
									dest='monthly_count',
									metavar="[PATH]",
									type='int',
									help="How many months of backups to keep, default is: %s" % __default_months__)

	vars.add_option("", "--yearly-count", action="store",
									default=__default_years__, 
									dest='yearly_count',
									metavar="[PATH]",
									type='int',
									help="How many years of backups to keep, default is: %s" % __default_years__)


	vars.add_option("", "--root-dir", action="store",
									default=None, 
									dest='root',
									metavar="",
									type='string',
									help=optparse.SUPPRESS_HELP)

	parser.add_option_group(vars)
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging")
	helpishere=False
	for a in sys.argv:
		if a == '--help':
			helpishere=True
			dbgroup.add_option("-V", "--verbose", action="store_true",
							 default=True, dest='verbose',
							 help="Be more Verbose (make lots of noise)")
	if not helpishere:
		dbgroup.add_option("-V", "--verbose", action="store_true",
						 default=True, dest='verbose',
						 help=optparse.SUPPRESS_HELP)

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits)")

	dbgroup.add_option("-v", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()

	if len(args) > 0 and not opts.action:
		if str(args[0]).strip().lower() in ('test','run','use','ignore'):
			opts.action=str(args[0]).lower()
	opts.had_verbose = False
	if opts.verbose: opts.had_verbose = True
	if opts.quiet: opts.verbose = False
	if opts.action and opts.action.strip() and opts.action.strip().lower():
		opts.action = trim(opts.action).lower()
	if opts.action == 'test' and not trim(opts.quiet): opts.verbose=True

	
	if is_int(opts.niceness):
		try:
			os.nice(opts.niceness)
		except (AttributeError, NameError), e:
			pass

	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))

	if opts.version:
		return PyTis.version(__version__)
	
	config = load_config(config_file())
	sections =PyTis.identify_sections(config) 

	# #########################################
	if opts.list:
		L = []
		maxL = len('SECTION NAME')

		for section, sub in sections:
			try:
				action = sub['action']
			except KeyError, e:
				action = 'use'
			L.append((str(section).lower(),action))
			if maxL < len(str(section)):
				maxL = len(str(section))

		x=' '*(maxL/2)
		y="SECTION NAME%sACTION" % x
		log.info(y)
		log.info('='*len(y))
		L.sort()
		for s in L:
			log.info("%s%s%s%s" % (s[0],x,' '*(maxL-len(s[0])),s[1]))
		return

	# #########################################
	if opts.list_out:
		section = PyTis.get_section(sections,opts.list_out)
		if not section:
			log.error("Section not found, it is case-sensative.	Try the --list command to see a list of available sections.")
			return
		else:
			log.info(opts.list_out)
			log.info('='*len(opts.list_out))
			for key in section.keys():
				value = section[key]
				if type(value) == type(list([])):
					log.info("%s: \n%s\n" % (key,"\n".join([" %s" % v for v in value])))
				else:
					log.info("%s: %s" % (key,section[key]))
		return

	TEST_NOW = False; TEST_SECTION = None
	if opts.action and opts.action=='test':
		TEST_NOW = True
		if trim(opts.section_name):
			TEST_SECTION = trim(opts.section_name).lower()

	# prepair a dictionary, wither for saving, testing or running, it does not
	# matter, it will be used
	update_with = {}

	if opts.test_local and opts.test_local.strip(): update_with.update({'test_local':opts.test_local.strip()})

	if opts.daily_dir and opts.daily_dir.strip(): update_with.update({'daily_dir':opts.daily_dir.strip()})
	if opts.weekly_dir and opts.weekly_dir.strip(): update_with.update({'weekly_dir':opts.weekly_dir.strip()})
	if opts.monthly_dir and opts.monthly_dir.strip(): update_with.update({'monthly_dir':opts.monthly_dir.strip()})
	if opts.yearly_dir and opts.yearly_dir.strip(): update_with.update({'yearly_dir':opts.yearly_dir.strip()})

	# strings
	if opts.flags and opts.flags.strip() and opts.flags.strip() != __default_tar_flags__:
		update_with.update({'flags':trim(opts.flags)})
	elif opts.flags and opts.flags.strip() and opts.flags.strip() == __default_tar_flags__ and not config.get('flags', None):
		update_with.update({'flags':trim(opts.flags)})


	# integers
	errors, update_with = get_count(opts, 'daily_count', __default_days__, update_with, errors)
	errors, update_with = get_count(opts, 'weekly_count', __default_weeks__, update_with, errors)
	errors, update_with = get_count(opts, 'monthly_count', __default_months__, update_with, errors)
	errors, update_with = get_count(opts, 'yearly_count', __default_years__, update_with, errors)

	# lastly grab the action
	if (opts.save and trim(opts.action)) and not trim(opts.section_name):
		errors.append('Actions may not be specified globally, please specify a section.')
	elif trim(opts.section_name) and trim(opts.action):
		if trim(opts.action).lower() == 'run': opts.action='use'
		update_with.update({'action':trim(opts.action)})
	
	if trim(opts.section_name) and not errors:
		opts.section_name = trim(opts.section_name)
		if str(type(config.get(opts.section_name))) != "<class 'pylib.configobj.Section'>":
			config[opts.section_name] = {'to_backup':[],'to_exclude':[]}

	# Okay, 1, try to update the config regardless of saving it, you need to
	# update the config file so that the info will be in there for testing.
	# Saving can happen later.
	if trim(opts.section_name) and not errors:
		config[trim(opts.section_name)].update(update_with)
	elif update_with and not errors:
		config.update(update_with)
	
	# Set the titles to be used.
	if config.exists:
		title = 'UPDATING '
	else:
		title = 'CREATING '

	if opts.section_name:
		title += 'SECTION: %s' % trim(opts.section_name)
	else:
		title += 'config'

	if TEST_NOW:
		log.debug(title)
	elif opts.save:
		log.info(title)

	# moved this out side of the if statements below so it would only have to run
	# once, regardless of if it is for testing, saving, or running.

	if not errors:
		try:
			valid_config_values(config)
		except PyTis.ConfigurationError, er:
			PyTis.conjoin(er,errors)

	if not errors:
		try:
			validate(opts, config)
		except PyTis.EmptyString, e:
			PyTis.conjoin(e,errors)

	# TEST, if we have any errors from testing, we capture them
	if not errors and TEST_NOW:
		# header output
		if TEST_SECTION:
			log.debug('TESTING SECTION %s NOW' % TEST_SECTION)
			log.info("# CONFIG FILE: %s\n" % os.path.abspath(config.filename))
		else:
			log.debug('TEST EVERYTHING NOW')
			log.info("# CONFIG FILE: %s\n" % os.path.abspath(config.filename))

		if not errors:
			try:
				run(opts, config, TEST_NOW)
			except KeyboardInterrupt,e:
				if not opts.quiet:
					print "\nbye!"
				return
			except PyTis.EmptyString, er:
				PyTis.conjoin(er,errors)
			else:
				log.info("Done,... Test successfull.")
				if not opts.save:
					# We might as well return, so we don't go into the next (real) run
					# method since instead, a test was requested.  Don't worry, the save
					# method returns out of this main function for us.
					return


	# If no ERRORS and save, then save, test or not, if test raised errors, then
	# we won't save because the arguments added weren't "save worthy" and if test
	# didn't, cool we can save it, and if no test, who cares, if we have no
	# errors and someone said save, then save it ;-)

	if not errors and opts.save:
		try:
			validate(opts, config)
		except PyTis.EmptyString, e:
			PyTis.conjoin(e,errors)
		else:
			config.save()
			log.debug('configfile: %s' % os.path.abspath(config.filename))
			log.info("your settings have been saved")
			return PyTis.toContinue()


	if not trim(opts.action) and not errors:
		log.warn('To make sure this is not called by accident, by a user who is new to it, to simply run everything use "%s run".' % os.path.basename(sys.argv[0]))
		return parser.print_usage()
	elif not errors:
		try:
			run(opts, config, False)
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return
		else:
			log.info("Done.")
			return
	else:
		parser.print_usage()
		if errors:
			#log.error(str("\n".join(errors)))
			[log.error(e) for e in errors if e]
		return parser.print_help(errors)

	parser.print_help("ERROR: Unknown, but invalid input.")
	sys.exit(0)

if __name__ == '__main__':
		main()

