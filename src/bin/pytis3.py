#!/usr/bin/env python3
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		 #
# 1.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							 #
#		 http://www.PyTis.com/License/																						 #
#																																							 #
#		 Copyright (c) 2009 Josh Lee																							 #
#																																							 #
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                               #
# @auto-generated by the PyTis Copyright Tool on 08:15 11 Nov, 2009             #
############################################################################## #
""" This library started as a single file to hold just a few functions that I
repeatedly used.  Slowly it grew to include a universal config file loading,
saving, editing tool that is used by several of my scripts.  Eventually I wrote
a sub-class of the optparse.OptionParser, and my own logging file.  As with any
script library, this one has grown as my repetuir of scripts has.  Now I am
adding in several classes from pyservice.py Andrey Usov
(https://github.com/ownport/pyservice).  I tried to utilize his library for
daemonizing python scripts, but with no success.  I am going to have to
rewrite parts of it but I will be utilizing some of his classes.


"""
# builtin
import base64 as b64
import os
import re
import sys
import glob
import time
import errno
import pydoc
import atexit
import signal
import logging
import datetime
import optparse
import resource
import itertools
import traceback
#import thread
import threading
from pprint import pprint

python_version = float("%s.%s"%(sys.version_info.major,sys.version_info.minor))

if python_version >= 3.0:
	from collections import UserDict
	from io import StringIO
	import functools

	# internal (mine/yours/ours) 
	from pylib3 import configobj as COBJ
	from pylib3 import parse
	from pylib3.util.dicts import odict
else:
	from UserDict import UserDict
	import cStringIO

	# internal (mine/yours/ours) 
	from pylib import configobj as COBJ
	from pylib import parse
	from pylib.util.dicts import odict
import configure as pytis_configure # (imports configdir and logdir)
#from pylib import pyservice

__author__ = 'Josh Lee'
__created__ = '06:14pm 09 Sep, 2009'
__copyright__ = 'PyTis.com'
__configdir__ = pytis_configure.configdir # '/root/etc'
__logdir__ = pytis_configure.logdir # '/root/log'
__version__ = 4.1



__change_log__ = """

4.2:
	created new class object ConfigField
	added class method to ConfigFile.validate
	added class method to ConfigFile.validate_obj
	added new Class ConfigurationError(Exception)

4.1.55
	added new function microtime

4.1.53
	added new Classes:
		DieNow(Exception)
		ProgrammerError(Exception)
	Fixed KeyboardInterrupt Error in Man Page --help pager
	added pause/Pause/unPause feature to custom logger (MyLogger)
	added mbool config file boolean evaluator
	added in tolen function, from the to80 script

4.1.37
	Added in ability to read ini files.

XXX-TODO:
	gothrough sourceforge and continue creating the changelog.



Forward...

For years I have insisted that there only be one library, PyTis.	However I can
foresee the next release being the game changer.	It will contain my old trusty
python-zs library from Zertis LLC and KCG (The Koar Consulting Group, LLC).

This will give me to use the greatest two functions ever written.	Sync and
Snatch.	They are practically A.I. they are so intelligent.	They are two of
1.5 gigs of previously written library code that I should probably just start
using, rather than re-invent the wheel.	I do plan on slowly importing it
though, and only bringing in what I need.

DataSource, many of these programs use similar datasources, that currently, are
ini files.	While that is great, eventually, I will want to control them with a
gui.	Which likely means having a site that allows me to setup variabls that
are stored in the database.	Whether it be PostgreSQL, MySQL, SQLite3, Mongo,
or INI, I would like these scripts to be able to run.	That is the point in
adding in the extrapolation layer of a data source.	While I could do that now,
i am trying to have some self control, and only do what is needed to get these
backup programs, well, back up, and running.	Next time though, I will put the
datasoucre in place.	It is fine that I am writing all of this ini file stuff,
because if the DS is to come from an INI file, then we will still have a use
for our code.






"""

__option_always__ = [False]
__input_options__ = ['y','N']

# #############################################################################
# Error Classes Below
# #############################################################################
class DieNow(Exception): pass # Egregious Error has occured, must exit now.
class NoFiles(Exception): pass
class QuitNow(Exception): pass
class IdiotError(Exception): pass
class FileExists(UserWarning): pass
class EmptyString(Exception): pass
class FileNotFound(UserWarning): pass
class FutureFeature(Exception): pass
class EmptyTemplate(FileNotFound): pass
class ProgrammerError(Exception): pass
class ConfigurationError(Exception): pass
class DuplicateCopyright(UserWarning): pass
class IdiotError(Exception): pass

class ArgumentError(UserWarning):
	opt_str=''
	val=''
	choices=()
	def __init__(self,message,opt_str='',val='',choices=()):
		UserWarning.__init__(self,message)
		self.opt_str=opt_str
		self.val=val
		self.choices=choices

	def __str__(self,errstr=None,opt_str='',val='',choices=()):
		if opt_str: self.opt_str=opt_str
		if val: self.val=val
		if choices: self.choices=choices
		buf = [] 
		if errstr:
			buf.append(str(errstr))
		if self.opt_str or self.val or self.choices:
			if self.choices:
				x = "(choose from %s)" % ','.join(["'%s'" % choice for choice in self.choices])
			else:
				x = ''
			buf.append("%s - ERROR: option %s: invalid choice: '%s' %s" % \
				(os.path.basename(sys.argv[0]),
				 self.opt_str,
				 self.val,
				 x))
		return "\n".join(buf)

def conjoin(unknown,errors=[]):
	if hasattr(unknown,'message'):
		unknown = unknown.message
	if type(unknown) is type(str('')):
		errors.append(unknown)
	elif type(unknown) is type(list([])):
		errors.extend(unknown)
	elif type(unknown) is type(tuple((1,))):
		[errors.append(u) for u in unknown if u]
	return errors

# #############################################################################
# Custom Classes Below
# #############################################################################

# ============================================================================#
class NullLogHandler(logging.Handler):
	def emit(self, record): pass

#class MyThread(threading.Thread):
class MyThread(object):

	_pid = None # Process ID
	_pidfile = None # Instance of Pidfile management class
	_callbacks = []
	_parent_file = None
	_parent_name = None
	_parent = None
	_opts = None 
	action = None

	# -20 (most favorable to the process) to 19 (least favorable to the process)
	# default 10
	default_niceness = 10 
	_niceness = None

	# 0 for none, 1 for real time, 2 for best-effort, 3 for idle
	default_ioniceness_class = 2
	_ioniceness_class = None # was ioclass in pluto's (sf.net) pytis pre-merger

	# (0-7) with lower number being higher priority (only used when
	# ioniceness_class is 1 or 2)
	default_ioniceness = 4
	_ioniceness = None


	default_frequency = 1
	running = False

	def set_opts(self, opts):
		self._opts = opts
	def get_opts(self):
		if not self._opts: return optparse.Values()
		return self._opts
	opts = property(get_opts, set_opts)
	def setOpts(self,opts):
		self.opts=opts

	def set_parent_file(self, parent_file):
		self._parent_file = parent_file
	def get_parent_file(self):
		if not self._parent_file: self._parent_file = self.parent.__file__
		return self._parent_file
	parent_file = property(get_parent_file, set_parent_file)

	def set_parent_name(self, parent_name):
		self._parent_name = parent_name
	def get_parent_name(self):
		if not self._parent_name: 
			try:
				self._parent_name = os.path.basename(self.parent_file).split('.')[0]
			except: 
				self._parent_name = self.parent.__name__
		return self._parent_name
	parent_name = property(get_parent_name, set_parent_name)

	def set_parent(self, parent):
		self._parent = parent
	def get_parent(self):
		if not self._parent: self.parent = calling_module()
		return self._parent
	parent = property(get_parent, set_parent)

	# IO Niceness Class (0,1,2,3)
	def set_ioniceness_class(self, ioniceness_class):
		self._ioniceness_class = ioniceness_class
	def get_ioniceness_class(self):
		if not self._ioniceness_class:
			try: 
				self._ioniceness_class = opts.ioniceness_class
			except AttributeError as e: 
			# could set to default here, but that happens anyways right below 
				pass 
			# if there still is not one, perhaps opts.ioniceness_class was none
			if not self._ioniceness_class: 
				self.ioniceness_class = self.default_ioniceness_class 
		return self._ioniceness_class
	ioniceness_class = property(get_ioniceness_class, set_ioniceness_class)


	# IO Niceness (Classdata 0-7)
	def set_ioniceness(self, ioniceness):
		self._ioniceness = ioniceness
	def get_ioniceness(self):
		if not self._ioniceness: self.ioniceness = self.default_ioniceness
		return self._ioniceness
	ioniceness = property(get_ioniceness, set_ioniceness)

	def set_niceness(self, niceness):
		self._niceness = niceness
	def get_niceness(self):
		if not self._niceness: self.niceness = self.default_niceness
		return self._niceness
	niceness = property(get_niceness, set_niceness)

	def set_callbacks(self, i):
		self._callbacks.append(i)
	def get_callbacks(self):
		if not self._callbacks: return []
		return self._callbacks
	callbacks = property(get_callbacks,set_callbacks)

	def set_pid(self, pid):
		self._pid = pid
	def get_pid(self):
		if not self._pid: self.pidfile.pid
		return self._pid
	pid = property(get_pid, set_pid)

	def set_pidfile(self, pidfile):
		self._pidfile = pidfile
	def get_pidfile(self):
		if not self._pidfile: self._pidfile = Pidfile(self.parent_file)
		return self._pidfile
	pidfile = property(get_pidfile, set_pidfile)

	def __init__(self):
		global log
		self.keep_going=True
		if log is not None:
			self.setLogFile(log)
		atexit.register(self.stop)
		#threading.Thread.__init__(self)

	def start(self):
		''' You should override this method when you subclass Process.
It will be called before the process will be runned via when you call caplital 
Start. '''
		#self.log.debug('override start')
		pass

	def stop(self):
		''' You should override this method when you subclass Process.
It will be called after the process has been stopped or interupted by
signal.SIGTERM'''
		#self.log.debug('override stop')
		pass

	def setLogFile(self, log):
		self.log=log
	
	def control(self, action):
		action = action.lower().title()
		if action not in ('Start','Stop','Restart','Status'):
			log.error("Invalid control action, must be in <start,stop,restart,status>")
		try:
			getattr(self, action)()
		except RuntimeError as e:
			#print >> sys.stderr, e
			sys.stderr.write("%s\n" % str(e))

	def service(self, opts):
		''' alias for self.control with the "action" pulled out of opts and passed 
		in seperately
		'''
		try:
			self.action = opts.action
		except AttributeError as e:
			if type(opts) is type(str()) and opts.lower() in ('start','stop',
			'restart','status'):
				self.action=opts
			else:
				raise ProgrammerError("optparse action is missing, to " \
					"use MyThread.service optparse must have a valid action " \
					"(start,stop,restart,status)")
		try:
			self.niceness = opts.niceness
		except AttributeError as e:
			self.niceness = self.default_niceness

		try:
			self.ioniceness_class = opts.ioniceness_class
		except AttributeError as e:
			self.ioniceness_class = self.default_ioniceness_class

		try:
			self.ioniceness = opts.ioniceness
		except AttributeError as e:
			self.ioniceness = self.default_ioniceness
	
		try:
			self.frequency = int(opts.frequency)
		except (AttributeError, NameError, ValueError) as e:
			self.frequency = self.default_frequency

		return self.control(self.action)

	def register(self, run, *args,**kwargs):
		'''
		func - function to be called at exit
		targs - optional arguments to pass to func
		kargs - optional keyword arguments to pass to func
		'''
		c=Callback()
		c.setCallback(run)
		c.setArgs(*args)
		c.setKwArgs(**kwargs)
		self.callbacks = c

	def Start(self):
		stderr = sys.stderr
		old_pid = self.pidfile.validate()
		if old_pid:
			self.log.error("Error during service start:\n " \
				"Already running on PID %s (or pid file '%s' is stale)" % \
				(old_pid, self.pidfile.pidfile))
			return

		# Start the service
		self.log.info("starting the %s service now" % (self.parent_name))
		if self.daemonize():
			try:
				self.pidfile.create()
			except RuntimeError as err:
				# *IMPORTANT* No matter what, this will not make it to the screen.
				# Even print statements won't make it to the screen from here.
				# This is already within the spawned child process with no open pipes
				# to the parent.	The best we can do is log.
				self.log.error("Error during service start: %s" % str(err))
				return

			atexit.register(self.remove_pid)
			self.start()
			try:
				self.keep_going = True
				self.running = True
#				thread.start_new_thread(self.Run, None, self.opts)
				t=threading.Thread(None,self.Run,None)
#				self.Run()
				t.start()
				#t.opts=self.opts
			#	t.join()
			except Exception as e:
				self.keep_going=False
				self.running=False
				self.log.error(e)
				#print >> sys.stderr, e
				#sys.stderr.write(str(e))
				raise Exception(e)
				return
			self.log.info('%s service started' % self.parent_name)
		else:
			self.log.info("Success, all done")
		return

	def _fork(self, fid):
		''' fid - fork id'''
		
		try:
			pid = os.fork()
		except OSError as e:
			self.log.error(
				"service._fork(), fork #%d failed: %d (%s)\n" % (fid, e.errno, e.strerror))
			raise OSError(e)
		return pid
	
	def daemonize(self):
		'''
do the UNIX double-fork magic, see Stevens' "Advanced
Programming in the UNIX Environment" for details (ISBN 0201563177)
http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
'''

		def _maxfd(limit=1024):
			''' Use the getrlimit method to retrieve the maximum file
descriptor number that can be opened by this process. If
there is not limit on the resource, use the default value
limit - default maximum for the number of available file descriptors.
'''
			maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
			if maxfd == resource.RLIM_INFINITY:
				return limit
			else:
				return maxfd
		
		def _devnull(default="/dev/null"):
			# The standard I/O file descriptors are redirected to /dev/null by
			# default.
			if hasattr(os, "devnull"):
				return os.devnull
			else:
				return default

		def _close_fds(preserve=None):
			preserve = preserve or []
			for fd in range(0, _maxfd()):
				if fd not in preserve:
					try:
						os.close(fd)
					except OSError: # fd wasn't open to begin with (ignored)
						pass

		pid = self._fork(1) # first fork
		if pid == 0: # the first child
			os.setsid()
			pid = self._fork(2)
			if pid == 0: # the second child
				os.chdir("/")
				os.umask(0)
			else:
				os._exit(0)
			_close_fds(logging_file_descriptors())
		else:
			os._exit(0)

		os.open(_devnull(), os.O_RDWR)
		os.dup2(0, 1)	# standard output (1)
		os.dup2(0, 2)	# standard error (2)
		return True

	def remove_pid(self):
		if self.pidfile.validate():
			self.pidfile.unlink()
		self.log.info('the task completed, service was stopped')

	def _stop(self):
		self.keep_going=False
		self.stop()

	def Stop(self):
		pid = self.pidfile.validate()
		if not pid:
			self.log.error("pidfile %s does not exist. The %s service is not " \
			"running." % (self.pidfile.pidfile, self.parent_name))
			return # not an error in a restart

		# Try killing the service process
		try:
			while 1:
				os.kill(pid, signal.SIGTERM)
				time.sleep(0.1)
		except OSError as err:
			err = str(err)
			if err.find("No such process") > 0:
				self.pidfile.unlink()
			else:
				self.log.error('Error during service stop, %s' % str(err))
				raise OSError(err)

		self.log.info('stopping %s [%s] service.' %(self.parent_name, pid))
		self.log.debug('service [%s] was stopped by SIGTERM signal' % pid)

	#def remove_pid(self):
	#	if self.pidfile.validate(): self.pidfile.unlink()

	def IsRunning(self):
		return bool(self.pidfile.validate())
	
	def RunningAndService(self):
		return self.running

	def Status(self):
		pid = self.pidfile.validate()
		if pid:
			try:
				os.kill(pid, 0)
				print('process {} is running, pid: {}'.format(self.parent_name, pid))
				return
			except (OSError, TypeError):
				pass
		print( "{} process is not running".format(self.parent_name) )

	def Restart(self):
		self.log.info('restarting [%s] service.' % self.parent_name)
		self.Stop()
		self.Start()

	def Run(self):
		i=0
		os.nice(self.niceness)
		while self.keep_going:
			if not self.callbacks:
				self._run()
			else:	
				if self.frequency or ( not self.frequency and not i):
					for v in self.callbacks:
						callback = v.getCallback()
						args = v.getArgs()
						kwargs = v.getKwArgs()
						try:
							callback(*args,**kwargs)
						except (KeyboardInterrupt, QuitNow) as e:
							print("\nbye!")
							self.keep_going = False
							self._stop()
							self.running=False
							return
						except Exception as e:
							self.log.error("Some error occured.")
							type_,value_,traceback_ = sys.exc_info()
							self.log.debug("type: %s" % type_)
							self.log.debug("type2: %s" %type(e))
							self.log.debug("value: %s" % value_)
							for tb_line in traceback.format_tb(traceback_):
								self.log.debug(tb_line)
							self.log.error(str(e))

				if not self.frequency and not i:
						self._stop()
						self.running=False
						return

			if self.frequency:
				time.sleep(self.frequency)
				
			try:
				if self.opts.debug:
					i+=1
					if i > 2: 
						self._stop()
						self.running=False
						return
			except (AttributeError, NameError) as e:
				pass

	def _run(self):
		self.log.warn('running placeholder until callbacks are set')

# ============================================================================#
class Pidfile(object):
	''' Manage a PID file '''
	_filename = None  # just the name of the file with .pid extension on the end
	_pidfile = None # A.K.A. fullpath to file
	_path = None # path to save the PID file in, not including filename
	_name = None # name to create filename from, no extension
	_pid = None # PID (integer)
	log = None # log file

	caller = None

	def __init__(self, name=None):
		global log
		self.log = log
		self.name = os.path.basename(name)
		self.caller = calling_module()

	# --------------------------------------------------------------------------#
	# properties begin

	def set_log(self, log):
		self._log = log
	def get_log(self):
		if not self._log:
			global log; self._log=log
		return self._log
	log = property(get_log, set_log)
		# -------------------------------------- #
	def set_name(self, name):
		self._name = name
	def get_name(self):
		''' passed into new instance, or determined by the 'rename' method
		'''
		if not self._name: self.rename()
		return self._name
	name = property(get_name, set_name)
		# -------------------------------------- #
	def set_filename(self, filename):
		self._filename = filename
	def get_filename(self):
		''' self.name + .pid = filename
		'''
		if not self._filename: self._filename = "%s.pid" % self.name
		return self._filename
	filename = property(get_filename, set_filename)
		# -------------------------------------- #
	def set_path(self, path):
		self._path = path
	def get_path(self):
		''' determined based on OS, can be set on instance
		'''
		if not self._path:
			if os.name in ('posix'):
				rundir = '/run/'
			elif os.name in ('mac', 'os2', 'ce', 'riscos'):
				rundir = '/var/run/'
			elif os.name == 'nt':
				if self.caller is not None:
					rundir = os.path.join(os.path.dirname(self.caller.__file__), 
					'run/')
				else:
					rundir = os.path.join(os.path.dirname(__file__), 'run/')
			else:
				rundir = os.getcwd()
			self._path = os.path.abspath(rundir)
			if not os.path.isdir(self._path) or not os.path.exists(self._path):
				try:
					os.makedirs(self._path)
				except (OSError, IOError):
					self._path = os.path.join(self._path,'/user/')
					if not os.path.isdir(self._path) or not os.path.exists(self._path):
						try:
							os.makedirs(self._path)
						except (OSError, IOError):
							self._path = os.abspath(os.getcwd())
					#self._path = os.abspath(os.getcwd())
		return self._path
	path = property(get_path, set_path)
		# -------------------------------------- #
	def set_pidfile(self, pidfile):
		self._pidfile = pidfile
	def get_pidfile(self):
		''' if not set, use path + filename
		'''
		if not self._pidfile: 
			self._pidfile = os.path.abspath(os.path.join(self.path,self.filename))
		return self._pidfile
	pidfile = property(get_pidfile, set_pidfile)
		# -------------------------------------- #
	def set_pid(self, pid):
		self._pid = pid
	def get_pid(self):
		''' Actual Process ID as integer
		'''
		if not self._pid: self.pid=os.getpid()
		return self._pid
	pid = property(get_pid, set_pid)

	# properties end
	# --------------------------------------------------------------------------#
	# setter/getter methods begin

	def rename(self):
		self.caller = calling_module()
		if self.caller is not None:
			name = os.path.basename(self.caller.__file__)
		else:
			name = get_calling_file()
			if name is not None:
				name = os.path.basename(name)
		if name is None:
			name = self.__name__
		name=name.lower()
		try:
			self.name = name.split('.')[0]
		except IndexError as e:
			self.name = name

	def fixdirs(self):
		if not os.path.isdir(self._path) or not os.path.exists(self._path):
			try:
				os.makedirs(self._path)
			except (OSError, IOError):
				self.path = os.abspath(os.getcwd())
		return

	def fixpath(self,pidfile):
		self._pidfile=None
		self.fixdirs()
		try:
			pfile = open(pidfile,'w')
		except IOError as e:
			if self.caller is not None:
				rundir = os.path.join(os.path.dirname(self.caller.__file__), 'run/')
			else:
				rundir = os.path.join(os.path.dirname(__file__), 'run/')
			self.path = os.path.abspath(rundir)
			self.fixdirs()
			try:
				pfile = open(pidfile,'w')
			except IOError as e:
				self.path = os.path.abspath(os.getcwd())
			else:
				pfile.close()
		else:
			pfile.close()
		return

	# setter/getter methods end 
	# --------------------------------------------------------------------------#
	# begin methods 

	def create(self,attempt=0):
		''' create pid file
			Be very careful, simply accessing the path or pidfile property will set
			them, and in this case that is bad, because if this method finds the path
			set, and non-existant it will error out.	Accessing the pidfile accesses
			by-proxy, the path.
		'''

		pid = self.validate()
		if pid:
			if pid == os.getpid():
				# This, the current process/instance IS the PID, and it has already 
				# been created.
				return
			raise RuntimeError("Already running on PID %s " \
				"(or pid file '%s' is stale)" % (pid, self.pidfile))
				
		self.pid = os.getpid()

		# Write pidfile
		if self.path and not os.path.isdir(self.path):
			raise RuntimeError("%s doesn't exist. Can't create pidfile %s" % \
				(self.path, self.pidfile))

		try:
			pfile = open(self.pidfile,'w')
			pfile.write("%s\n" % self.pid)
			pfile.close()
		except IOError as e:
			self.fixpath(self.pidfile)
			if attempt > 1:
				raise RuntimeError(e)
			else:
				self.create(attempt+1)
		else:
			# set permissions to -rw-r--r--
			os.chmod(self.pidfile, 420)
			
	def unlink(self):
		""" delete pidfile"""
		try:
			#with open(self.pidfile, "r") as f:
			#	pid_in_file = int(f.read() or 0)
			os.unlink(self.pidfile)
		except:
			pass

	def validate(self):
		""" Validate pidfile and make it stale if needed"""
		if not self.pidfile or not os.path.exists(self.pidfile):
			return False
		try:
				pfile = open(self.pidfile, "r")
				pid = int(pfile.read(-1).strip())
				pfile.close()
				if pid <= 0:
					return
				try:
					os.kill(pid, 0)
					# old exiss, kill the old
					return pid
				except OSError as e:
					# could not kill the old for one reason or another
#					self.log.error("Pidfile.validate - OSError(%s)" % e)
					if e[0] == errno.ESRCH:
						return
					raise RuntimeError("Can not kill process [%s] or remove old PID file (%s), permission denied. - OSError(%s)" % (pid,self.pidfile,e))
		except IOError as e:
			self.log.error("Pidfile.validate - IOError(%s)" % e)
			if e[0] == errno.ENOENT:
				return
			raise RuntimeError("Pidfile.validate - IOError(%s)" % e)
		except ValueError as e:
			#self.log.info("likely the contents of the pid file could not be cast to an int: '%s'" % str(pid))
			self.log.debug("Pidfile.validate - ValueError(%s)" % e)
			raise ValueError(e)

	# end methods
	# --------------------------------------------------------------------------#


# ============================================================================#
class ConfigFile(COBJ.ConfigObj):
	_filename = None
	_opts = {} # OptionParser option value's dictionary attribute
	_fields = [] # list of field names
	_field_settings = {} # new list of fieldnames, until old variable has been fixed.

	_optional_fields = [] # list of optional field names 
	_exists = None # config file bool flag

	config = None # var to store COBJ object instance on
	prompts = [] # for saving, i.e. "Are you save the password to the .ini file?"

	# lazy_override: if True, then you can redeclare
	# ConfigFile.addField('SaidName',*args) and it will override a previously
	# supplied 'SaidName'	ELSE, by default, it will raise an error.
	_lazy_override = False

	'''
	def __getattr__(self,key):
		try:
			return dict.__getattr__(self, key)
		except AttributeError as e:
			try:
				return dict.__getitem__(self, key)
			except KeyError, e:
				return None
	'''
	# ###########################################################################
	# begin properties
	def set_exists(self):
		if self.filename and os.path.exists(self.filename):
			self._exists = True
		else:
			self._exists = False
	def get_exists(self):
		if self._exists is None:
			self.set_exists()
		return self._exists
	exists = property(get_exists, set_exists)

	def set_fields(self, fields):
		self._fields = fields
	def get_fields(self):
		return self._fields
	fields = property(get_fields, set_fields)

	def set_optional_fields(self, optional_fields):
		self._optional_fields = optional_fields
	def get_optional_fields(self):
		return self._optional_fields
	optional_fields = property(get_optional_fields, set_optional_fields)

	def set_lazy_override(self, lazy_override):
		self._lazy_override = lazy_override
	def get_lazy_override(self):
		return self._lazy_override
	lazy_override = property(get_lazy_override, set_lazy_override)

	def set_opts(self, opts):
		self._opts = opts
	def get_opts(self):
		return self._opts
	opts = property(get_opts, set_opts)

	def set_filename(self, fname=os.path.abspath(sys.argv[0])):
		self._filename=os.path.abspath(fname)
	def get_filename(self):
		if not self._filename:
			self.set_filename()
		return self._filename
	filename = property(get_filename, set_filename)
	# end properties
	# ###########################################################################

	def __init__(self, opts=None):
	# XXX - TODO !!!!
	# right now opts get passed into the init, and then set as an attribute on
	# this class.	But THEN we request them time and time again from the user
	# an argument for some of the methods.	That is silly, we already passed i
	# in once, why ask for it again.	We need to clean that up a bit.
	
	# XXX-TODO: I know I do the same thing as below in a few files to grab the
	# config file, filename.	I could just get it off this class as an attribu
	# Additionally, I would like to have the filename as one attribute/propert
	# and the filepath as a separate one.	However I can't make this second
	# change just, as I have to ensure backwards compatibility.
		self.filename = os.path.abspath(os.path.join(__configdir__, \
		'%s.ini' % os.path.basename(os.path.abspath(sys.argv[0]))))

		if self.exists:
			self.config = self.getConfig(True)

		if opts:
			self.fields = opts.__dict__.keys()
			self.opts = dict(opts.__dict__.items())

	# brain dump here....	We need a better way to create this datasource.	It
	# should specify the default value (if it exists), its relative
	# OptionParser option, it's config file name, whether or not it can get
	# saved in the global section.	Whether or not it inherits from above
	# sections, it's type cast, etc.	I can start with a simple addField
	# method, and extend that to do a batchAddFields method.	I can already
	# forsee a good reason for YAML, to create config file definitions, but I
	# don't want to get to far ahead of myself.	It is already going to be ver
	# difficult to create this loosly coupled enough that it can get reused in
	# any of my programs that use ini files.	There are already some examples
	# of scripts that use pylib.configobj.ConfigObj (COBJ.load) instead of
	# PyTis.ConfigFile.	I don't know why, but they should all, in theory, be
	# able to use this one.
	
	def batchAddFields(self,L=[]):
		""" L should be a list of dictionaries, each of which could be passed as
		kwargs directly into ConfigFile.addField() """
		for kwargs in L:
			self.addField(**kwargs)
	
	def addField(self, config_name, required=True, default_value=None, \
		option=None, opt_parse_destination=None, global_scope=True, inherited=True,
		prompt=False, cast=str, title_override=None):
			if not self.lazy_override and config_name in self.field_settings.keys():
				raise ProgrammingError('This config field ("%s") has already been ' \
				'added.' % config_name)
		
			d = {
				'config_name':config_name,
				'required':required,
				'default_value':default_value,
				'option':option,
				'opt_parse_destination':opt_parse_destination,
				'global_scope': global_scope,
				'prompt':prompt,
				'inherited':inherited,
				'cast':cast,
				'title_override':title_override
			}
			field = ConfigField(d)
			self.field_settings[config_name]=field

	# ########################################################################
	# ########################################################################
	# ########################################################################
	def validate_opt(self,key, section_name=None):
		""" To clarify, this is just to make sure that the option can be found,
		not as an option argument, then in the section's configuration, and if n
		there, then look to the global configuration settings.	If a required fi
		cannot be found, raise an empty string error.
	
		field attributes to consider (they all need handled, otherwise, what
		the hell was the point in setting them?
		field(
			config_name='niceness',
			option=opts.niceness,
			opt_parse_destination='niceness',
			required=True,
			cast=int
			default_value=PyTis.MyThread.default_niceness,
	
			global_scope=True,
			inherited=True,
	
			)
	
		"""
		global log
		field = self.field_settings[key]
		dig_config=False
		found_value = None
	
		try:
			opt_val = self.opts[key]
		except KeyError as e:
			# doesn't even have the attribute in options, the look to config
			dig_config=True
		else:
			if type(opt_val) == type(str('')) and opt_val=='=' or not trim(opt_val):
			# an empty string
				if field.cast == int:
					if field.default_value == opt_val:
						dig_config = True
					elif field.default_value == 0 and field.required:
						dig_config = True
				else:
					opt_val=''
					dig_config=True
		
			if type(opt_val) is type(list([])) and not trim(opt_val):
			# an empty list
				opt_val = []
				dig_config=True
		
			# if it does exist in the options as an attribute, but only because it
			# the default, then we need to really look to the configuration
			if field.opt_parse_destination is not None and \
				field.option is not None and \
				field.option == field.default_value:
				# not empty, but equal to the default
				dig_config=True
				found_value = field.option
				# so down below, while digging config, we can allow extending of val
				# for intheritted fields, UNLESS the found_value == detfault value.
				# therefore, below, expect to check the field.default_value at least
				# twice, once within the section if a value is found, and again with
				# the global, if a value is found.	Come to think about it we check
				# global multiple times so likely, we will be doing the same thing o
				# and over again, so likely we will need to turn this into a functio
		
				# some func(optval from optparser, sectional val, global val, field
				# itself)

				# this makes since, but should not be extended, because then it woul
				# only always extend into set values, default values
	
			elif field.opt_parse_destination is not None and \
				field.option is not None and \
				not dig_config and trim(opt_val):
				# plain and simple we found a value that was specified by the user o
				# STDIN, this is not a default value.
				found_value = field.option
				# so we don't need to look through the config
		
				if field.cast == dict or field.cast == list and field.inherited:
					# Unless... it needs to be extended because it is an inheritable s
					dig_config = True
		
		sectional_value = None
		global_value = None
		if dig_config or not key in self.opts.keys():
			try:
				self.config[section_name]
			except KeyError as e:
				raise EmptyString('Section "%s" provided, and could not be found in ' \
				'the config file.' % section_name)
		
			# LOADING
			try:
				sectional_value = self.config[section_name][key]
			except KeyError as e:
				if section_name and field.required:
					log.warn('"%s" not found under section: %s, looking into global ' \
					'section.' % (field.title,section_name))
			else:
				if section_name and not trim(sectional_value) and field.required:
					log.warn('"%s" not found under section: %s, looking into global ' \
					'section.' % (field.title,section_name))
		
			try:
				global_value = self.config[key]
			except KeyError as e:
				if trim(sectional_value) and field.required and section_name:
					# there is a value, it is required, and there is a section
					pass
				elif not trim(sectional_value) and field.required:
					# there is NOT a value, it is required, and there is a section
					if not trim(found_value):
						if section_name:
							raise ConfigurationError('"%s" not found in the global ' \
								'section of the configuration file, and is required. ' \
							'Unable to lookup: [%s:%s].' % (field.title,section_name,key))
						else:
							raise ConfigurationError('"%s" not found in the global ' \
							'section of the configuration file, and is ' \
							'required.' % field.title)
			else:
				if not field.global_scope:
					raise ConfigurationError("Somebody directly edited the ' \
					'configuration ini file (%s).  You may not specify the '%s' in ' \
					'the global section." % (field.title,self.filename))
			
			# CASTING
			if sectional_value or field.cast == int and sectional_value == 0:
				try:
					if field.cast == bool:
						sectional_value = mbool(sectional_value,False)
					else:
						sectional_value = field.cast(sectional_value)
				except (ValueError, TypeError) as e:
					raise ConfigurationError('Wrong type of value stored for "%s" in '
					'section "%s", it must be a: %s.' % (field.title, section_name,
					str(field.cast)))

			if global_value:
				try:
					if field.cast == bool:
						sectional_value = mbool(global_value,False)
					else:
						global_value = field.cast(global_value)
				except (ValueError, TypeError) as e:
					raise ConfigurationError('Wrong type of value stored for "%s", ' \
          'it must be a: %s.' % (field.title, str(field.cast)))

  
		# CASTING

		if found_value:
			try:
				if field.cast == bool:
					sectional_value = mbool(found_value,False)
				else:
					found_value = field.cast(found_value)
			except (ValueError, TypeError) as e:
				raise ConfigurationError('Wrong type of value passed in STDIN as an ' \
				'argument for "%s", it must be a: %s.' % (field.title,str(field.cast)))
	
		value = None
		if dig_config or not key in self.opts.keys():
			# log.debug("key: %s" % key)
			# log.debug("sectional_value: %s" % sectional_value)
			# log.debug("global_value: %s" % global_value)
			# log.debug("field.inherited: %s" % field.inherited)
	
			if field.inherited and field.global_scope:
	
				if field.cast == dict:
	
					if field.update_type == 'parent':
						sectional_value.update(global_value)
						if trim(found_value):
							sectional_value.update(found_value)
						value = sectional_value
					elif field.update_type == 'child':
						global_value.update(sectional_value)
						if trim(found_value):
							global_value.update(found_value)
						value = global_value
					else: # == none, only update if there is an option value
						if trim(sectional_value):
							value = sectional_value
						elif trim(global_value):
							value = global_value
	
						if trim(found_value):
							value.update(found_value)
					return value

			elif field.inherited and not field.global_scope:
				if trim(sectional_value):
					value = unique(sectional_value)
				elif trim(global_value):
					value = unique(global_value)
	
				if trim(found_value):
					value.extend(found_value)
					value = unique(value)
				return value
	
			if trim(sectional_value) or field.cast == int and sectional_value == 0:
				return sectional_value
			if trim(global_value):
				return global_value
	
		# stuck here
			if trim(found_value):
				if section_name and field.default_value and \
					found_value == field.default_value:
	
					log.warn('We could not find a saved value for "%s," we will use ' \
					'the default value of "%s."	You may	want to save a value in the ' \
					'config for this field	under section: "%s"' % \
						(field.title, field.default_value, section_name))
	
	
				elif field.global_scope and field.default_value and \
				found_value == field.default_value:
					log.warn('We could not find a saved value in the global section ' \
					' for "%s," we will use the default value of "%s."' % \
					(field.title, field.default_value))
				elif field.default_value and found_value == field.default_value:
					log.warn('We could not find a saved value anywhere for "%s."	You' \
					' may want to save a value in the config for this field.' % \
					field.title)
				return found_value
		else:
			if trim(found_value) or field.default_value is None and found_value == 0:
				return found_value
			elif field.required:
				del self.opts[key]
				return validate_opt(key,section_name)
			else:
				if field.cast == str:
					return field.cast('')
				elif field.cast == list:
					return field.cast([])
				elif field.cast == tuple:
					return field.cast(())
				elif field.cast == int:
					return field.cast(0)
				elif field.cast == float:
					return field.cast(0)
				elif field.cast == dict:
					return field.cast({})
				elif field.cast == bool:
					return field.cast(False)
	
	

	# ########################################################################
	def validateToSave(self, opts):
		return self.validate(opts, sparce=True)
	
	def validateToRun(self, opts):
		return self.validate(opts, sparce=False)

	def validate(self, opts, sparce=True):
		""" Very similar to what will occur within the run function.	This funct
		will ensure that the required data for all of the sections (or only one
		section, if only one is specified to be ran/tested via the optional attr
		"--section-name=[NAME OF SECTION]").	If the required data cannot be fou
		the parsed arguments/options (or can be found, but is simply a default
		value), then look to the config.	If it cannot be found within the secti
		then look globally within the config.	Lastly, unless the action and sec
		were sprecifically specified within the STDIN optional arguments, then t
		may skip over sections who have the ignore flag set.
	
		This makes sure that when this runs for a cronjob, that each section tha
		could run, will.	In other words, each section that is not explicedly se
		"ignore" have all required variables set, or can be inherited.
		"""
		global log
	
		if opts:
			self.opts = dict(opts.__dict__.items())
	
		sections = identify_sections(self.config)
		field_keys = self.field_settings.keys()
		field_keys.sort()
	
		# Below could be done, but would be redundant, since our logger
		# (set_logging) already does this.
		#
		# opt_keys = [opt_key for opt_key in opts.__dict__.keys() \
		# if opt_key not in [foo.opt_parse_destination \
		# for foo in self.field_settings.values() if foo.opt_parse_destination i
		# opt_keys.sort()
		# log.debug("# -- GLOBAL")
		# for opt_name in opt_keys:
		# value = opts.__dict__[opt_name]
		# log.debug("ARGUMENT OPTIONS [GLOBAL] %s: %s" % (opt_name,value))
		# log.debug('-'*80)
	
		errors = []
		if hasattr(opts,'action') and opts.action and trim(opts.action).strip():
			opts_action = trim(opts.action)
		else:
			opts_action = None
	
		if hasattr(opts,'section_name') and opts.section_name and \
		trim(opts.section_name).strip():
			opts_section_name = trim(opts.section_name)
		else:
			opts_section_name = None
	
	
		if sections:
			for section_name, section in sections:
				if opts_section_name and \
				opts_section_name.lower()==section_name.lower():
					# a section was specified on the command line, so we are only goin
					# to handle this one, skipping all others.
					if opts_action and opts_action.lower() != 'ignore':
						# keep going, we aren't being told to ignore
						# so if it did say ignore in the config, they just overrode it.
						# so go ahead and pass through, allowing validation below to occ
						pass
					elif trim(section.get('action','use')).lower() == 'ignore':
						# STDIN command line action was not overridden, and the config f
						# says ignore, so we should continue on to the next section,
						# skipping this one.	they did not tell the STDIN to ignore, and
						# the config file says to ignore, so we will skip
						continue
				elif opts_section_name:
					# as I said above, a section was specified on the command line, so
					# continue over this one, because this one's name isn't the same a
					# the one specified.
					# it was specified on STDIN and it isn't the one we are in
					continue
				else:
					# a section was not specified on the command line, so we should
					# validate all of them
	
					# including global?
					if sparce:
						for config_name in field_keys:
							try:
								value = self.validate_opt(config_name,None)
							except (EmptyString, ConfigurationError) as er:
								conjoin(er,errors)
								#[log.error(e) for e in errors if e]
								#sys.exit(1)
							else:
								log_value = value
								if config_name.upper() in ('PASSWD','PASSWORD','PASS',
								'CLOUD_CHECKER_ACCESS_KEY','SR_SECRET_ACCESS_KEY','DB_PASSWORD'):
									log_value='*'*8
	
								log.debug("VALIDATED OPTIONS [GLOBAL] %s: %s" % \
									(config_name,log_value))
	
								field = self.field_settings[config_name]
								if field.global_scope and (value != field.default_value):
									self.config[config_name] = value
	
						#	 #	 #
	
				log.debug("# -- %s" % section_name)
	
				for config_name in field_keys:
					try:
						value = self.validate_opt(config_name,section_name)
					except (EmptyString, ConfigurationError) as er:
						conjoin(er,errors)
						#[log.error(e) for e in errors if e]
						#sys.exit(1)
					else:
						log_value = value
						if config_name.upper() in ('PASSWD','PASSWORD','PASS',
							'CLOUD_CHECKER_ACCESS_KEY','SR_SECRET_ACCESS_KEY','DB_PASSWORD'):
							log_value='*'*8

						log.debug("VALIDATED OPTIONS [%s] %s: %s" % \
							(section_name,config_name,log_value))
	
						field = self.field_settings[config_name]
						if (value != field.default_value or not sparce):
							if section_name not in self.config.keys():
								self.config[section_name] = {}
							self.config[section_name][config_name] = value
		else:
			# we either have the first new section ever for a config, or we are
			# editing the global scope of the config
	
			if opts_section_name:
				log.debug("# -- %s" % opts_section_name)
			else:
				log.debug("# -- GLOBAL SCOPE")
	
			for config_name in field_keys:
				try:
					value = self.validate_opt(config_name,opts_section_name)
				except (EmptyString, ConfigurationError) as er:
					conjoin(er,errors)
				else:
					log_value = value
					if config_name.upper() in ('PASSWD','PASSWORD','PASS'):
						log_value='*'*8
					if opts_section_name:
						log.debug("VALIDATED OPTIONS [%s] %s: %s" % \
							(opts_section_name,config_name,log_value))
					else:
						log.debug("VALIDATED OPTIONS [GLOBAL] %s: %s" % (opt,log_value))
	
					field = self.field_settings[config_name]
					if ((not opts_section_name and field.global_scope) or \
					opts_section_name) and (value != field.default_value or not sparce):
						if opts_section_name:
							if opts_section_name not in self.config.keys():
								self.config[opts_section_name] = {}
							self.config[opts_section_name][config_name] = value
						else:
							self.config[config_name] = value

		if errors:
			[log.error(e) for e in errors if e]
			sys.exit(1)
	
		log.debug('-'*80)

	# ########################################################################
	# ########################################################################
	# ########################################################################
	
	def ensureLoaded(self):
		""" self explanitory, load, load now, whatever you can."""	
		if self.config == None:
			if self.exists:
				self.config = self.getConfig()
			else:
				self.config = {}

	def __getitem__(self, key):
		self.ensureLoaded()
		return self.config[key]
	
	def values(self):
		self.ensureLoaded()
		return self.config.values()

	def keys(self):
		self.ensureLoaded()
		return self.config.keys()

	def load(self, force=False):
		""" (alias for getCOnfig)
		"""
		return self.getConfig(force)

	def getConfig(self, force=False):
		self.config = COBJ.load(self.filename, force)
		self.set_exists()
		return self.config

	def saveConfig(self, opts=optparse.Values, section_name=None):
		global log
		if opts:
			self.opts = dict(opts.__dict__.items())

		self.config = self.getConfig(True)

		if section_name:
			section_name=section_name.strip()
			try:
				config = self.config[section_name]
			except KeyError as e:
				self.config[section_name] = {}
				config = self.config[section_name]
		else:
			log.debug("No section_name '%s' provided, saving globally."%section_name)
			config = self.config

		if self.field_settings:
			errors = []
			for config_name, field in self.field_settings.items():
				try:
					 value = self.validate_opt(config_name,section_name)
				except (EmptyString, ConfigurationError) as er:
					conjoin(er,errors)
				else:
					if not field.prompt or (field.prompt and getInputYN("Are you sure you wish to save the %s?" % field.title,
								"This is not encrypted, and will be stored in plain text.")):
						config[config_name] = value
					else:
						log.debug("User choose not to save %s" % field.title)


				if type(value) == type(None) and type(field.cast) != type(value):
					log.debug("removing %s from config code 6579" % config_name)
					del config[config_name]

			if errors:
				[log.error(e) for e in errors if e]
				sys.exit(1)

			if not section_name:
				self.config.update(config)
			else:
				self.config[section_name].update(config)
			self.config.save()

		else:
			# beginning of the old way XXX-TODO this will need phased out
			for k in self.opts.keys():
				if self.opts[k] is None or k not in self.fields:
					del self.opts[k]

			for fld in config.keys():
				sub = config[fld]
				if str(type(sub)) == "<class 'pylib.configobj.Section'>":
					pass
				elif self.exists and fld not in self.fields:
					del config[fld]
			
			for prompt in self.prompts:
				if self.opts.get(prompt, None) is not None:
					if not getInputYN("Are you sure you wish to save the %s?" % prompt,
							"This is not encrypted."):
						if prompt in self.opts.keys():
							del self.opts[prompt]
						if self.exists and prompt in config.keys():
							del config[prompt]
			# END of old way XXX
		
		if not section_name:
			self.config.update(self.opts)
		else:
			config.update(self.opts)
		self.config.save()

		try:
			if opts.debug:
				log.debug("Saving options to: '%s'" % self.filename)
		except (AttributeError, NameError) as e:
			pass


class ConfigField(odict,dict):

	_defaults = dict(default_value=None, global_scope=True, inherited=True, \
	cast='str', option=None,required=True, extendable=False, updateable=False, \
	utype=None,prompt=False,config_name=None, title_override=None)
	#_defaults = {}

# _utype=None

	# --------------------------------------------------------------------------#
	# begin properties
	"""
	# additional properties that can be set inline
	# Lists
	def set_extendable(self,extendable):
		''' So the field cast is a list, and it may inherit from the parent
	sections, i.e. the global config section.	Great, does the global list get
	completly replaced if a section value is found, or does the list get
	extended? '''
		self._extendable=bool(extendable)
	def get_extendable(self): return self._extendable
	extendable = property(get_extendable, set_extendable)

	# Dicts
	def set_updateable(self,updateable):
		''' So the field cast is a dict, and it may inherit from the parent sections,
	i.e. the global config section.	Great, does the global dict get completly
	replaced if a section value is found, or does the list get extended? '''
		self._updateable=bool(updateable)
	def get_updateable(self): return self._updateable
	updateable = property(get_updateable, set_updateable)
	"""

	def set_update_type(self,utype=None):
		if (utype and type(utype) is type(str('')) and utype.lower.strip() in \
		('parent','global','child')) or utype is None:
			self._utype=utype
		else:
			raise ProgrammingError("PyTis.ConfigField.update_type(): Invalid" \
			" value selected, please choose from 'parent', 'global', 'child', or None.")
	def get_update_type(self):
		return self._utype
	update_type = property(get_update_type,set_update_type)

	# end properties
	# --------------------------------------------------------------------------#

	def __init__(self,dict,other={}):
		odict.__init__(self,dict)
		if other:
			self._defaults = other

		if type(self.config_name) != type(str('')) or not self.config_name.strip():
				raise ProgrammingError('The first argument, the "config name" is ' \
				'required.')

		if 'title_override' not in self.keys() or not self['title_override']:
			self['title']=self.config_name.replace('_',' ').replace('-',' ').strip().title()
		elif self.title_override:
			self['title'] = self.title_override.strip()

	def __getitem__(self, key):
		# check the first place to look, self as dictionary
		if self.has_key(key): ###
			return odict.__getitem__(self,key)
		# check default dictionary
		elif self._defaults.has_key(key):
			return self._defaults.get(key)
		# do we have it as an attribute?
		try:
			return dict.__getattribute__(self,key)
		except AttributeError:
			raise KeyError(key)

	def __setattr__(self, attr, val):
		if attr in ('_keys', '_defaults','data'):
			return dict.__setattr__(self, attr, val)
		else:
			dict.__setattr__(self, attr, val)
			UserDict.__setitem__(self, attr, val)
			if attr not in self._keys: self._keys.append(attr)
			return

	# --------------------------------------------------------------------------#

def config_file():
	global __configdir__
	return "%s.ini" % os.path.abspath(os.path.join(__configdir__, \
		os.path.basename(sys.argv[0])))

def load_config(config_file=config_file()):
	global config
	config = COBJ.load(config_file, True)
	return config


# ============================================================================#
class MyLogger(logging.Logger):
	opt_debug = False
	opt_full_verbose = False
	opt_verbose = False
	opt_had_verbose = False
	opt_quiet = False
	had_error = False
	had_warning = False
	paused = False

	def Pause(self):
		return self.pause()
	def pause(self):
		self.paused = True
	def unPause(self):
		self.paused = False

	def setopts(self, opts):
		try:
			self.opt_full_verbose = opts.totally_verbose
		except AttributeError as e:
			try:
				self.opt_full_verbose = opts.verbose
			except AttributeError as e:
				pass

		try:
			self.opt_verbose = opts.verbose
		except AttributeError as e:
			pass

		try:
			self.opt_debug = opts.debug
		except AttributeError as e:
			pass

		try:
			self.opt_quiet = opts.quiet
		except AttributeError as e:
			pass

		try:
			self.opt_had_verbose = opts.had_verbose
		except AttributeError as e:
			pass


	@property
	def hadWarning(self):
		return self.had_warning

	@property
	def hadErrors(self):
		return self.had_error

	def _log(self, level, msg, args, exc_info=None):
		"""
		Low-level logging routine which creates a LogRecord and then calls
		all the handlers of this logger to handle the record.
		"""
		if self.paused:
			return
		if level == logging.ERROR:
			#print >> sys.stderr, 'ERROR: ', msg
			sys.stderr.write("ERROR: %s\n" % msg)
			self.had_error = True
		if level == logging.WARN and not self.opt_quiet:
			print('WARNING: %s' % msg)
			self.had_warning = True
		if level == logging.INFO and self.opt_verbose:
			print(msg)
		#if level == logging.DEBUG and self.opt_verbose and self.opt_debug:
		#	print msg
		#if level == logging.DEBUG and self.opt_full_verbose and self.opt_debug:
		#if level == logging.DEBUG and self.opt_verbose and self.opt_debug:
		if level == logging.DEBUG and self.opt_full_verbose and self.opt_debug:
			print( msg)

		if logging._srcfile:
			fn, lno, func, stack_info = self.findCaller()
		else:
			fn, lno, func = "(unknown file)", 0, "(unknown function)"
		if exc_info:
			if type(exc_info) != types.TupleType:
				exc_info = sys.exc_info()
		record = self.makeRecord(self.name, level, fn, lno, msg, args, exc_info)
		self.handle(record)

# ============================================================================#
class MyParser(optparse.OptionParser):
	extra_txt = None
	helpishere = False
	py_args = []
	py_opts = []
	"""
	The below variable is new, but I want to have backwards compatability.  If
	you turn this variable on, and make set it to True then the print_help will
	hide the default help page which lists well formatted options and their help
	messages.	I choose to do this because while in the extra_txt, I usually
	provide additional help, in the current program I am working on the
	extra_txt represents an entire man page with greater detail on each
	individual option.  Therefore I do not wish to show the built-in,
	auto-generated help message as well.  Lastly, you won't actually set this
	variable directly, I am creating a setter and getter method to treat it as a
	property, which you should find under the __init__.  
	"""
	_full_help_available = False

	def setFullHelpAvaiable(self):
		self._full_help_available=True

	'''
	def set_helpishere(self,b=True):
		self._full_help_available=b
	def get_full_help_available(self):
		return self._full_help_available
	full_help_available = property(get_full_help_available, set_full_help_available)
	'''

	def set_full_help_available(self,b):
		self._full_help_available=b
	def get_full_help_available(self):
		return self._full_help_available
	full_help_available = property(get_full_help_available, 
		set_full_help_available)

	def __init__(self,
							 usage=None,
							 option_list=None,
							 option_class=optparse.Option,
							 version=None,
							 conflict_handler="error",
							 description=None,
							 formatter=None,
							 add_help_option=True,
							 prog=None,
							 epilog=None):

		optparse.OptionParser. __init__(self,
							 usage, option_list, option_class, version, conflict_handler, 
							 description, formatter, add_help_option, prog, epilog)

	def print_out(self, txt):
		import curses
		#txt = txt.replace("`$","\n")
		txt = txt.replace("`$","\n                     ")
		#txt = txt.replace(":\n",":\n\n")
		win=curses.initscr()
		max_x, max_y = win.getmaxyx()
		curses.endwin()
		if len(txt.split("\n")) > max_x:
			pager = pydoc.getpager()
			try:
				pager(txt)
			except (EOFError, KeyboardInterrupt) as e:
				pass
		else:
			sys.stdout.write("%s\n" % txt)

	def print_help(self, errors=None):
		"""
		NAME
		SYNOPSIS
		DESCRIPTION
		OPTIONS
		COMMANDS
		ENVIRONMENT
		SEE ALSO
		AUTHOR
		HISTORY
		VERSION
		"""
		buf = StringIO()
		sys.stdout = buf

		# The user did not enter --help, they only entered -h, show short help and
		# instructions on howto view full help.
		if not '--help' in sys.argv and self.extra_txt is not None:
			# print the short usage.
			self.set_usage("%s\n%s" % (self.get_usage(), "*** USE '--help' for the full help page. ***"))

		# If NOT (--help was typed in, and there is extra_text to show, and
		# full_help_available)
		if not (self.full_help_available and '--help' in sys.argv and self.extra_txt is not None):
			# print help as the OptionParser normally would, without extra goodies
			optparse.OptionParser.print_help(self)


		extras = ''
		if '--help' in sys.argv and self.extra_txt is not None and errors is None:
			"""
			try: extras = "Created: %s\n" % __created__
			except NameError: pass
			try: extras = "%sAuthor: %s\n" % (extras,__author__)
			except NameError: pass
			try: extras = "%sCopyright: %s\n" % (extras,__copyright__)
			except NameError: pass
			try: extras = "%sVersion: %s\n" % (extras,__version__)
			except NameError: pass
			if extras:
				self.extra_txt = "\n%s\n\n%s" % (self.extra_txt, extras)
			"""
			#print self.extra_txt
			# FIXME - 
			self.print_out(self.extra_txt)

		if not errors:
			errrors = []
		elif not isinstance(errors, list):
			errors = [errors]

		sys.stdout = sys.__stdout__
		# XXX:TODO - 2 Weeks ago I was writing a ManPage builder.  Afer looking
		# back at this method I wrote years ago.  I realized it would be easy to
		# alter this code just slightly to have it generate manpages.  It may be
		# better to just add a similar method for generating manpages, easier than
		# what I was doing.
		self.print_out(buf.getvalue().replace("Options:\n","OPTIONS:\n").replace(":\n",":\n\n"))
		#txt = txt.replace(":\n",":\n\n")

		if errors:
			sys.stderr.write("\n")
			for error in errors:
				sys.stderr.write(wrap("ERROR: %s\n" % error))
		sys.stderr.flush()

		return bool(errors)

# ============================================================================#
class Callback(object):
	def __init__(self):
		self.cb = None
		self.a = [] 
		self.k = {}

	def setCallback(self,cb): self.cb=cb
	def getCallback(self): return self.cb
	def setArgs(self,*a): self.a=a
	def getArgs(self): return self.a
	def setKwArgs(self,**k): self.k=k
	def getKwArgs(self): return self.k


class ImmutableDict(UserDict):
	""" This is a dictionary that enforces as set once and only once policy.
	Then if you try to overwrite a key with a new value, it will still maintain
	it's original value.

	The one and only option that gives this any flexibility, is to allow keys
	with empty values (None or '') to be re-assigned non-empty values, however
	this feature must be enabled.

	"""
	_reassign_empties = False

	#@property
	#def 
	
	def allowEmptyReset(self):
		self.reassign_empties = True

	@property
	def emptyReset(self):
		return self._reassign_empties

	def set_reassign_empties(self, b):
		self._reassign_empties =b 
	def get_reassign_empties(self):
		return self._reassign_empties
	reassign_empties = property(get_reassign_empties, set_reassign_empties)

	def __init__(self, **kwargs):
		""" # Start by filling-out the abstract methods
		"""
		self._keys = []
		UserDict.__init__(self, dict(kwargs))

	def __delitem__(self, key):
		""" # We must override this in order to delete the key from our list of
		keys set on self._key.  First we will call the parent, and finally we will
		remove our own reference to the key.
		"""
		UserDict.__delitem__(self, key)
		self._keys.remove(key)

	def __setitem__(self, key, item):
		""" key:hashable item
				item: value to assign
		"""
		if key in self._keys: 
			if not self.reassign_empties: return
			else:
				old_item = self.__getitem__(key)
				if old_item is None or (type(old_item) is str and old_item == ''):
					pass
				else: return

		UserDict.__setitem__(self, key, item)
		if key not in self._keys: self._keys.append(key)

	def setdefault(self, key, failobj = None):
		""" D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
		"""
		if key in self._keys: 
			if not self.reassign_empties: return
			else:
				old_item = self.__getitem__(key)
				if old_item is None or (type(old_item) is str and old_item == ''):
					pass
				else: return

		UserDict.setdefault(self, key, failobj)
		if key not in self._keys: self._keys.append(key)

class OrderedDict(UserDict):
	def __init__(self, dict = None):
		self._keys = []
		UserDict.__init__(self, dict)

	def __delitem__(self, key):
		UserDict.__delitem__(self, key)
		self._keys.remove(key)

	def __setitem__(self, key, item):
		UserDict.__setitem__(self, key, item)
		if key not in self._keys: self._keys.append(key)

	def clear(self):
		UserDict.clear(self)
		self._keys = []

	def copy(self):
		dict = UserDict.copy(self)
		dict._keys = self._keys[:]
		return dict

	def items(self):
		return zip(self._keys, self.values())

	def keys(self):
		return self._keys

	def popitem(self):
		try:
			key = self._keys[-1]
		except IndexError:
			raise KeyError('dictionary is empty')

		val = self[key]
		del self[key]

		return (key, val)

	def setdefault(self, key, failobj = None):
		UserDict.setdefault(self, key, failobj)
		if key not in self._keys: self._keys.append(key)

	def update(self, dict):
		UserDict.update(self, dict)
		for key in dict.keys():
			if key not in self._keys: self._keys.append(key)

	def values(self):
		return map(self.get, self._keys)
# ============================================================================#

# #############################################################################
# Util functions Below
# #############################################################################

def column_from_csv_file(fname, headers=False, col=0):
	col=column(col)
	lines=parse_csv_file(fname, headers) 
	return list(itertools.zip_longest(*lines))[col]
	ret= list(itertools.zip_longest(*lines))[col]
	print(ret)
	return ret
		
def parse_csv_file(fname, headers=False):
	try:
		handle = open(os.path.abspath(fname),'r')
	except PermissionError as e:
		raise PermissionError(e)
	except (IOError, OSError) as e:
		raise FileNotFound('CSV File not found: %s' % fname)
	else:
		lines = handle.readlines(-1)
		records=[parse(l) for l in lines if parse(l) is not None and len(parse(l))]
		if headers and records:
			del records[0]
		# I think we can just call del records[0] if headers but I want to test
		# this out a little first

	return records

def get_calling_file():
	""" Needs error checking """
	try:
		1/0
	except ZeroDivisionError:
		t = sys.exc_info()[2]
		return t.tb_frame.f_back.f_back.f_globals['__file__']
	return None

def calling_module():
	import inspect
	i=0
	while i < 10:
		try:
			frame,filename,line_number,function_name,lines,index=\
				inspect.getouterframes(inspect.currentframe())[i]
			if (filename != __file__):
				a=0
				b=0
				max_a=max_b=10
				while a < max_a: 
					try:
						frm = inspect.stack()[a]
					except IndexError as e:
						max_a = a
					mod = inspect.getmodule(frm[b])
					if mod.__file__ != __file__:
						return mod
					a+=1
					if a == max_a:
						a=0
						b+=1
					if b == max_b:
						break
		except IndexError as e:
			break
		i+=1
	return None

def getVersion(mod=None):
		if not mod: mod=calling_module()
		try:
				return mod.__version__
		except AttributeError as e:
				#print >> sys.stderr, "Version not found."
				sys.stderr.write("Version not found.\n")
		return 0.1

def optional_arg(arg_default,choices=[]):
	if choices and arg_default not in choices:
		raise IdiotError("Your arg_default was not in your supplied list of choices.")
	def func(option,opt_str,value,parser):
		if value:
			val=value
		else:
			if parser.rargs and not parser.rargs[0].startswith('-'):
				val=parser.rargs[0]
				parser.rargs.pop(0)
			else:
				val=arg_default
		if choices and val not in choices:
			parser.print_usage()
			buf = []
			metavar = option.metavar or "[%s]" % str(option.dest).upper()
			if option._short_opts:
				buf.append("%s %s" % (option._short_opts[0], metavar) )
			if option._long_opts:
				buf.append("%s=%s" % (option._long_opts[0], metavar) )
			buf=', '.join(buf)

#-A [ACTION], --action=[ACTION]
			print("\n%s\n\t %s\n" % (buf,option.help))
			print("%s - ERROR: option %s: invalid choice: '%s' (choose from %s)" % (os.path.basename(sys.argv[0]),opt_str,val,','.join(["'%s'" % choice for choice in choices])))
			sys.exit(0)
			#x = ArgumentError(None,opt_str,val,choices)
			#raise x
# cryptwatch: error: option -a: invalid choice: 'foo' (choose from 'start', 'stop', 'restart', 'status')
		if not str(val).strip():
			val = '_empty_val_trick_'
		setattr(parser.values,option.dest,val)
	return func

def getInput(question, helptext='No help for this command',example_or_hint=None,default=None,required=False):
	"""
	Full Name - press Enter for default: root
	if helptext:
		if required:
			Full Name [i.e. John Smith (required)]:
		else:
			Full Name [i.e. John Smith (or leave blank)]:
	else:
		if required:
			Full Name (required):
		else:
			Full Name:
	"""

	if helptext == 'No help for this command' or not helptext.strip():
		h=''
	else:
		h = '/?'

	if example_or_hint:
		if required:
			txt = '%s %s%s ' % (question,example_or_hint,h)
		else:
			txt = '%s %s (or leave blank)%s ' % (question,example_or_hint,h)
	else:
		if default and required and not example_or_hint:
			example_or_hint='(default "%s")' % default
		txt = '%s %s%s ' % (question,example_or_hint,h)

	try:
		res = input("%s>>> " % (txt))
	except (KeyboardInterrupt,EOFError) as e:
		print("\nInvalid input, press 'q' to quit or 'h' for help.")
		return getInput(question,helptext,example_or_hint,default,required)

	if not res.strip() and required:
		if default:
			__option_always__ = [False]
			if getInputYN('Use default: %s?' % (default),
					'This will set the %s to the system default of "%s"' % (question,default),
					__input_options__,[]):
				return default
			else:
				if not example_or_hint: 
					example_or_hint='(default "%s")' % default
				return getInput(question,helptext,example_or_hint,default,required)

		else:
			print("\n")
			print('Nothing entered "%s" is required, please try again.' % question)
			print("\n")
			if not example_or_hint:
				example_or_hint='(default "%s")' % default
			return getInput(question,helptext,example_or_hint,default,required)

	if res.strip().lower() in ['h','?']:
		print("\nHELP (q to quit)" )
		print("\n\t? or "+'"h"'+" for this help")
		print("\ty for Yes")
		print("\tn for No")
		if helptext:
			if required:
				r="\t\tREQUIRED -\n "
			else:
				r=''
			print("\n%s" % fixWidth("%s%s"%(r,helptext)))
		return getInput(question,helptext,example_or_hint,default,required)
	if res.strip().lower() == 'q':
		raise QuitNow(question)
	else:
		return res


def getInputYN(question, helptext='No help for this command',input_options=__input_options__,option_always=__option_always__):

	if len(option_always):
		if option_always[0]:
			return True
		if 'a' not in input_options:
			input_options.append('a')

	if helptext == 'No help for this command' or not helptext.strip():
		pass
	elif '?' not in input_options:
		input_options.append('?')
	options = '/'.join(input_options)

	try:
		res = input("%s [%s]>>> " % (question,options))
	except (KeyboardInterrupt,EOFError) as e:
		print("\nInvalid input, press 'q' to quit or 'h' for help.")
		if 'q' in input_options:
			if 'h' not in input_options:
				input_options.append('h')
		if 'q' not in input_options:
			input_options.append('q')
		return getInputYN(question,helptext,input_options,option_always)

	if not res.strip():
		print( "Nothing entered, please try again.")
		return getInputYN(question, helptext,input_options,option_always)
	if len(option_always) and res.strip().lower() == 'a':
		option_always[0] = True
		return True
	if res.strip().lower() == 'y':
		return True
	if res.strip().lower() == 'n':
		return False
	if res.strip().lower() in ['h','?']:
		print( "\n\t? or h for this help" )
		print( "\ty for Yes")
		print( "\tn for No")
		if len(option_always):
			print('\ta for always (skipping prompt from now on, always assuming yes.)')
		print ("\nHELP (q to quit): \n%s\n" % wrap(helptext))
		return getInputYN(question, helptext,input_options,option_always)
	if res.strip().lower() == 'q':
		raise QuitNow #, question
	else:
		print ("Invalid input, please try again.")
		return getInputYN(question, helptext,input_options,option_always)

def to80(s): return fixWidth(s)

def wrap(text, width=79):
	"""
	A word-wrap function that preserves existing line breaks
	and most spaces in the text. Expects that existing line
	breaks are posix newlines (\n).
	"""
	return functools.reduce(lambda line, word, width=width: '%s%s%s' % (line,
	' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0]) >= width)],
	word), text.split(' '))

def fixWidth(st):
	buf = list(st.split(" "))
	lines = []
	cur = ''
	for word in buf:
		if word=="\n":
			lines.append(cur)
			cur = ''
		elif len('%s %s' % (cur, word)) >= 79:
			lines.append(cur)
			cur = ''
		if cur:
			cur = "%s %s" % (cur,word)
		else:
			cur = word
	if cur:
		lines.append(cur)
	return "\n".join(lines)

def version(v):
	print("%s version: %s" % (os.path.basename(sys.argv[0]), v))

def set_logging(opts, name, quiet=False, __logdir__=__logdir__):
	global log
	if opts.debug:
		level=logging.DEBUG
		log_file = '%s.log' % name
	else: 
		level=logging.INFO
		log_file = 'pytis_tools.log'
	logging.basicConfig(
		filename = os.path.abspath(os.path.join(os.path.abspath(__logdir__), log_file )),
		level=level,
		format='%(asctime)s %(name)-10s %(levelname)-8s %(message)s',
		datefmt="%m.%d.%Y %H:%M:%S")
	logging.setLoggerClass(MyLogger)
	log = logging.getLogger(name)
	log.setopts(opts)

	try:
		version = opts.version
	except AttributeError as e:
		version = False
	if not quiet and version != True:
		log.info("Starting %s at %s" % (name,prettyNow())) 

	try:
		totally_verbose = opts.totally_verbose
	except AttributeError as e:
		totally_verbose = True
	
	if not totally_verbose:
		buf = StringIO()
		sys.stdout = buf

	log.debug('-'*80) 
	# I want the output alphabatized, so I am going to create a list of tuples,
	# sort them, no wait, you know what would be faster? to just grab the keys,
	# sort those, request each value by key.
	opt_keys = list(opts.__dict__.keys())
	opt_keys.sort()
	for opt in opt_keys:
		value = opts.__dict__[opt]
	#for opt, value in opts.__dict__.items():
		if type(value) == type(str('')):
			if value.strip() == '_empty_val_trick_':
				value = ''
		if str(opt).lower() in ('cloud_checker_access_key',
			'password',
			'pass',
			'sr_secret_access_key',
			'secret_access_key',
			'db_password'):
			value = protect(value)

		log.debug("OPTION %s: %s" % (opt,value))
	log.debug('-'*80) 

	if not totally_verbose:
		sys.stdout = sys.__stdout__
		del buf
	return log

def homedir():
	""" Get Home directory path in Python for Windows and Linux
	"""
	#homedir = os.path.expanduser('~')
	# ...works on at least windows and linux. 
	# In windows it points to the user's folder 
	#	(the one directly under Documents and Settings, not My Documents)
	# In windows, you can choose to care about local versus roaming profiles.
	# You can fetch the current user's through PyWin32.
	#
	# For example, to ask for the roaming 'Application Data' directory:
	#	(CSIDL_APPDATA asks for the roaming, CSIDL_LOCAL_APPDATA for the local one)
	#	(See microsoft references for further CSIDL constants)
	try:
		from win32com.shell import shellcon, shell
		homedir = shell.SHGetFolderPath(0, shellcon.CSIDL_APPDATA, 0, 0)
	except ImportError: # quick semi-nasty fallback for non-windows/win32com case
		homedir = os.path.expanduser("~")
	return homedir

def timestamp(full=False):
	if full: return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f") 
	else: return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") 

def fileModified(path):
	return time.strftime("%Y-%m-%d %H:%M:%S.%s",
	time.localtime(os.path.getmtime(path)))
	
def fileCreated(path):
	return time.strftime("%Y-%m-%d %H:%M:%S.%s", 
	 time.localtime(os.path.getctime(path)))
	
def prettyNow():
	return datetime.datetime.now().strftime("%I:%M%%s %m %b, %Y") % datetime.datetime.now().strftime("%p").lower()

def fileStampNow():
		return datetime.datetime.now().strftime("%Y%m%d_%H%M")

def testFind(path):
	"""
	"""
	f=[]
	for root, dirs, files in os.walk(os.path.abspath(path), topdown=False):
		for name in dirs:
			fpath = os.path.abspath(os.path.join(root,name))
			for fname in glob.glob(os.path.join(fpath, '*.png')):
				f.append(fname)
	pprint(f)
	return f

def filesFromArgs(opts, args):
	""" 
	XXX:TODO unix only, need to make this so it would work on windows.
	XXX:TODO this thing needs sserious work, with recursive an no . in filenames
	import glob
	"""
	if opts.recursive:
		re = ''
	else:
		re = '-maxdepth 1'
	cd=os.curdir
	files = []
	cmd=None
	for arg in args:
		'''
		if arg.startswith('"') and arg.endswith('"'):
			arg=arg.strip('"')
		if arg.startswith("'") and arg.endswith("'"):
			arg=arg.strip("'")
		'''

		if os.path.isfile(arg) and os.path.exists(arg):
			files.append(arg)
		elif ('/' in arg or '\\' in arg):
			if (os.path.isfile(os.path.abspath(os.path.join(cd,arg))) and os.path.exists(os.path.abspath(os.path.join(cd,arg)))):
				files.append(os.path.abspath(os.path.join(cd,arg)))
				return files
			elif(os.path.isdir(os.path.abspath(os.path.join(cd,arg))) and os.path.exists(os.path.abspath(os.path.join(cd,arg)))):
				if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
					arg = "'%s'" % arg
				cmd = "find %s %s" % (re,os.path.abspath(arg))
			else:
				if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
					arg = "'%s'" % arg
				cmd = "find %s %s" % (re,arg)
		elif arg == '.':
			if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
				arg = "'%s'" % arg
			cmd = "find . * %s" % re
		else:
			if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
				arg = "'%s'" % arg
			cmd = "find . %s -type f -iname %s | egrep -v '.svn|.git'" % (re,arg)

		if cmd:
			log.debug("CMD IS: %s" % cmd)
			cmd_out = os.popen(cmd).readlines(-1)
			for line in cmd_out:
				line = line.strip()
				if line and os.path.abspath(line) not in files \
					and os.path.isfile(line) and os.path.exists(line):
					files.append(os.path.abspath(line))
		cmd=None
	return files

def fileTest(f):
	# ensure it is a valid real existing file 
	if not f.strip(): return False
	f = os.path.abspath(f)
	if not os.path.exists(f) or not os.path.file(f): return False
	return True

def dirTest(d):
	# ensure it is a valid real existing directory 
	if not d.strip(): return False
	d = os.path.abspath(d)
	if not os.path.exists(d) or not os.path.isdir(d): return False
	return True

def toContinue():
	""" Prompt the user to press a key to continue. Should probably use a pager
	most of the time though.
	"""
	if sys.platform in ('win32', 'win64'):
		os.system('PAUSE')
		sys.stdout.write("\n")
	elif sys.stdin.isatty():
		import tty
		sys.stdout.write("Press any key to continue . . .\n")
		tty.setraw(sys.stdin.fileno())
		try:
			sys.stdin.read(1)
		finally:
			os.system("stty sane")
		sys.stdout.write("\n")
	return

def dos2unix(thing):
	"""
		This will take in 3 types of input, 
		a list of strings
		a string
		or the path to a file to fix.

		If your input is a file path, it will clean up the file (dos2unix)
		
		If your input is a string, it will clean the string and return the cleaned
		input.

		If your input is a list, it will clean each line, and return a new list.
	"""
	if type(thing) is type('') and os.path.isfile(thing) and \
	os.path.exists(thing):
		try:
			handle = open(thing,'r')
			contents = handle.read(-1)
			handle.close()
			nhandle = open(thing,'wb')
			nhandle.write(contents.replace("\r$","").replace("\r",''))
			nhandle.close()
		except Exception as e:
			sys.stderr.write("thing is fpath in dos2unix error here.\n")
			raise e

	if type(thing) is type(''):
		try:
			return thing.replace("\r\n","\n")
		except Exception as e:
			sys.stderr.write("thing is string in dos2unix error here.\n")
			raise e

	if type(thing) is type([]):
		try:
			lines = []
			for line in thing:
				lines.append(line.replace("\r\n","\n"))
			return lines 
		except Exception as e:
			sys.stderr.write("thing is list in dos2unix error here.\n")
			raise e

	raise ProgrammerError("This function (PyTis.dos2unix) requires list " \
		"or string or file path as input but a %s was passed in." % \
		repr(type(thing)))

def clearScreen():
	sys.stdout.write("\n")
	if sys.platform in ('win32', 'win64'):
		os.system('cls')
	elif sys.stdin.isatty():
		os.system('clear')
	return

def hello():
	import inspect
	i=0
	while i < 10:
		try:
			#print 'i',i
			frame,filename,line_number,function_name,lines,index=\
				inspect.getouterframes(inspect.currentframe())[i]
			print( 'frame', frame)
			print( 'filename', filename)
			print( 'line_number',line_number)
			print( 'function_name',function_name)
			print( 'lines',lines)
			print( 'index',index)
			print( 'basename of filename', os.path.basename(filename))
			print( '__file__', __file__)
			if (filename != __file__):
				a=0
				b=0
				max_a = 5
				while a < max_a: 
					try:
						frm = inspect.stack()[a]
					except IndexError as e:
						max_a = a

					print(dir(frm))

					mod = inspect.getmodule(frm[b])
					if '__FINDME__' in dir(mod):
						print( '='*80)
						print( sys.argv[0])
						print( 'FOUND IT')
						print( 'filename', filename)
						print( 'i', i)
						print( 'a', a)
						print( 'b', b)
						print( 'FINDME = ', mod.__FINDME__)
						print( mod)
						print( dir(mod))
						print( 'VERSION vvv')
						print( mod.__version__)
						print( 'VERSION ^^^')
						print( '='*80)
						return mod
					print( mod)
					print( dir(mod))
					a+=1
					if a == max_a:
						a=0
						b+=1
					if b == 5:
						break

			print( '*'*80)
		except IndexError as e:
			break
		i+=1

def traceCaller():
		i=0
		while i < 10:
				try:
						frame,filename,line_number,function_name,lines,index=\
								inspect.getouterframes(inspect.currentframe())[i]
						if (filename != __file__):
								a=0
								b=0
								max_a=max_b=10
								while a < max_a: 
										try:
												frm = inspect.stack()[a]
										except IndexError as e:
												max_a = a
										mod = inspect.getmodule(frm[b])
										if mod.__file__ != __file__:
												return mod
										a+=1
										if a == max_a:
												a=0
												b+=1
										if b == max_b:
												break
				except IndexError as e:
						break
				i+=1
		return None

def logging_file_descriptors():
	''' logging file descriptors are used in core.Service.daemonize() '''
	return [handler.stream.fileno() for handler in [wr() for wr in
			logging._handlerList] if isinstance(handler, logging.FileHandler)]

def unique(L):
	return list(set(L))

def microtime(dt=None):
	""" simple microtime function that can take in a datetime timestamp to ret
	the microtime for, returns the microtime right now. """
	dt = dt or datetime.datetime.now()
	return (dt - datetime.datetime.utcfromtimestamp(0)).total_seconds()

def tolen(instr, i=80):
	""" Reads the input string :instr: and reformatts to an specified length :
	"""
	lines = []; line = []
	for word in instr.split(' '):

		while len(word) >= 1 and word[0:2] in ("\\n","\n",'\n'):
			lines.append("\n")
			word = word[2:]

		if len('%s %s' % (' '.join(line), word)) > i:
			lines.append(' '.join(line))
			line = [word]
		else:
			if word.startswith('\n'):
				lines.append(' '.join(line))
				line = [word]
			else:
				line.append(word)
	if line:
		lines.append(' '.join(line))
	return '\n'.join(lines)

def mbool(val, default=True):
	if not val:
		return False
	val = str(val).strip()
	if not val:
		return False
	if val.upper() in ['NONE', 'FALSE', '0']:
		return False
	if val.upper() in ['TRUE', '1', 'YES']:
		return True
	return default

def identify_sections(cfile=COBJ, filename=None):
	if filename and filename.strip():
		if os.path.exists(filename):
			cfile = COBJ.load(filename)
		else:
			raise FileNotFound("The config file does not exist, no sections will be able to be found in a non-existant file.")
	sections=[]
	for k,v in cfile.items():
		if str(type(v)) == "<class 'pylib.configobj.Section'>":
			sections.append((k,v))
	return sections

def get_section(sections, section_key):
	for section, sub in sections:
		if section == section_key:
			return sub
	return None

def relative_date(date=datetime.datetime.now(),years=None,months=None,weeks=None,days=None,hours=None,minutes=None):
	if hours or minutes:
		raise FutureFeature("Not coded yet.")
	if years or years==0:
		year = date.year+years
		return datetime.date(year,date.month,day)
	elif months or months==0:
		acceptable_date = datetime.datetime(date.year,date.month,1)
		#while int(months) <> 0:
		while int(months) != 0:
			acceptable_date = acceptable_date-datetime.timedelta(days=20)
			acceptable_date = datetime.datetime(acceptable_date.year,acceptable_date.month,1)
			if months < 0: months=months+1
			else: months=months-1
		return date.replace(year=acceptable_date.year,month=acceptable_date.month,day=date.day)
	elif weeks or weeks==0:
		return date+datetime.timedelta(days=7*weeks)
	elif days or days == 0:
		if days > 0: # positive number of days
			return date+datetime.timedelta(days=days)
		else: # negative number of days
			# oops, wound up with a double negative, passing a negative date in, and
			# subtracting it.	Need to add here too. I could just leave this as a
			# one-liner without the above IF/ELSE but for clarity on what is going
			# on, or for copy/pasting into the other switch cases, I am going to
			# leave it (for now).
			return date+datetime.timedelta(days=days)
		pass
	elif hours:
		pass
	elif minutes:
		pass
	else:
		pass
	raise ProgrammingError("PyTis.relative_date() -- You must specify one of the following: years,months,weeks,days,hours or minutes.")

def trim(item):
	"""
	"""
	if type(item) == type(str('')):
		if item: item=item.strip()
		else: item = ''
	elif type(item) == type([]):
		return [f.strip() for f in item]
	elif type(item) == type(dict()):
		newdict = {}
		for k,v in item.items():
			newdict[k]=trim(v)
		return newdict
	else:
		if not item:
			item = ''
	return item

def die(string=None):
	global log
	if log and string:
		log.error(string)
	elif string:
		print(string)
	sys.exit()

def protect(s,trim_len=4):
	""" padd a password and only show the remaining "trim_len" 
	example: protect('this now', 2) >> '******ow'
	example: protect('my password', 0) >> '**********'
	"""
	global log
	if len(s) == 0:
		return "''"
		#return '*'*8
	elif trim_len >= len(s):
		log.warn("Programming error in PyTis.protect; trim len passed is " \
			"actually longer than string passed.")
		return '*'*len(s)
	else:
		return '%s%s'%('*'*(len(s)-trim_len),s[(len(s)-trim_len):])

col2num = lambda col: functools.reduce(lambda x, y: x*26 + y, [ord(c.upper()) - ord('A') + 1 for c in col])
#col2num = lambda colo: sum(pow(26, i) * ord(c) - 64) for i, c in enumerate(reversed(col.upper()))

def column(str_or_int):
	try:
		r = int(str_or_int)
	except ValueError:
		r = col2num(str_or_int)-1
	finally:
		return r

def simpleDecode(s=''):
	bencoded_txt = s.strip().encode('ascii')
	bdecoded_txt = b64.b64decode(bencoded_txt)
	return bdecoded_txt.decode('ascii')

def simpleEncode(s=''):
	bencoded_txt = s.strip().encode('ascii')
	return (b64.b64encode(bencoded_txt).decode('ascii'))

ireplace=lambda f,r,s: re.sub(r'(?i)%s'%str(f),str(r),str(s))

def sendEmail(body, subject, to, mfrom, cc, host=None, local_hostname=None,
	port=25, timeout=20):
	global log

	from email.mime.text import MIMEText
	import smtplib
	import socket

	msg=MIMEText(body)
	msg['Subject'] = subject

	if type(to) is type([]) or type(to) is type(()):
		to=';'.join(to)
	else:
		to=';'.join(to.split(','))

	msg['To'] = to 

	msg['From'] = mfrom

	if cc: msg['CC'] = cc

	if local_hostname is None: local_hostname = os.uname()[1]

	if host is None:
		host_attempts = ['localhost','127.0.0.1']
	elif host.lower() == 'localhost':
		host_attempts = ['localhost','127.0.0.1']
	else:
		host_attempts = [host]

	for host in host_attempts:
		log.debug("smtplib.SMTP(host='%s',port=%s," \
			"local_hostname='%s',timeout=%s) - %s" % (host,port,
			local_hostname, str(int(timeout)), subject))
		try:
			s = smtplib.SMTP(host=host,port=port,
				local_hostname=local_hostname,timeout=timeout)
			s.sendmail(msg['From'],msg['To'],msg.as_string())
			s.quit()

			log.debug('smtplib Instantiated with no errors - %s' % subject)

		except socket.error as e:
			log.debug('socket.error caught, continuing: %s - %s' % (str(e), subject))
			return False
		else:
			log.debug('To: %s, CC: %s, FROM: %s; s.sendmail successfull - %s' % \
				(msg['To'], msg['CC'], msg['From'], subject))
			return True
	else:
		log.error("Incorrect mail host and/or local_hostname " \
		"provided, sendmail failed - %s " % subject)
		return False


def main(): #global __version__
	print("PyTis toolkit library, version: %s" % str(__version__))

if __name__ == '__main__': sys.exit(main())



