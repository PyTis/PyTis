#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 2.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2019 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 11:55 PM - 06 Feb, 2019       #
############################################################################## #
"""benchmark
=========

NAME:
  benchmark

SYNOPSIS:
  benchmark [--options] [-H] [-v] [-D]

DESCRIPTION:

  Three failed attemps, wait 1 minute.

  If the user is not already root, then...
  3 blank entries, switch username to root, to allow an administrator to walk
  over and unlock the screen for an idiot who forgot their password.
  IF there are 3 blank root entries, perhaps the idiot hit enter 3 times by
  accident, 3 blank entries switches back to normal user.
  Additionally, CTRL+C (KeyboardInterrupt) also will switch back to normal
  user.

-------------------------------------------------------------------------------

SEMANTICS:
  Flag vs. Argument:
    Flag - an option that accepts no input.
    Argument - an option that requires input.

CODE:
	...

UNDERSTANDING LOGGING and OUTPUT:

 The way my PyTis scripts and programs work, I hardly ever use the print
 command.  Instead I just log something using a custom logging class.  I have
 four log levels: debug, info, warn and error. Messages may or may not make it
 to the screen (as my logging class will print output as it logs) depending on
 which arguments you pass into the program you are executing.

 The current setup allows for 2 log files, to be written to the PyTis
 configured log directory.  If you do not use debug, then the log file used
 will be the pytis_tools.log, if debugging is turned on, then the log file will
 be {program_name}.log found in the same directory.  In this program's case
 that would be pybkup.log  So if you use -D the output ends up in a different
 log file, but this is just to keep debugging separate from normal logging.  v-
 --verbose is off by default by with this program, unless you use the action
 'test' then it is on (unless you specify --quiet, then it stays off).


 debug:
  Not to log-file or to screen by default, but if turned on with the -D or
    --debug flag, it will always end up in the debug log file (pybkup.log).

  -D: print debug messages to log only

  -v: alone does not print debug messages anywhere, because -D or --debug not
    given

  -DV: now debug messages are sent to their log file, and make it to the screen

 info:
  Print normal level information, always written to log (although which log is
    being used depends on if you are using debugging, as stated above).

  -v allows info messages to print to STDOUT, thus to the screen for you to
    see.

  -q or --quiet turns off -v


 warn:
  Warnings will always make it to which ever log is being used, and it will
    always make it to the screen unless -q is passed in.  If -q is passed in
    then warnings are hidden from STDOUT, thus only show in log files.

  -q suppresses warnings to STDOUT (the screen) but they will still end up in
    whichever log this program is using.

 error:
  error messages always make it to the screen, no matter what; and are always
    logged to the log file as well.

 Notes:
  To ensure there is no confusion, I want to specify that the log file is
    chosen one time during the first stages of the program firing up, it does
    not switch back and forth while running, nothing complex like that.  Simply
    this, all of my programs share pytis_tools.log unless they are in debug
    mode.  Then, since they are obviously going to spit out allot more
    information, they write to their very own log file for that run.  That way
    they don't fill up and clutter the shared pytis_tools.log

  '-DVq' confuses my little logging class.  -q silences most messages, nothing
    but errors make it to the screen, -D was passed in so the debug log is used
    (pybkup.log) however logging level is set to verbose, with nothing to the
    screen so what ends up happening is only info messages make it to the debug
    log (debug messages hidden).

DEPENDENCIES:

-------------------------------------------------------------------------------

"""

default_times_to_run = 1

# ############################ DO NOT EDIT BELOW ############################ #
errors = []
default_frequency = 1
# default_frequency always equals zero.  Get it?  default_frequency -> this
# should always = 0, only changed to debug PyTis Library, DO NOT EDIT THIS
# (unless your name is Josh Lee)!!!

# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
import optparse
import getpass
import subprocess
import time
import os
import atexit
from random import randint as rand
import pam
import sys
import logging


# This program needs to import PyTis(2) v4.1, which imports modules from the
# sub-package pylib, this program also needs to import from the sub-package
# cobj, pylib.cobj itself, has to import from the parent, pytis, which it
# can only do if the parent directory is a package, turning the parent (bin)
# into a package breaks importing pytis for this program in the first place
# and caused severe circular import errors.	To fix this, we have to adjust the
# path.
# vvvvv XXX-TODO may not need this here, dunno, remove at end and try it. vvvvv
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__),'..')))
# ^^^^^ XXX-TODO may not need this here, dunno, remove at end and try it. ^^^^^

#
# Internal
#
try:
	import pytis as PyTis # Shared GPL/PPL License
	from pylib.util.functional import any as fany
except ImportError as e:
	# We cannot go any further than this, we can't use the Parser or Logging tool
	# to display these errors because those very tools are loaded from PyTis.
	# Therefore, display errors now and exit with an errored exit code.
	print("This program requires the PyTis Python library to run.")
	print("You may download the PyTis library, or do an SVN checkout from:")
	print("<https://sourceforge.net/projects/pytis/>")
	print("This program should be installed in the bin directory of the PyTis " \
		"library.")
	print(str(e))
	sys.exit(1)

#
# Third-Party
#

# -----------------------------------------------------------------------------
# End Imports
# =============================================================================
# =============================================================================
# Begin VARIABLE DEFINITIONS
# -----------------------------------------------------------------------------

__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee'
__created__ = '11:55 PM - 06 Feb, 2019'
__copyright__ = 'PyTis'
__version__ = '0.1'

# XXX::TODO::GET`ER DONE!
# __version__ = 0.1 --> creation
# __version__ = 0.2 --> it works
# __version__ = 0.3 --> clean it up
# __version__ = 0.4 --> document what has been cleaned up
# __version__ = 0.5 --> document everything else
# __version__ = 0.6 --> test everything we can, try to break it with bad input
# __version__ = 0.7 --> apply bug fixes
# __version__ = 0.8 --> document bug fixes, apply spell checking and cleanup to
#												documentation.
# __version__ = 0.9 --> run importnanny, and ensure it is properly copyrighted! 
# __version__ = 0.9? -> ready for release, just needs packaged up 
# this is where confusion sets in, I still need to finish / complete jhelp, and
# learn how to auto-build man-pages from the --help options
# __version__ = 1.0 --> release with setup.py / installation files.

# -----------------------------------------------------------------------------
# End VARIABLE DEFINITIONS
# =============================================================================
# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------

def is_root():
	return bool(getpass.getuser()=='root')

def pidfile():
	""" :-/  hmm,... what if a user runs this as a service (backgrounded),... 
	and, um, is benchmarkign script 'A', then also wants to run a backgrounded
	benchmarking script 'B' at the same time?  We may want to have slightly
	unique PID file names (which could be very dangerous, if done incorrectly).
	"""
	# XXX:TODO, read above docstring
	return os.path.splitext(os.path.basename(__file__))[0]

def pid_filename():
	""" In keeping with the naming convention of the PyTis.Pidfile properties, 
	the "filename" includes the extension, whereas the above "pidfile" function,
	would be the path, without the extension.
	"""
	return "%s.pid" % pidfile()

def pidpath():
	""" maybe not... """
	pass

"""

	if os.name in ('posix'):
		rundir = '/run/'
	elif os.name in ('mac', 'os2', 'ce', 'riscos'):
		rundir = '/var/run/'
	elif os.name == 'nt':
		if self.caller is not None:
			rundir = os.path.join(os.path.dirname(self.caller.__file__), 
			'run/')
		else:
			rundir = os.path.join(os.path.dirname(__file__), 'run/')
	else:
		rundir = os.getcwd()

	try:
		from win32com.shell import shellcon, shell
		homedir = shell.SHGetFolderPath(0, shellcon.CSIDL_APPDATA, 0, 0)
	except ImportError: # quick semi-nasty fallback for non-windows/win32com case
		homedir = os.path.expanduser("~")
	return homedir

print(pid_filename())
print("Is root?: %s" % str(bool(is_root())))
sys.exit(1)
"""

# -----------------------------------------------------------------------------
# End HELPER Functions
# =============================================================================
# =============================================================================
# Begin MAIN PROGRAM FUNCTIONS
# -----------------------------------------------------------------------------


def run(opts):
	""" You don't only have to specify a callable program with a shebang line. 

EXAMPLE of benchmarking a program WITH a shebang line:
  benchmark --times=10 ./my-program <optional arguments for my-program>

EXAMPLE of benchmarking a program WITHOUT a shebang line:
  benchmark --times=10 ./my_program.py --some-arg=foobar

Yes, because the file has a python extension, it will look at the first line
of the program for you, and if it does not contain a shebang line OR if you
have not yet, or have forgotten to give it a executable bit (chmod 0755),
this program will automatcially prefix it with the python executable,
determined by the file extension.  Thus, the line executed would be
translated --

FROM:
  benchmark --times=10 ./my_program.py --some-arg=foobar

TO:
  benchmark --times=10 /usr/bin/env python my_program.py --some-arg=foobar

Additionally, this may be the run function, but please remember, this file
does not need to be called directly.  If you wish, you may import this
benchmark.py file, and use the benchmark functions/classes.

	"""
	global log
	log.info('Outer RUN ran')
	log.critical("FIND ME, I AM THE RUNNING PROGRAM!")
# -----------------------------------------------------------------------------
# End MAIN PROGRAM FUNCTIONS
# =============================================================================
# =============================================================================
# Begin MAIN 
# -----------------------------------------------------------------------------

class SingleThread(PyTis.MyThread):

	"""
	def buildNice(self):
		return ['nice', '-n%s' % self.default_niceness]

	def buildIoNice(self):
		return ['ionice', '-c%s' % self.default_ioniceness_class, '-n%s' % self.default_ioniceness]
		
	"""

	def run(self):
		"""
			Extra help goes here...
		"""
		self.log.info("Method run ran")
		self.log.critical("FIND ME, I AM THE RUNNING PROGRAM!")

		"""


		# Call function to generate the NMAP targets list
		argv=[]
		[argv.extend(arg.split()) for arg in sys.argv]
		
		#cmd_list = self.buildIoNice()
		#cmd_list.extend(self.buildNice())
		cmd_list=[]
		cmd_list.extend(argv)

		#print(repr(cmd_list))
		#print(repr(cmd_list))
		self.log.info(repr(cmd_list))
		subprocess.call(cmd_list)

		"""

# =============================================================================
# End MAIN PROGRAM FUNCTION
# -----------------------------------------------------------------------------

# =============================================================================
# Begin MAIN 
# -----------------------------------------------------------------------------



def main2(times_to_run = 3):
	global verbose
	verbose = False 


	
	return
	# I don't want to use an option parser, as I feel it would complicate things,
	# it is unnessecary, for one.  For two, I think it would through errors, IF
	# you were trying to pass additional options in to the secondary program.
	# shit, doesn't time do this already?
	# No, I just checkd, it will time a process once, but not run it multiple
	# times, and then display the average.
	#if '-v' or '-V' or '--verbose' or '--VERBOSE' in sys.argv:
	#	verbose = True

	if len(sys.argv) > 1:
		try:
			ttr = int(sys.argv[1])
		except ValueError as e:
			print("ERROR: You may input an integer only, for times to run!")
			return 1
			# ttr = times_to_run

		else:
			if ttr < 1:
				print("ERROR: You must run the benchmark at least once, thus the " \
					"lowest number you can choose is 1.")
				return 1

			if ttr > 100:
				print("STRONG WARNING! You have chosen a VERY large number, this " \
					"may take too long to run.  You may press CTRL+C to exit if this " \
					"takes too long.")

			if ttr > 500:
				print("ERROR!!! You cannot run the benchmark this many times, it " \
					"would likely take weeks to run.")
				return 1

	else:
		ttr = times_to_run # the default, 

	return benchmark_these_with_times(ttr)

def main():
	"""usage: %prog <options> {benchmarking program or script} <options> """

	global default_times_to_run, errors, log
	# first arg will be this program name.
	prog_path = os.path.basename(sys.argv[0]) 
	prog_name = os.path.splitext(os.path.basename(prog_path))[0] 

	parser = PyTis.MyParser()

	parser.extra_txt = "\n\n%s\n" % run.__doc__ + """

-------------------------------------------------------------------------------

SEE ALSO:

	dyndns
	powerdns-update

COPYRIGHT:

	%(copyright)s

AUTHOR:

	%(author)s

HISTORY:

	Original Author

CHANGE LOG:
	
	v1.Original Release

EXAMPLES:	

	benchmark ipecho

	benchmark 3

	benchmark

	benchmark --list

	benchmark -dv

	benchmark -v

	benchmark -vv

	benchmark -vvv


BUGS - KNOWN ISSUES:

	NONE (at tis time).

CREATED:

	%(created)s

VERSION:

	%(version)s

`EOF
"""  % dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	# ----------------------------
	parser.formatter.format_description = lambda s:s
	parser.set_usage(main.__doc__)

	if '--help' in sys.argv:
		parser.set_description(__doc__)

		action_help = "Another optional argument that does not require to be " \
			"prefixed (-a/--action) this can simply be typed out. `$`$" \
			"		i.e.: pers -DV -u start `$" \
			"This argument allows you to access the service features of this " \
			"program. Choices: <start, stop, restart, status>, when using the " \
			"[-b/--background] flag, this argument is not required, as the 'start'" \
			" action is automatically implied."

		background_help = "This could take hours to run, and you may wish to " \
			"run it in the background, checking back later to read the results " \
			"in an output report.	When you get a chance, if you want to know " \
			"if it is done running, you can simply type in 'benchmark status' to " \
			"see if it is still running (if you used the [-b/--bg/--background] " \
			"flag.`$" \
			"If this flag is used, the 'start' action is implied for the " \
			"[-a/--action] argument.`$"

		debug_help = "Enable debugging.	When debugging is enabled, this " \
			"program will utilize it's own log file ('pers.log') logging will " \
			"write to the ('pytis-tools.log') when this option is NOT enabled.	" \
			"When utilizing the [-D/--debug] flag, debug statements will " \
			"also print to the screen, unless you suppress them with the " \
			"[-q/--quiet] flag.`$"

		ttr_help = "How many times to run (default %s).`$"  % default_times_to_run

		verbose_help=optparse.SUPPRESS_HELP

	else:
		helpishere=False # to determine help mode (short or full)
		parser.set_description('')
		parser.setFullHelpAvaiable()

		action_help = "Access the service features of this program. `$" \
			"Choices: <start, stop, restart, status>`$" \
			'*(use "--help" for more details)`$'

		background_help = "Run this process in the Background. `$" \
			'`$*(use "--help" for more details)`$'

		debug_help = "Enable debugging`$" \
			'`$*(use "--help" for more details)`$'

		ttr_help = "How many times to run (default %s).`$"  % default_times_to_run

		verbose_help="Be more Verbose (make lots of noise).  Off by default, " \
					 "unless in dry-run.`$"
  # ------------------------------------------------------------------------ |
	# -------------------------------------------------------------------------

  # ------------------------------------------------------------------------ |
	# runtime variable setting
  # ------------------------------------------------------------------------ |
	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")
	# ----------------------------

	runtime.add_option("-a", "--action", type="choice", action='store',
		default=None, dest='action', choices=('start','stop','restart','status'),
		metavar='[ACTION]',
		help=action_help)

	runtime.add_option("", "--bg", action="store_true",
		default=False, dest='background',
		help='')
	runtime.add_option("-b", "--background", action="store_true",
		default=False, dest='background',
		help=background_help)

	runtime.add_option("", "--times", type="int", action='store',
		default=default_times_to_run, dest='ttr',
		help='')
	runtime.add_option("-t", "--times-to-run", type="int", action='store',
		default=default_times_to_run, dest='ttr', metavar='[INT]',
		help=ttr_help)

	parser.add_option_group(runtime)
  # ------------------------------------------------------------------------ |
  # ------------------------------------------------------------------------ |
	# configuration variable setting
  # ------------------------------------------------------------------------ |
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")
	# ----------------------------
	# ----------------------------
	vars.add_option("-i", "--ionice", type="int", action='store',
		 default=PyTis.MyThread.default_ioniceness, 
		 dest='ioniceness',
		 metavar='[INT <0 to 7>]',
		 help="Niceness range from 0 " \
					"(most favorable scheduling) to 7 (least favorable).	Default 4.`$" \
					"for more information, please run: man ionice.`$")

	vars.add_option("-I", "--io-class", type="int", action='store',
		default=PyTis.MyThread.default_ioniceness_class, 
		dest='ioniceness_class',
		metavar='[INT <0-3>]',
		help="The scheduling class. 0 for none, 1 for real time, 2 for " \
			"best-effort, 3 for idle. Default: 2`$")

	# ----------------------------

	vars.add_option("-N", "--nice", type="int", action='store',
		 default=PyTis.MyThread.default_niceness, 
		 dest='niceness', 
		 metavar='[INT <-20 to 19>]',
		 help="Niceness range from -20 (most favorable scheduling) to 19 " \
		 "(least favorable).	Default 10.`$" \
		 "for more information, please run: man nice.`$")
	# ----------------------------
	# ----------------------------

	vars.add_option("", "--frequency__", type="int", action='store', 
		default=default_frequency, dest='frequency', metavar='[INT]',
		help=optparse.SUPPRESS_HELP)
		# help="This needs to only run once, even if running in the background.
		# Threfore the frequency will be 0, and the user SHOULD NOT SPECIFY any
		# different!`$")

	parser.add_option_group(vars)


  # ------------------------------------------------------------------------ |
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging`$")


	# This is a little trick to tell if the user entered the -v/--verbose flag.
	# We want verbosity on by default, but we also want to know if the user
	# entered it for debug items, and providing end messages vs informed output.
	dbgroup.add_option("", "--totaly-verbose", action="store_true",
		default=False, dest='totally_verbose', 
		help=optparse.SUPPRESS_HELP)

	dbgroup.add_option('-v', '--verbose', action='count', default=0,
		dest='verbose', help=verbose_help)

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits).  On by default, " \
					 "unless in dry-run.`$")

	dbgroup.add_option("-V", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------
	# OptParser OPTIONS ABOVE
	# ##################################################################### #
	# ##################################################################### #
	# ##################################################################### #
	# Unique to this program, we do not (cannot) use the standard sys.argv, #
	# instead, we have to break sys.argv into two separate parts, one for   #
	# this program (benchmark.py/benchmark) and one for which ever child    #
	# program will be called by this program.                               #
	# Side note, I hate having this code here, and hope to move it to its   #
	# own function, if not just for readability, to get this program more   #
	# inline with other PyTis programs.                                     #
	# ##################################################################### #

	wts = None # where_to_split = wts
	for i, arg in enumerate(sys.argv):
		if i > 0:
			if os.path.isfile(arg): 
				wts=i
			elif not arg.startswith('-') and \
			arg.lower() not in ('start','stop','restart','status'):
				x=os.popen("which '%s'" % arg)
				if x.read() and not x.close():
					wts=i
	if not wts:
		wts = len(sys.argv)
		
	sargs=[]; pargs=[]
	if wts:
		sargs = sys.argv[:wts] # sargs:(s)args:(s)ys.argv args 
		pargs = sys.argv[wts:] # (p)rogram args:(p)assed args:(p)args

	# A quick fix for executables in our direct path, where the user forgot to
	# prefix them with the standard ./ to execute them, referencing "this"
	# directory.  Also, I need to expand this section ensuring that the file has
	# a shebang line, and if not, call the program ahead of it.

	if pargs and os.path.isfile(pargs[0]) and not pargs[0].startswith('.') and \
		not pargs[0].startswith(os.sep):
		pargs[0] = "./%s" % pargs[0]

	# ##################################################################### #
	# ##################################################################### #
	# ##################################################################### #
	# ##################################################################### #

	# ----------------------------
	(opts, args) = parser.parse_args(sargs)
	# ----------------------------
	if opts.verbose: 
		opts.totally_verbose = True

	if opts.quiet: opts.verbose = 0

	# if opts.dry_run and not opts.quiet and not opts.verbose: opts.verbose = 1

	#if not opts.quiet: opts.verbose = True # Defaults to Verbose
	if not opts.verbose: opts.quiet = True # Defaults to Quiet 
	# ----------------------------

	old_version = opts.version
	opts.version = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	opts.version = old_version

	if opts.version:
		print("benchmark v%s" % __version__)
		return 0
	# ----------------------------

	log.setLevel(0)

	if opts.verbose:			 logging.getLogger().setLevel(level=logging.WARNING)
	if opts.verbose > 1:	 logging.getLogger().setLevel(level=logging.INFO)
	if opts.verbose > 2:	 
		opts.totally_verbose=True
		logging.getLogger().setLevel(level=logging.DEBUG)

	if opts.verbose > 3:	 
		opts.debug=True
		logging.getLogger().setLevel(level=logging.NOTSET)

	if opts.debug:				 logging.getLogger().setLevel(level=logging.DEBUG)
	if opts.quiet:				 logging.getLogger().setLevel(level=logging.CRITICAL)

	log.debug('sys.argv: %s' % repr(sargs))
	log.debug('passed program args: %s' % repr(pargs))


	# ##################################################################### #
	# BEGIN ERROR CHECKING (to be moved)
	
	if opts.frequency <> default_frequency:
		errors.append("YOU MAY NOT PROVIDE A FREQUENCY ARGUMENT!")

	action_set_via_bg = False # for better error handling...

	if opts.action and opts.background:
		errors.append('You provided the "background" [-b/--background] flag, ' \
			'which implies the argument "action" [-a/--action] "start".  Yet ' \
			'you also provided an action.  You do not need to provide an action, ' \
			'when providing the "background" flag.')

	elif opts.background is True:
		action_set_via_bg = True
		opts.action = 'start'

	#remove_me is a list of index pointer INTS to help clean up sys.args as sargs
	remove_me = [] 
	# we have to look for actions, and time to run (ttr), on STDIN.
	ttr_set_by_STDIN = False
	if len(sargs): 
		for i, arg in enumerate(sargs):
			try:
				ttr = int(arg)
			except ValueError:
				pass
			else:
				if ttr_set_by_STDIN is True:
					# now this is interesting, this means we have already caught, and set
					# it once, this means that EVEN if the provided INT is the same as
					# the default, we want to catch the second declaration of an INT, and
					# raise it as an error.
					errors.append('You have provided two (2) separate integers via ' \
						'STDIN, "%s" and "%s."  This is silly, you can only specify how ' \
						'many times to run once.  Otherwise I will not know which ' \
						'number to use.' % (opts.ttr, arg))

				# uh ohh, it is already specified once,.. hmm.. maybe it is just the
				# default.
				elif ttr_set_by_STDIN is False and opts.ttr <> default_times_to_run:
					# uh oh, the user specified ttr as an argument and provided it
					# blindly on STDIN.
					errors.append('You cannot provide "times to run" twice, once as ' \
						"an argument [-t/--times-to-run] (%s) and once without an " \
						"argument (%s)." % (opts.ttr, arg))
				else:
					opts.ttr = int(arg)
					ttr_set_by_STDIN = True

			if str(arg).lower() in ('start','stop','restart','status'):
				if opts.action is None: # redundant, but to have it more readable.
					# action not provided as an attribute, but on STDIN, set opts.action
					# now
					if opts.background:
						# uh oh, we have an action implied, by the background flag, and an
						# action provided on STDIN.
						errors.append('You provided the "background" ' \
							'[-b/--background] flag, which implies the argument ' \
							'"action" [-a/--action] "start".  Yet you also provided ' \
							'an action via STDIN.  You do not need to provide an ' \
							'action, when providing the "background" flag.  This is like ' \
							'providing an action twice, which confuses me.')
					else:
						opts.action = arg.lower()
						remove_me.append(i)
				else:
					# uhoh, we have an action specified twice!
					if action_set_via_bg:
						errors.append('Using the optional flag "background" ' \
							'[-b/--bg/--background] already implies the action ' \
							'[-a/--action] "start". By also providing the an action on ' \
							'STDIN, you have provided an action twice, "start" via the ' \
							'"background" flag, and "%s" via STDIN.  This confuses ' \
							'me.' % arg.lower())
					else:
						errors.append('You have already specified "%s" as an action, ' \
							'and are also trying to provide the action "%s" via STDIN.\n\n' \
							'You may only specify ONE action [-a/--action].' % \
								(opts.action, arg))

		# If we remove ARGS in standard order, the list will immediately shift and
		# throw off the value of all other index pointers, thus we first must
		# reverse the list of pointers.
		remove_me.reverse()
		for i in remove_me:
			# then we can remove it from args, no longer needed now that it is set in
			# opts.action
			del sargs[i]
	
	if opts.ttr < 1:
		log.error("You must run the benchmark at least once, thus the " \
			"lowest number you can choose is 1.")
	elif opts.ttr > 500:
		log.error("You cannot run the benchmark this many times, it " \
			"would likely take weeks to run.")
	elif opts.ttr > 100:
		log.error("STRONG WARNING! You have chosen a VERY large number, this " \
			"may take too long to run.  You may press CTRL+C to exit if this " \
			"takes too long.")

	# END ERROR CHECKING (to be moved)
	# ##################################################################### #

  # ------------------------------------------------------------------------ |
	if not errors and opts.debug and opts.verbose > 3:
		PyTis.relogOpts(opts, "* VALUES AFTER LOADING *")

	if not errors and not len(pargs) and opts.action not in ('stop', 'restart', 
	'status'):
		return parser.print_usage() # returns 0
		# (same as below 2 lines)
		#parser.print_usage()
		#return 0

	elif not errors:
		if opts.action == 'start':
			if not opts.quiet:
				log.info("benchmark started at %s" % PyTis.prettyNow())


		y = SingleThread()
		y.setLogFile(log)
		y.setOpts(opts)

		if opts.action:
			y.register(run,opts)
			y.register(y.run)
			y.service(opts)
		else:
			return run(opts)

		"""
		
		argv=[]
		[argv.extend(arg.split()) for arg in pargs]
		
		cmd_list=[]
		cmd_list.extend(argv)

		log.info(repr(cmd_list))
		subprocess.call(cmd_list)
		"""
		
		print(repr(pargs))

		'''
		y	= SingleThread()
		y.run()
		'''
		return 0 #os.system(' '.join(sys.argv))

		
	else: # ( else there are errors)

		# odd, printing "\n" creates two line breaks, whereas a space, only one,...
		print(" ") # therefore, we only print a space.
		parser.print_usage()
		for e in errors:
			log.error("%s\n" % PyTis.wrap(e,71))

		return 1
	

	'''

	if not errors:
		if not opts.action:
			return parser.print_usage()
		else:
			y = PyTis.MyThread()
			y.setLogFile(log)
			y.setOpts(opts)
			y.register(run,opts,cfile)
			y.service(opts)
			return
	else:
		if len(args) == 0 and not opts.action and not errors:
			return parser.print_usage()
		return parser.print_help(errors)

	parser.print_help("ERROR: Unknown, but invalid input.")
	'''
	'''
	if len(sys.argv) > 1:
		try:
			ttr = int(sys.argv[1])
		except ValueError as e:
			print("ERROR: You may input an integer only, for times to run!")
			return 1
			# ttr = times_to_run

		else:
			if ttr < 1:
				print("ERROR: You must run the benchmark at least once, thus the " \
					"lowest number you can choose is 1.")
				return 1

			if ttr > 100:
				print("STRONG WARNING! You have chosen a VERY large number, this " \
					"may take too long to run.  You may press CTRL+C to exit if this " \
					"takes too long.")

			if ttr > 500:
				print("ERROR!!! You cannot run the benchmark this many times, it " \
					"would likely take weeks to run.")
				return 1

	else:
		ttr = times_to_run # the default, 
	
	'''


if __name__ == '__main__':
	sys.exit(main())

