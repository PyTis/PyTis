#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 3.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright Â© 2022 Josh Lee                                                #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 01:55 PM - 03 Aug, 2022       #
############################################################################## #
"""uniquelist
==========
Input from STDIN, all lines are sorted, unique lines are output
"""

import curses
import optparse
import pydoc
import optparse
import os
import sys

python_version = float("%s.%s"%(sys.version_info.major,sys.version_info.minor))
if python_version >= 3.0:
  from io import StringIO
else:
  from cStringIO import StringIO


__author__ = 'Josh Lee'
__created__ = '05:53pm 06 Jun, 2011'
__copyright__ = 'PyTis.com'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__version__ = '2.0'

class MParser(optparse.OptionParser):

  extra_txt = None

  def print_out(self, txt):
    try:
      #txt = txt.replace("`$","\n")
      txt = txt.replace("`$","\n                     ")
      #txt = txt.replace(":\n",":\n\n")
      win=curses.initscr()
      max_x, max_y = win.getmaxyx()
      curses.endwin()
      if len(txt.split("\n")) > max_x:
        pager = pydoc.getpager()
        try:
          pager(txt)
        except (EOFError, KeyboardInterrupt) as e:
          pass
      else:
        sys.stdout.write("%s\n" % txt)
    except:
      pager = pydoc.getpager()
      try:
        pager(txt)
      except (EOFError, KeyboardInterrupt) as e:
        pass
      sys.stdout.write("%s\n" % txt)


  def print_help(self, errors=None):
    """
    NAME
    SYNOPSIS
    DESCRIPTION
    OPTIONS
    COMMANDS
    ENVIRONMENT
    SEE ALSO
    AUTHOR
    HISTORY
    VERSION
    """
    buf = StringIO()
    sys.stdout = buf

    # The user did not enter --help, they only entered -h, show short help and
    # instructions on howto view full help.
    if '--help' not in sys.argv and self.extra_txt is not None:
      # print the short usage.
      self.set_usage("%s\n%s" % (self.get_usage(), "*** USE '--help' for the full help page. ***"))

    # If NOT (--help was typed in, and there is extra_text to show, and
    # full_help_available)
    if not ('--help' in sys.argv and self.extra_txt is not None and 
      self.full_help_available):
      # print help as the OptionParser normally would, without extra goodies
      optparse.OptionParser.print_help(self)

    if '--help' in sys.argv and self.extra_txt is not None and errors is None:
      """
      try: extras = "Created: %s\n" % __created__
      except NameError: pass
      try: extras = "%sAuthor: %s\n" % (extras,__author__)
      except NameError: pass
      try: extras = "%sCopyright: %s\n" % (extras,__copyright__)
      except NameError: pass
      try: extras = "%sVersion: %s\n" % (extras,__version__)
      except NameError: pass
      if extras:
        self.extra_txt = "\n%s\n\n%s" % (self.extra_txt, extras)
      """
      #print self.extra_txt
      self.print_out(self.extra_txt)

    if not errors:
      errors = []

    if not isinstance(errors, list):
      errors = [errors]

    sys.stdout = sys.__stdout__
    # XXX:TODO - 2 Weeks ago I was writing a ManPage builder.  Afer looking
    # back at this method I wrote years ago.  I realized it would be easy to
    # alter this code just slightly to have it generate manpages.  It may be
    # better to just add a similar method for generating manpages, easier than
    # what I was doing.
    self.print_out(buf.getvalue().replace("Options:\n","OPTIONS:\n").replace(":\n",":\n\n"))
    #txt = txt.replace(":\n",":\n\n")

    if errors:
      sys.stderr.write("\n")
      for error in errors:
        sys.stderr.write(wrap("ERROR: %s\n" % error))
    sys.stderr.flush()
# =============================================================================
# Begin Helpers

def parse(lines):
  ret = []
  for line in lines:
    line = line.strip()
    if not line: 
      continue
    if not line.startswith('#'):
      if line not in ret and line.strip():
        ret.append(line.strip())
  ret.sort()
  return ret


def main():
  """usage: `cat` somefile.txt | uniquelist 

** uniquelist also removes lines that start with a hashtag (#) and blanklines.
  """
  global __version__, log
  # ----------------------------
  parser = MParser()
  parser.set_usage(main.__doc__)
  parser.formatter.format_description = lambda s:s

  # ----------------------------

  vrs = optparse.OptionGroup(parser, "MAIN",'')

  vrs.add_option("-m", "--mp3", action="store_true",
                    default=False, dest="mp3",
                    help="For Winamp playlist (alias for winamp)")

  vrs.add_option("-w", "--winamp", action="store_true",
                    default=False, dest="mp3",
                    help="For Winamp playlist")

  parser.add_option_group(vrs)

  dbg = optparse.OptionGroup(parser, "DEBUG",'')

  dbg.add_option("-D", "--debug", action="store_true",
                    default=False, 
                    help="Enable debugging")

  dbg.add_option("-v", "--version", action="store_true",
                    default=False, 
                    help="Display Version")

  parser.add_option_group(dbg)

  help_dict = dict(version=__version__,
             author=__author__,
             created=__created__,
             copyright=__copyright__)

  if '--help' in sys.argv:
    extra = """

SYMANTICS:
  Flag vs. Argument:
  Flag - an option that accepts no input.
  Argument - an option that requires input.

SEE ALSO:
  cnt
  fixedwidth
  to80

COPYRIGHT:
  %(copyright)s

AUTHOR:
  %(author)s

HISTORY:
  Original Author

CHANGE LOG:
  v2.0 MAJOR CHANGE                                               August 3, 2022
      First, added -m/--mp3 as an alias of newly added -w/--winamp optional
    flag.  Because I've found myself once again using this program, but not for
    editing music lists, rather for cleaning up a list of Python files, I've
    realized we do not always wish to have the "#EXTM3U" prefixed line.  
      Now, this program will only print said prefix line (to work as a Winamp
    MP3 player playlist file) if you provided this optional flag.

      Secondly, I updated how this program prints the "--help" and how it is
    called, by moving it into the "pytis" directory, and mirring the way
    "getip" works.  This will allow me to call this function in the future,
    importing it's functionality.

  v1.1 MINOR CHANGE                                               August 2, 2022
  Updated to run in Python3 

  v1.0 ORIGINAL RELEASE                                             June 6, 2011
  Original Publish.


EXAMPLES:  

  cat old_music_list.mp3 | uniquelist --winamp > new_music_list.mp3

  cat python_files.txt | uniquelist > py_files_with_duplicates_removed.txt

  getip --list
  /home/jlee38/bitbucket/src_igb/python_files.txt

  uniquelist -dv

  uniquelist -h

  uniquelist --help


BUGS - KNOWN ISSUES:
  NONE (at tis time).

CREATED:
  %(created)s

VERSION:
  %(version)s

"""  % help_dict

    parser.set_usage('')
    parser.set_description(__doc__ + extra)
    parser.print_help()
    print("\n\n")
    parser.set_usage(main.__doc__)
    parser.print_usage()
    return 0

  elif not sys.argv[1:] and sys.stdin.isatty():
    parser.print_usage()
    return 0

  elif '-h' in sys.argv:
    parser.print_help()
    return 0

  (opts, args) = parser.parse_args()

  if opts.version:
    print("getip v%s" % __version__)
    return 0

  if sys.stdin.isatty():

    try:
      infile = open(args[0])
    except IndexError:
      parser.print_help()
      return 0

  else:
    infile = sys.stdin

  if not infile:
    parser.print_usage()
    return 1

  newlines = parse(infile.readlines(-1))

  if newlines:
    if opts.mp3:
      print("#EXTM3U\n")
    for s in newlines:
      print(s)
  return 0 


if __name__ == '__main__':
  try:
    sys.exit(main())
  except Exception as e:
    print("An error has occured.\n")
    print(str(e))
    sys.exit(1)

