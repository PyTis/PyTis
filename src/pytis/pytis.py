#!/usr/bin/env python3
# encoding=utf-8
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 1.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2009 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 08:15 11 Nov, 2009            #
############################################################################## #
""" This library started as a single file to hold just a few functions that I
repeatedly used.  Slowly it grew to include a universal config file loading,
saving, editing tool that is used by several of my scripts.  Eventually I wrote
a sub-class of the optparse.OptionParser, and my own logging file.  As with any
script library, this one has grown as my repetuir of scripts has.  Now I am
adding in several classes from pyservice.py Andrey Usov
(https://github.com/ownport/pyservice).  I tried to utilize his library for
daemonizing python scripts, but with no success.  I am going to have to
rewrite parts of it but I will be utilizing some of his classes.

# RIGHTVERSION GOTO line 66 (end of comments) ||| GOTO line 138 (CHANGE LOG)

I don't know why, I may have been programing since I was four years old, and
now, near 40, as a highly paid professional, I still can't seem to remember the
difference of Mutable vs Immutable.  Now, I know what the difference is, and
when, and how to use these as an advantage, I just forget the "word" that
defines this consept I very well know.  Thus, pasting definition below, as a
reference.

  Mutable vs Immutable:

  Mutable vs Immutable Objects. A mutable object can be changed after it's
  created, and an immutable object can't. That said, if you're defining your
  own class, you can make its objects immutable by making all fields final and
  private. Strings can be mutable or immutable depending on the language.

  Flag vs. Argument:
    Flag - an input option that accepts no input.
    Argument - an input option that requires input.

  *(for vim searching: 
    flag vs argument vs optional flag vs optional argument vs)*

program versioning.  (I need to add this to newscript)
# XXX::TODO::GET`ER DONE!
# __version__ = 0.1 --> creation
# __version__ = 0.2 --> it works
# __version__ = 0.3 --> clean it up
# __version__ = 0.4 --> document what has been cleaned up
# __version__ = 0.5 --> document everything else
# __version__ = 0.6 --> test everything we can, try to break it with bad input
# __version__ = 0.7 --> apply bug fixes
# __version__ = 0.8 --> document bug fixes, apply spell checking and cleanup to
#                        documentation.
# __version__ = 0.9 --> run importnanny, and ensure it is properly copyrighted! 
# __version__ = 0.9? -> ready for release, just needs packaged up 
# this is where confusion sets in, I still need to finish / complete jhelp, and
# learn how to auto-build man-pages from the --help options
# __version__ = 1.0 --> release with setup.py / installation files.

List of error codes, to remember which one to return.

Codes:

  0 - Proper Exit
  1 - Catchall for general errors
  2 - Misuse of shell builtins (according to Bash documentation)
      
  64 - command line usage error
  65 - data format error
  66 - cannot open input
  67 - addressee unknown
  68 - host name unknown
  69 - service unavailable
  70 - internal software error
  71 - system error (e.g., can't fork)
  72 - critical OS file missing
  73 - can't create (user) output file
  74 - input/output error
  75 - temp failure; user is invited to retry
  76 - remote error in protocol
  77 - permission denied
  78 - configuration error
  126 - Command invoked cannot execute
  127 - “command not found”
  128 - Invalid argument to exit
  128+n - Fatal error signal “n”
  130 - Script terminated by Control-C
  255 - Exit status out of range

Most Used Codes:

  0 - Proper Exit
  1 - Catchall for general errors
  2 - Misuse of shell builtins (according to Bash documentation)
  66 - cannot open input
  72 - critical OS file missing
  73 - can't create (user) output file
  74 - input/output error
  77 - permission denied
  78 - configuration error
  130 - Script terminated by Control-C

"""
# builtin
import base64 as b64
import os
import re
import sys
import glob
import time
import types
import errno
import pydoc
import atexit
import signal
import getpass
import logging
import datetime
import optparse
import resource
import itertools
import traceback
#import thread
import threading
from pprint import pprint

python_version = float("%s.%s"%(sys.version_info.major,sys.version_info.minor))

if python_version >= 3.0:
  from collections import UserDict
  from io import StringIO
  import functools

  # internal (mine/yours/ours) 
  class PermissionError(Exception): pass
  sys.path.append(os.path.abspath(os.path.dirname(__file__)))
  from pylib3 import configobj as COBJ
  from pylib3 import parse
  #from pylib3.util.dicts import odict
  from pylib3.util.dicts import cldict, default_dict, default_set_dict, odict
else:
  from UserDict import UserDict
  from cStringIO import StringIO

  class PermissionError(Exception): pass
  # internal (mine/yours/ours) 
  sys.path.append(os.path.abspath(os.path.dirname(__file__)))
  from pylib import configobj as COBJ
  from pylib import parse
  #from pylib.util.dicts import odict
  from pylib.util.dicts import cldict, default_dict, default_set_dict, odict
import configure as pytis_configure # (imports configdir and logdir)
#from pylib import pyservice

protected_options = (
  'aws_secret_access_key',
  'cloud_checker_access_key',
  'db_password',
  'pass',
  'password',
  'secret_access_key',
  'sr_secret_access_key',
)

__author__ = 'Josh Lee'
__created__ = '06:14pm 09 Sep, 2009'
__copyright__ = 'PyTis.com'
__configdir__ = pytis_configure.configdir # '/root/etc'
__logdir__ = pytis_configure.logdir # '/root/log'
__version__ = '8.4.2' # changed 2 files, so 8.4.0 to 8.4.2



__change_log__ = """

CHANGE LOG

v8.4.0                                                          January 20, 2022
  MAJOR CHANGE
    Major change in getip.py
    Also fixed broken import issue with bulkmore and bulkcopy.  Now these
    programs should work properly again.

V8.3.0
  MINOR CHANGE
    I've fixed getip so that it doesn't print the IP address out twice.
    I've also moved a few items around, so that the getip.py is in the pytis
    directory, so that the python get's installed under the python3 directory,
    while the "program" just imports pytis's getip and runs the "main"
    function.
    Also, fixed colorize so that it has the correct log prefix.

V8.2.9
  MINOR CHANGE
   Changes in PyTis.MyLogger to both the warn and warning methods.
    Tweaked log.warn, as it was depricated and throws a warning itself, which
    causes a loop if you are overriding the logging.Logger. God the Python3
    Devs are morons.  On top of this, they want you to replace log.warn with
    log.warning, three more letters to type.  What is it with Python 3 Devs
    that want more characters, instead of less?  I fix this by setting
    logging.Logger.warn=logging.Logger.warning in my override of warn, and
    within warn, I call warning, which I have also overridden.

v7.2
  MAJOR CHANGES
    added setup.py
    moved allot around, new pytis direcotry for libs, bin directory remains for
      scripts.
    added get_input function to be python version indepenent

v6.2
  MAJOR CHANGES
    added setup.py
    moved allot around, new pytis direcotry for libs, bin directory remains for
    scripts.

v6.1
  MINOR CHANGE ( version from boolean to integer)
    old PyTis.MyLogger::opt_verbose = False
    new PyTis.MyLogger::opt_verbose = 0 ( must be >=0<5 ) 
      (0,1,2,3,4) 0=quiet,1=verbose,2=more verbose,3=most verbose,4=debug too

v6.0
  MAJOR CHANGE (rather, many minor changes)
  Moved os.touch into a function.
  Created is_root() function
  Altered Pidfile.get_path so that NON root users can have paths
    within their own home directory.
  Fixed minor bug in Pidfile.fixdirs, where os.abspath was called
    instead of os.path.abspath
  Fixed BIG Bug, with MyThread inside of Run, where frequency of 0
    would run indefinately, need to "untab" (move left) the 'if not
    frequency' testing block, still within the while loop.
  Secondly, within the same MyThread.Run metohd, I added a log.warning
    and comment block, explaining the beauty of running in -D/--debug
    mode, and not getting stuck in a loop, because it breaks after the
    third cycle.
    >> self.log.warning("STOPPING THE PROCESS BY DESIGN.")

  Fixed os.touch functionality.  MANY things were wrong, it used
    O_APPEND (incorrectly, you cannot append to a non-existing file
    DUH!) instead of O_CREAT, AND, from version 3 to version 3.6 it
    was broken, as the truly low-level support wasn't actually
    completed, and calling os.open within the with statement raised an
    "AttributeError __exit__".  In other words, Python3's os.open was
    broken.  I had to use the built in "open" function instead.  I am
    not really sure where I got the code that is being used for the
    current design of touch:
      def touch(fname, times=None, ns=None, dir_fd=None):

    But I feel like it must be correct, it looks like I did some real
    research on it.

  Lastly, I believe this version of the primary PyTis library is
    now completely universal.  In other-words, it works properly in
    Python2.7 as well as Python3.x


v5.2
  Added relogOpts function, this utilizes the above added protected_options 

v5.1
  Altered parse_csv_file to take in an IO object, as well as a path to a file.

v5.0
  WOW I haven't stayed up on updating this thing, I forgot this change log was
  even here.  Well, recently, I added col2num and num2col functions, for MS
  Excel column translation.

v4.2
  created new class object ConfigField
  added class method to ConfigFile.validate
  added class method to ConfigFile.validate_obj
  added new Class ConfigurationError(Exception)

v4.1.55
  added new function microtime

v4.1.53
  added new Classes:
    DieNow(Exception)
    ProgrammerError(Exception)
  Fixed KeyboardInterrupt Error in Man Page --help pager
  added pause/Pause/unPause feature to custom logger (MyLogger)
  added mbool config file boolean evaluator
  added in tolen function, from the to80 script

v4.1.37
  Added in ability to read ini files.

XXX-TODO:
  gothrough sourceforge and continue creating the changelog.



Forward...

For years I have insisted that there only be one library, PyTis.  However I can
foresee the next release being the game changer.  It will contain my old trusty
python-zs library from Zertis LLC and KCG (The Koar Consulting Group, LLC).

This will give me the ability to use the greatest two functions ever written.
Sync and Snatch.  They are practically A.I. they are so intelligent.  They are
two of 1.5 gigs of previously written library code that I should probably just
start using, rather than re-invent the wheel.  I do plan on slowly importing it
though, and only bringing in what I need.

DataSource, many of these programs use similar datasources, that currently, are
ini files.  While that is great, eventually, I will want to control them with a
gui.  Which likely means having a site that allows me to setup variabls that
are stored in the database.  Whether it be PostgreSQL, MySQL, SQLite3, Mongo,
or INI, I would like these scripts to be able to run.  That is the point in
adding in the extrapolation layer of a data source.  While I could do that now,
I am trying to have some self control, and only do what is needed to get these
backup programs, well, back up, and running.  Next time though, I will put the
datasoucre in place.  It is fine that I am writing all of this ini file stuff,
because if the DS is to come from an INI file, then we will still have a use
for our code.




"""

__option_always__ = [False]
__input_options__ = ['y','N']

# #############################################################################
# Error Classes Below
# #############################################################################
class DieNow(Exception): pass # Egregious Error has occured, must exit now.
class NoFiles(Exception): pass
class QuitNow(Exception): pass
class IdiotError(Exception): pass
class FileExists(UserWarning): pass
class EmptyString(Exception): pass
class FileNotFound(UserWarning): pass
class InvalidInput(Exception): pass
InputError=InvalidInput
class FutureFeature(Exception): pass
class EmptyTemplate(FileNotFound): pass
class ProgrammerError(Exception): pass
class ConfigurationError(Exception): pass
class DuplicateCopyright(UserWarning): pass
class IdiotError(Exception): pass # (as a joke)

class ArgumentError(UserWarning):
  opt_str=''
  val=''
  choices=()
  def __init__(self,message,opt_str='',val='',choices=()):
    UserWarning.__init__(self,message)
    self.opt_str=opt_str
    self.val=val
    self.choices=choices

  def __str__(self,errstr=None,opt_str='',val='',choices=()):
    if opt_str: self.opt_str=opt_str
    if val: self.val=val
    if choices: self.choices=choices
    buf = [] 
    if errstr:
      buf.append(str(errstr))
    if self.opt_str or self.val or self.choices:
      if self.choices:
        x = "(choose from %s)" % ','.join(["'%s'" % choice for choice in self.choices])
      else:
        x = ''
      buf.append("%s - ERROR: option %s: invalid choice: '%s' %s" % \
        (os.path.basename(sys.argv[0]),
         self.opt_str,
         self.val,
         x))
    return "\n".join(buf)

def conjoin(unknown,errors=[]):
  if hasattr(unknown,'message'):
    unknown = unknown.message
  if type(unknown) is type(str('')):
    errors.append(unknown)
  elif type(unknown) is type(list([])):
    errors.extend(unknown)
  elif type(unknown) is type(tuple((1,))):
    [errors.append(u) for u in unknown if u]
  else:
    errors.append(repr(unknown))
  return errors

def get_input(*args, **kwargs):
  global python_version
  if python_version >= 3.0:
    return input(*args,**kwargs)
  else:
    return raw_input(*args,**kwargs)


# #############################################################################
# Custom Classes Below
# #############################################################################

# ============================================================================#
class NullLogHandler(logging.Handler):
  def emit(self, record): pass

## XXX-TODO TODAY XXX XXX
class MyThread(threading.Thread):
#class MyThread(object):
## XXX-TODO TODAY XXX XXX

  _pid = None # Process ID
  _pidfile = None # Instance of Pidfile management class
  _callbacks = []
  _parent_file = None
  _parent_name = None
  _parent = None
  _opts = None 
  action = None

  # -20 (most favorable to the process) to 19 (least favorable to the process)
  # default 10
  default_niceness = 10 
  _niceness = None

  # 0 for none, 1 for real time, 2 for best-effort, 3 for idle
  default_ioniceness_class = 2
  _ioniceness_class = None # was ioclass in pluto's (sf.net) pytis pre-merger

  # (0-7) with lower number being higher priority (only used when
  # ioniceness_class is 1 or 2)
  default_ioniceness = 4
  _ioniceness = None


  default_frequency = 1
  running = False

  def set_opts(self, opts):
    self._opts = opts
  def get_opts(self):
    if not self._opts: return optparse.Values()
    return self._opts
  opts = property(get_opts, set_opts)
  def setOpts(self,opts):
    self.opts=opts

  def set_parent_file(self, parent_file):
    self._parent_file = parent_file
  def get_parent_file(self):
    if not self._parent_file: self._parent_file = self.parent.__file__
    return self._parent_file
  parent_file = property(get_parent_file, set_parent_file)

  def set_parent_name(self, parent_name):
    self._parent_name = parent_name
  def get_parent_name(self):
    if not self._parent_name: 
      try:
        self._parent_name = os.path.basename(self.parent_file).split('.')[0]
      except: 
        self._parent_name = self.parent.__name__
    return self._parent_name
  parent_name = property(get_parent_name, set_parent_name)

  def set_parent(self, parent):
    self._parent = parent
  def get_parent(self):
    if not self._parent: self.parent = calling_module()
    return self._parent
  parent = property(get_parent, set_parent)


  def set_callbacks(self, i):
    self._callbacks.append(i)
  def get_callbacks(self):
    if not self._callbacks: return []
    return self._callbacks
  callbacks = property(get_callbacks,set_callbacks)

  def set_pid(self, pid):
    self._pid = pid
  def get_pid(self):
    if not self._pid: self.pidfile.pid
    return self._pid
  pid = property(get_pid, set_pid)

  def set_pidfile(self, pidfile):
    self._pidfile = pidfile
  def get_pidfile(self):
    if not self._pidfile: self._pidfile = Pidfile(self.parent_file)
    return self._pidfile
  pidfile = property(get_pidfile, set_pidfile)

  def __init__(self):
    global log
## XXX-TODO TODAY XXX XXX
    threading.Thread.__init__(self, target=self.Run, name='PyTis-Thread')
## XXX-TODO TODAY XXX XXX
    self.keep_going=True
    if log is not None:
      self.setLogFile(log)
    atexit.register(self.stop)

  def start(self):
    ''' You should override this method when you subclass Process.
It will be called before the process will be runned via when you call caplital 
Start. '''
    #self.log.debug('override start')
    pass

  def stop(self):
    ''' You should override this method when you subclass Process.
It will be called after the process has been stopped or interupted by
signal.SIGTERM'''
    #self.log.debug('override stop')
    pass

  def setLogFile(self, log):
    self.log=log
  
  def control(self, action):
    action = action.lower().title()
    if action not in ('Start','Stop','Restart','Status'):
      log.error("Invalid control action, must be in <start,stop,restart,status>")
    try:
      getattr(self, action)()
    except RuntimeError as e:
      #print >> sys.stderr, e
      sys.stderr.write("%s\n" % str(e))

  def register(self, run, *args,**kwargs):
    '''
    func - function to be called at exit
    targs - optional arguments to pass to func
    kargs - optional keyword arguments to pass to func
    '''
    c=Callback()
    c.setCallback(run)
    c.setArgs(*args)
    c.setKwArgs(**kwargs)
    self.callbacks = c

  def Start(self):
    stderr = sys.stderr
    old_pid = self.pidfile.validate()
    if old_pid:
      self.log.error("Error during service start:\n " \
        "Already running on PID %s (or pid file '%s' is stale)" % \
        (old_pid, self.pidfile.pidfile))
      return

    # Start the service
    self.log.info("starting the %s service now" % (self.parent_name))
    if self.daemonize():
      try:
        self.pidfile.create()
      except RuntimeError as err:
        # *IMPORTANT* No matter what, this will not make it to the screen.
        # Even print statements won't make it to the screen from here.
        # This is already within the spawned child process with no open pipes
        # to the parent.  The best we can do is log.
        self.log.error("Error during service start: %s" % str(err))
        return

      atexit.register(self.remove_pid)
      self.start()
      try:
        self.keep_going = True
        self.running = True
#        thread.start_new_thread(self.Run, None, self.opts)
        t=threading.Thread(None,self.Run,None)
#        self.Run()
        t.start()
        #t.opts=self.opts
      #  t.join()
      except Exception as e:
        self.keep_going=False
        self.running=False
        self.log.error(e)
        #print >> sys.stderr, e
        #sys.stderr.write(str(e))
        raise Exception(e)
        return
      self.log.info('%s service started' % self.parent_name)
    else:
      self.log.info("Success, all done")
    return

  def _fork(self, fid):
    ''' fid - fork id'''
    
    try:
      pid = os.fork()
    except OSError as e:
      self.log.error(
        "service._fork(), fork #%d failed: %d (%s)\n" % (fid, e.errno, e.strerror))
      raise OSError(e)
    return pid
  
  def daemonize(self):
    '''
do the UNIX double-fork magic, see Stevens' "Advanced
Programming in the UNIX Environment" for details (ISBN 0201563177)
http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
'''

    def _maxfd(limit=1024):
      ''' Use the getrlimit method to retrieve the maximum file
descriptor number that can be opened by this process. If
there is not limit on the resource, use the default value
limit - default maximum for the number of available file descriptors.
'''
      maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
      if maxfd == resource.RLIM_INFINITY:
        return limit
      else:
        return maxfd
    
    def _devnull(default="/dev/null"):
      # The standard I/O file descriptors are redirected to /dev/null by
      # default.
      if hasattr(os, "devnull"):
        return os.devnull
      else:
        return default

    def _close_fds(preserve=None):
      preserve = preserve or []
      for fd in range(0, _maxfd()):
        if fd not in preserve:
          try:
            os.close(fd)
          except OSError: # fd wasn't open to begin with (ignored)
            pass

    pid = self._fork(1) # first fork
    if pid == 0: # the first child
      os.setsid()
      pid = self._fork(2)
      if pid == 0: # the second child
        os.chdir("/")
        os.umask(0)
      else:
        os._exit(0)
      _close_fds(logging_file_descriptors())
    else:
      os._exit(0)

    os.open(_devnull(), os.O_RDWR)
    os.dup2(0, 1)  # standard output (1)
    os.dup2(0, 2)  # standard error (2)
    return True

  def remove_pid(self):
    if self.pidfile.validate():
      self.pidfile.unlink()
    self.log.info('the task completed, service was stopped')

  def _stop(self):
    self.keep_going=False
    self.stop()

  def Stop(self):
    pid = self.pidfile.validate()
    if not pid:
      self.log.error("pidfile %s does not exist. The %s service is not " \
      "running." % (self.pidfile.pidfile, self.parent_name))
      return # not an error in a restart

    # Try killing the service process
    try:
      while 1:
        os.kill(pid, signal.SIGTERM)
        time.sleep(0.1)
    except OSError as err:
      err = str(err)
      if err.find("No such process") > 0:
        self.pidfile.unlink()
      else:
        self.log.error('Error during service stop, %s' % str(err))
        raise OSError(err)

    self.log.info('stopping %s [%s] service.' %(self.parent_name, pid))
    self.log.debug('service [%s] was stopped by SIGTERM signal' % pid)

  #def remove_pid(self):
  #  if self.pidfile.validate(): self.pidfile.unlink()

  def IsRunning(self):
    return self.running
  
  def RunningAndService(self):
    return self.IsRunning() and bool(self.pidfile.validate())

  def Status(self):
    pid = self.pidfile.validate()
    if pid:
      try:
        os.kill(pid, 0)
        print('process {} is running, pid: {}'.format(self.parent_name, pid))
        return
      except (OSError, TypeError):
        pass
    print( "{} process is not running".format(self.parent_name) )

  def Restart(self):
    self.log.info('restarting [%s] service.' % self.parent_name)
    self.Stop()
    self.Start()

  # IO (Hard Drive) Niceness Class (0,1,2,3)
  def set_ioniceness_class(self, ioniceness_class):
    self._ioniceness_class = ioniceness_class
  def get_ioniceness_class(self):
    if not self._ioniceness_class:
      try: 
        self._ioniceness_class = opts.ioniceness_class
      except AttributeError as e: 
      # could set to default here, but that happens anyways right below 
        pass 
      # if there still is not one, perhaps opts.ioniceness_class was none
      if not self._ioniceness_class: 
        self.ioniceness_class = self.default_ioniceness_class 
    return self._ioniceness_class
  ioniceness_class = property(get_ioniceness_class, set_ioniceness_class)

  # IO (Hard Drive) Niceness (Classdata 0-7)
  def set_ioniceness(self, ioniceness):
    self._ioniceness = ioniceness
  def get_ioniceness(self):
    if not self._ioniceness: self.ioniceness = self.default_ioniceness
    return self._ioniceness
  ioniceness = property(get_ioniceness, set_ioniceness)

  # CPU Nicenes
  def set_niceness(self, niceness):
    self._niceness = niceness
  def get_niceness(self):
    if not self._niceness: 
      self._niceness = self.default_niceness
    # Final check, to make sure an invalid niceity hasn't been set.
    if self._niceness not in range(-20,20):
      self.log.warn("Invalid nicity specified.")
      self._niceness = self.default_niceness
    return self._niceness
  niceness = property(get_niceness, set_niceness)

  def buildNice(self):
    """ To control the niceness to the CPU, the niceness is used for children
    processes, to pass this onto child processes (client) from a parent
    (server).

    This method returns a list, so it can be extended and/or passed into
    external commands, and child processes.

    Example:

      cmd_list = self.buildIoNice()
      cmd_list.extend(self.buildNice())
      cmd_list.extend(["nmap","-vv"])
      subprocess.call(cmd_list)

    """
    if self.niceness not in range(-20,20):
      self.log.warn("Invalid nicity specified.")
      self.niceness = self.default_niceness

    return ['nice', '-n%s' % self.niceness]

  def setNiceness(self):
    """ To control the niceness to the CPU, the niceness is used to control the
      "nicity" to the Central Processing Unit (CPU). This method tells the
      instance to begin using whichever value has been set. If none has been set
      the default getters/setters will return the built in default niceness.

      This method specifically, tells the instance to set the niceness locally,
      for the current, running process.
    """
    try:
      os.nice(self.opts.niceness)
    except (AttributeError, NameError) as e:
      pass

  def buildIoNice(self):
    if self.ioniceness_class not in (1,2,3):
      self.log.warn("Invalid ionice class specified.")
      self.ioniceness_class = self.default_ioniceness_class

    if self.ioniceness not in range(0,8):
      self.log.warn("Invalid ionice classdata specified.")
      self.ioniceness = self.default_ioniceness
    if self.ioniceness_class ==3:
      return ['ionice', '-c3']
    return ['ionice', '-c%s' % self.ioniceness_class, '-n%s' % self.ioniceness]

  def buildAttrs(self, opts):
    try:
      self.niceness = opts.niceness
    except AttributeError as e:
      self.niceness = self.default_niceness

    try:
      self.ioniceness_class = opts.ioniceness_class
    except AttributeError as e:
      self.ioniceness_class = self.default_ioniceness_class

    try:
      self.ioniceness = opts.ioniceness
    except AttributeError as e:
      self.ioniceness = self.default_ioniceness
  
    try:
      self.frequency = int(opts.frequency)
    except (AttributeError, NameError, ValueError) as e:
      self.frequency = self.default_frequency

  def service(self, opts):
    ''' alias for self.control with the "action" pulled out of opts and passed 
    in seperately
    '''
    try:
      self.action = opts.action
    except AttributeError as e:
      if type(opts) is type(str()) and opts.lower() in ('start','stop',
      'restart','status'):
        self.action=opts
      else:
        raise ProgrammerError("optparse action is missing, to " \
          "use MyThread.service optparse must have a valid action " \
          "(start,stop,restart,status)")
    self.buildAttrs(opts)
    return self.control(self.action)

  def Run(self):
    i=0
    os.nice(self.niceness)
    while self.keep_going:
      if not self.callbacks:
        self._run()
      else:  
        if self.frequency or ( not self.frequency and not i):
          for v in self.callbacks:
            callback = v.getCallback()
            args = v.getArgs()
            kwargs = v.getKwArgs()
            try:
              callback(*args,**kwargs)
            except (KeyboardInterrupt, QuitNow) as e:
              print("\nbye!")
              self.keep_going = False
              self._stop()
              self.running=False
              return
            except Exception as e:
              self.log.error("Some error occured.")
              type_,value_,traceback_ = sys.exc_info()
              self.log.debug("type: %s" % type_)
              self.log.debug("type2: %s" %type(e))
              self.log.debug("value: %s" % value_)
              for tb_line in traceback.format_tb(traceback_):
                self.log.debug(tb_line)
              self.log.error(str(e))

      if not self.frequency and not i:
          self._stop()
          self.running=False
          return

      if self.frequency:
        time.sleep(self.frequency)
        
      try:
        if self.opts.debug:
          i+=1
          if i > 2: 
            #self.log.warning("The [-D/--debug] is True, therefore, by " \
            #  "design, the loop only runs 3 times, never any more.")
            self.log.warning("STOPPING THE PROCESS BY DESIGN.")
            self._stop()
            self.running=False
            return
      except (AttributeError, NameError) as e:
        pass

  def _run(self):
    self.log.warn('running placeholder until callbacks are set')

# ============================================================================#
class Pidfile(object):
  ''' Manage a PID file '''
  _filename = None  # just the name of the file with .pid extension on the end
  _pidfile = None # A.K.A. fullpath to file
  _path = None # path to save the PID file in, not including filename
  _name = None # name to create filename from, no extension
  _pid = None # PID (integer)
  log = None # log file

  caller = None

  def __init__(self, name=None):
    global log
    self.log = log
    self.name = os.path.basename(name)
    self.caller = calling_module()

  # --------------------------------------------------------------------------#
  # properties begin

  def set_log(self, log):
    self._log = log
  def get_log(self):
    if not self._log:
      global log; self._log=log
    return self._log
  log = property(get_log, set_log)
    # -------------------------------------- #
  def set_name(self, name):
    self._name = name
  def get_name(self):
    ''' passed into new instance, or determined by the 'rename' method
    '''
    if not self._name: self.rename()
    return self._name
  name = property(get_name, set_name)
    # -------------------------------------- #
  def set_filename(self, filename):
    self._filename = filename
  def get_filename(self):
    ''' self.name + .pid = filename
    '''
    if not self._filename: self._filename = "%s.pid" % self.name
    return self._filename
  filename = property(get_filename, set_filename)
    # -------------------------------------- #
  def set_path(self, path):
    self._path = path
  def get_path(self):
    ''' determined based on OS, can be set on instance
    '''
    if not self._path:
      if os.name in ('posix'):
        rundir = '/run/'
      elif os.name in ('mac', 'os2', 'ce', 'riscos'):
        rundir = '/var/run/'
      elif os.name == 'nt':
        if self.caller is not None:
          rundir = os.path.join(os.path.dirname(self.caller.__file__), 
          'run/')
        else:
          rundir = os.path.join(os.path.dirname(__file__), 'run/')
      else:
        rundir = os.getcwd()

      self._path = os.path.abspath(rundir)

      if not os.path.isdir(self._path) or not os.path.exists(self._path):
        try:
          os.makedirs(self._path)
        except (OSError, IOError):
          self._path = os.path.join(self._path,'/user/')
          if not os.path.isdir(self._path) or not os.path.exists(self._path):
            try:
              os.makedirs(self._path)
            except (OSError, IOError):
              self._path = os.path.abspath(os.getcwd())
          #self._path = os.path.abspath(os.getcwd())
          # . . . . . thinking . . . . .
          #
      testfile_to_be_deleted = os.path.abspath(os.path.join(self._path,
        'tf2b.deleteme'))
      # just in case this hasn't happened yet...
      add_os_touch()
      try:
        os.touch(testfile_to_be_deleted)
      except (OSError, IOError):
        # one last chance.
        if is_root():
          # well shit, idk, we tried.
          #pass
          self._path = os.path.abspath(os.getcwd())
        else:
          self._path = os.path.abspath(os.path.join(homedir(), 'run'))
          if not os.path.exists(self._path):
            try:
              os.mkdir(self._path, 0o777)
            except (OSError, IOError):
              self._path = os.path.abspath(os.getcwd())
      else:
        os.unlink(testfile_to_be_deleted)

    return self._path
  path = property(get_path, set_path)
    # -------------------------------------- #
  def set_pidfile(self, pidfile):
    self._pidfile = pidfile
  def get_pidfile(self):
    ''' if not set, use path + filename
    '''
    if not self._pidfile: 
      self._pidfile = os.path.abspath(os.path.join(self.path,self.filename))
    return self._pidfile
  pidfile = property(get_pidfile, set_pidfile)
    # -------------------------------------- #
  def set_pid(self, pid):
    self._pid = pid
  def get_pid(self):
    ''' Actual Process ID as integer
    '''
    if not self._pid: self.pid=os.getpid()
    return self._pid
  pid = property(get_pid, set_pid)

  # properties end
  # --------------------------------------------------------------------------#
  # setter/getter methods begin

  def rename(self):
    self.caller = calling_module()
    if self.caller is not None:
      name = os.path.basename(self.caller.__file__)
    else:
      name = get_calling_file()
      if name is not None:
        name = os.path.basename(name)
    if name is None:
      name = self.__name__
    name=name.lower()
    try:
      self.name = name.split('.')[0]
    except IndexError as e:
      self.name = name

  def fixdirs(self):
    if not os.path.isdir(self._path) or not os.path.exists(self._path):
      try:
        os.makedirs(self._path)
      except (OSError, IOError):
        self.path = os.path.abspath(os.getcwd())
    return

  def fixpath(self,pidfile):
    self._pidfile=None
    self.fixdirs()
    try:
      pfile = open(pidfile,'w')
    except IOError as e:
      if self.caller is not None:
        rundir = os.path.join(os.path.dirname(self.caller.__file__), 'run/')
      else:
        rundir = os.path.join(os.path.dirname(__file__), 'run/')
      self.path = os.path.abspath(rundir)
      self.fixdirs()
      try:
        pfile = open(pidfile,'w')
      except IOError as e:
        self.path = os.path.abspath(os.getcwd())
      else:
        pfile.close()
    else:
      pfile.close()
    return

  # setter/getter methods end 
  # --------------------------------------------------------------------------#
  # begin methods 

  def create(self,attempt=0):
    ''' create pid file
      Be very careful, simply accessing the path or pidfile property will set
      them, and in this case that is bad, because if this method finds the path
      set, and non-existant it will error out.  Accessing the pidfile accesses
      by-proxy, the path.
    '''

    pid = self.validate()
    if pid:
      if pid == os.getpid():
        # This, the current process/instance IS the PID, and it has already 
        # been created.
        return
      raise RuntimeError("Already running on PID %s " \
        "(or pid file '%s' is stale)" % (pid, self.pidfile))
        
    self.pid = os.getpid()

    # Write pidfile
    if self.path and not os.path.isdir(self.path):
      raise RuntimeError("%s doesn't exist. Can't create pidfile %s" % \
        (self.path, self.pidfile))

    try:
      pfile = open(self.pidfile,'w')
      pfile.write("%s\n" % self.pid)
      pfile.close()
    except IOError as e:
      self.fixpath(self.pidfile)
      if attempt > 1:
        raise RuntimeError(e)
      else:
        self.create(attempt+1)
    else:
      # set permissions to -rw-r--r--
      os.chmod(self.pidfile, 420)
      
  def unlink(self):
    """ delete pidfile"""
    try:
      #with open(self.pidfile, "r") as f:
      #  pid_in_file = int(f.read() or 0)
      os.unlink(self.pidfile)
    except:
      pass

  def validate(self):
    """ Validate pidfile and make it stale if needed"""
    if not self.pidfile or not os.path.exists(self.pidfile):
      return False
    try:
        pfile = open(self.pidfile, "r")
        pid = int(pfile.read(-1).strip())
        pfile.close()
        if pid <= 0:
          return
        try:
          os.kill(pid, 0)
          # old exiss, kill the old
          return pid
        except OSError as e:
          # could not kill the old for one reason or another
#          self.log.error("Pidfile.validate - OSError(%s)" % e)
          if e[0] == errno.ESRCH:
            return
          raise RuntimeError("Can not kill process [%s] or remove old PID file (%s), permission denied. - OSError(%s)" % (pid,self.pidfile,e))
    except IOError as e:
      self.log.error("Pidfile.validate - IOError(%s)" % e)
      if e[0] == errno.ENOENT:
        return
      raise RuntimeError("Pidfile.validate - IOError(%s)" % e)
    except ValueError as e:
      #self.log.info("likely the contents of the pid file could not be cast to an int: '%s'" % str(pid))
      self.log.debug("Pidfile.validate - ValueError(%s)" % e)
      raise ValueError(e)

  # end methods
  # --------------------------------------------------------------------------#


# ============================================================================#
class ConfigFile(COBJ.ConfigObj):
  _filename = None
  _opts = {} # OptionParser option value's dictionary attribute
  _fields = [] # list of field names
  _field_settings = {} # new list of fieldnames, until old variable has been fixed.

  _optional_fields = [] # list of optional field names 
  _exists = None # config file bool flag

  config = None # var to store COBJ object instance on
  prompts = [] # for saving, i.e. "Are you save the password to the .ini file?"

  # lazy_override: if True, then you can redeclare
  # ConfigFile.addField('SaidName',*args) and it will override a previously
  # supplied 'SaidName'  ELSE, by default, it will raise an error.
  _lazy_override = False

  '''
  def __getattr__(self,key):
    try:
      return dict.__getattr__(self, key)
    except AttributeError as e:
      try:
        return dict.__getitem__(self, key)
      except KeyError, e:
        return None
  '''
  # ###########################################################################
  # begin properties
  def set_exists(self):
    if self.filename and os.path.exists(self.filename):
      self._exists = True
    else:
      self._exists = False
  def get_exists(self):
    if self._exists is None:
      self.set_exists()
    return self._exists
  exists = property(get_exists, set_exists)

  def set_field_settings(self, field_settings={}):
    self._field_settings = field_settings
  def get_field_settings(self):
    return self._field_settings
  field_settings = property(get_field_settings, set_field_settings)

  def set_fields(self, fields):
    self._fields = fields
  def get_fields(self):
    return self._fields
  fields = property(get_fields, set_fields)

  def set_optional_fields(self, optional_fields):
    self._optional_fields = optional_fields
  def get_optional_fields(self):
    return self._optional_fields
  optional_fields = property(get_optional_fields, set_optional_fields)

  def set_lazy_override(self, lazy_override):
    self._lazy_override = lazy_override
  def get_lazy_override(self):
    return self._lazy_override
  lazy_override = property(get_lazy_override, set_lazy_override)

  def set_opts(self, opts):
    self._opts = opts
  def get_opts(self):
    return self._opts
  opts = property(get_opts, set_opts)

  def set_filename(self, fname=os.path.abspath(sys.argv[0])):
    self._filename=os.path.abspath(fname)
  def get_filename(self):
    if not self._filename:
      self.set_filename()
    return self._filename
  filename = property(get_filename, set_filename)
  # end properties
  # ###########################################################################

  def __init__(self, opts=None):
  # XXX - TODO !!!!
  # right now opts get passed into the init, and then set as an attribute on
  # this class.  But THEN we request them time and time again from the user
  # an argument for some of the methods.  That is silly, we already passed i
  # in once, why ask for it again.  We need to clean that up a bit.
  
  # XXX-TODO: I know I do the same thing as below in a few files to grab the
  # config file, filename.  I could just get it off this class as an attribu
  # Additionally, I would like to have the filename as one attribute/property
  # and the filepath as a separate one.  However I can't make this second
  # change just, as I have to ensure backwards compatibility.
    global log

    self.filename = os.path.abspath(os.path.join(__configdir__, \
    '%s.ini' % os.path.basename(os.path.abspath(sys.argv[0]))))

    log.debug("PyTis::ConfigFile setting filename: %s" % self.filename)

    if self.exists:
      self.config = self.getConfig(True)

    if opts:
      self.fields = opts.__dict__.keys()
      self.opts = dict(opts.__dict__.items())

  # brain dump here....  We need a better way to create this datasource.  It
  # should specify the default value (if it exists), its relative
  # OptionParser option, it's config file name, whether or not it can get
  # saved in the global section.  Whether or not it inherits from above
  # sections, it's type cast, etc.  I can start with a simple addField
  # method, and extend that to do a batchAddFields method.  I can already
  # forsee a good reason for YAML, to create config file definitions, but I
  # don't want to get to far ahead of myself.  It is already going to be ver
  # difficult to create this loosly coupled enough that it can get reused in
  # any of my programs that use ini files.  There are already some examples
  # of scripts that use pylib.configobj.ConfigObj (COBJ.load) instead of
  # PyTis.ConfigFile.  I don't know why, but they should all, in theory, be
  # able to use this one.
  
  def batchAddFields(self,L=[]):
    """ L should be a list of dictionaries, each of which could be passed as
    kwargs directly into ConfigFile.addField() """
    for kwargs in L:
      self.addField(**kwargs)
  
  def addField(self, config_name, required=True, default_value=None, \
    option=None, opt_parse_destination=None, global_scope=True, inherited=True,
    prompt=False, cast=str, title_override=None):
      if not self.lazy_override and config_name in self.field_settings.keys():
        raise ProgrammingError('This config field ("%s") has already been ' \
        'added.' % config_name)
    
      d = {
        'config_name':config_name,
        'required':required,
        'default_value':default_value,
        'option':option,
        'opt_parse_destination':opt_parse_destination,
        'global_scope': global_scope,
        'prompt':prompt,
        'inherited':inherited,
        'cast':cast,
        'title_override':title_override
      }
      field = ConfigField(d)
      self.field_settings[config_name]=field

  # ########################################################################
  # ########################################################################
  # ########################################################################
  def validate_opt(self,key, section_name=None):
    """ To clarify, this is just to make sure that the option can be found,
    not as an option argument, then in the section's configuration, and if n
    there, then look to the global configuration settings.  If a required fi
    cannot be found, raise an empty string error.
  
    field attributes to consider (they all need handled, otherwise, what
    the hell was the point in setting them?
    field(
      config_name='niceness',
      option=opts.niceness,
      opt_parse_destination='niceness',
      required=True,
      cast=int
      default_value=PyTis.MyThread.default_niceness,
  
      global_scope=True,
      inherited=True,
  
      )
  
    """
    global log
    field = self.field_settings[key]
    dig_config=False
    found_value = None
    try:
      opt_val = self.opts[self.field_settings[key].opt_parse_destination]
    except KeyError as e:
      # doesn't even have the attribute in options, the look to config
      dig_config=True
    else:
      if type(opt_val) == type(str('')) and opt_val=='=' or not trim(opt_val):
      # an empty string
        if field.cast == int:
          if field.default_value == opt_val:
            dig_config = True
          elif field.default_value == 0 and field.required:
            dig_config = True
        else:
          opt_val=''
          dig_config=True
    
      if type(opt_val) is type(list([])) and not trim(opt_val):
      # an empty list
        opt_val = []
        dig_config=True
    
      # if it does exist in the options as an attribute, but only because it
      # the default, then we need to really look to the configuration
      if field.opt_parse_destination is not None and \
        field.option is not None and \
        field.option == field.default_value:
        # not empty, but equal to the default
        dig_config=True
        found_value = field.option
        # so down below, while digging config, we can allow extending of val
        # for intheritted fields, UNLESS the found_value == detfault value.
        # therefore, below, expect to check the field.default_value at least
        # twice, once within the section if a value is found, and again with
        # the global, if a value is found.  Come to think about it we check
        # global multiple times so likely, we will be doing the same thing o
        # and over again, so likely we will need to turn this into a functio
    
        # some func(optval from optparser, sectional val, global val, field
        # itself)

        # this makes since, but should not be extended, because then it woul
        # only always extend into set values, default values
  
      elif field.opt_parse_destination is not None and \
        field.option is not None and \
        not dig_config and trim(opt_val):
        # plain and simple we found a value that was specified by the user o
        # STDIN, this is not a default value.
        found_value = field.option
        # so we don't need to look through the config
    
        if field.cast == dict or field.cast == list and field.inherited:
          # Unless... it needs to be extended because it is an inheritable s
          dig_config = True
    
    sectional_value = None
    global_value = None
    if (dig_config or not key in self.opts.keys())and section_name:
      try:
        self.config[section_name]
      except KeyError as e:
        raise EmptyString('Section "%s" provided, and could not be found in ' \
        'the config file.' % section_name)
    
      # LOADING
      try:
        sectional_value = self.config[section_name][key]
      except KeyError as e:
        if section_name and field.required:
          log.warn('"%s" not found under section: %s, looking into global ' \
          'section.' % (field.title,section_name))
      else:
        if section_name and not trim(sectional_value) and field.required:
          log.warn('"%s" not found under section: %s, looking into global ' \
          'section.' % (field.title,section_name))
    
      try:
        global_value = self.config[key]
      except KeyError as e:
        if trim(sectional_value) and field.required and section_name:
          # there is a value, it is required, and there is a section
          pass
        elif not trim(sectional_value) and field.required:
          # there is NOT a value, it is required, and there is a section
          if not trim(found_value):
            if section_name:
              raise ConfigurationError('"%s" not found in the global ' \
                'section of the configuration file, and is required. ' \
              'Unable to lookup: [%s:%s].' % (field.title,section_name,key))
            else:
              raise ConfigurationError('"%s" not found in the global ' \
              'section of the configuration file, and is ' \
              'required.' % field.title)
      else:
        if not field.global_scope:
          raise ConfigurationError("Somebody directly edited the ' \
          'configuration ini file (%s).  You may not specify the '%s' in ' \
          'the global section." % (field.title,self.filename))
      
      # CASTING
      if sectional_value or field.cast == int and sectional_value == 0:
        try:
          if field.cast == bool:
            sectional_value = mbool(sectional_value,False)
          else:
            sectional_value = field.cast(sectional_value)
        except (ValueError, TypeError) as e:
          raise ConfigurationError('Wrong type of value stored for "%s" in '
          'section "%s", it must be a: %s.' % (field.title, section_name,
          str(field.cast)))
        else:
            return sectional_value

      if global_value or field.cast == int and global_value == 0:
        try:
          if field.cast == bool:
            global_value = mbool(global_value,False)
          else:
            global_value = field.cast(global_value)
        except (ValueError, TypeError) as e:
          raise ConfigurationError('Wrong type of value stored for "%s", ' \
          'it must be a: %s.' % (field.title, str(field.cast)))
        else:
          return global_value
  
    # CASTING

    if found_value or field.cast == int and found_value == 0:
      try:
        if field.cast == bool:
          found_value = mbool(found_value,False)
        else:
          found_value = field.cast(found_value)
      except (ValueError, TypeError) as e:
        raise ConfigurationError('Wrong type of value passed in STDIN as an ' \
        'argument for "%s", it must be a: %s.' % (field.title,str(field.cast)))

      return found_value

    value = None
    if dig_config or not key in self.opts.keys():
      # log.debug("key: %s" % key)
      # log.debug("sectional_value: %s" % sectional_value)
      # log.debug("global_value: %s" % global_value)
      # log.debug("field.inherited: %s" % field.inherited)
  
      if field.inherited and field.global_scope:
  
        if field.cast == dict:
  
          if field.update_type == 'parent':
            sectional_value.update(global_value)
            if trim(found_value):
              sectional_value.update(found_value)
            value = sectional_value
          elif field.update_type == 'child':
            global_value.update(sectional_value)
            if trim(found_value):
              global_value.update(found_value)
            value = global_value
          else: # == none, only update if there is an option value
            if trim(sectional_value):
              value = sectional_value
            elif trim(global_value):
              value = global_value
  
            if trim(found_value):
              value.update(found_value)
          return value

      elif field.inherited and not field.global_scope:
        if trim(sectional_value):
          value = unique(sectional_value)
        elif trim(global_value):
          value = unique(global_value)
  
        if trim(found_value):
          value.extend(found_value)
          value = unique(value)
        return value
  
      if trim(sectional_value) or field.cast == int and sectional_value == 0:
        return sectional_value
      if trim(global_value):
        return global_value
  
    # stuck here
      if trim(found_value):
        if section_name and field.default_value and \
          found_value == field.default_value and not sectional_value:
  
          log.warn('We could not find a saved value for "%s," we will use ' \
          'the default value of "%s."  You may  want to save a value in the ' \
          'config for this field  under section: "%s"' % \
            (field.title, field.default_value, section_name))
  
  
        elif field.global_scope and field.default_value and \
        found_value == field.default_value and not global_value:
          log.warn('We could not find a saved value in the global section ' \
          ' for "%s," we will use the default value of "%s."' % \
          (field.title, field.default_value))
# FINDME FINDME
        elif field.default_value and found_value == field.default_value:
          log.warn('We could not find a saved value anywhere for "%s."  You' \
          ' may want to save a value in the config for this field.' % \
          field.title)
        return found_value
    else:
      if trim(found_value) or field.default_value is None and found_value == 0:
        return found_value
      elif field.required:
        del self.opts[key]
        return self.validate_opt(key,section_name)
      else:
        if field.cast == str:
          return field.cast('')
        elif field.cast == list:
          return field.cast([])
        elif field.cast == tuple:
          return field.cast(())
        elif field.cast == int:
          return field.cast(0)
        elif field.cast == float:
          return field.cast(0)
        elif field.cast == dict:
          return field.cast({})
        elif field.cast == bool:
          return field.cast(False)
  
  

  # ########################################################################
  def validateToSave(self, opts):
    return self.validate(opts, sparce=True)
  
  def validateToRun(self, opts):
    return self.validate(opts, sparce=False)

  def validate(self, opts, sparce=True):
    """ Very similar to what will occur within the run function.  This function
    will ensure that the required data for all of the sections (or only one
    section, if only one is specified to be ran/tested via the optional
    attrribute "--section-name=[NAME OF SECTION]").  If the required data cannot
    be found the parsed arguments/options (or can be found, but is simply a
    default value), then look to the config.  If it cannot be found within the
    section then look globally within the config.  Lastly, unless the action and
    section were sprecifically specified within the STDIN optional arguments,
    then this may skip over sections who have the ignore flag set.
  
    This makes sure that when this runs for a cronjob, that each section that
    could run, will.  In other words, each section that is not explicedly set
    to "ignore" have all required variables set, or can be inherited.
    """
    global log
  
    if opts:
      self.opts = dict(opts.__dict__.items())
  
    sections = identify_sections(self.config)
    field_keys = self.field_settings.keys()
    field_keys.sort()
  
    # Below could be done, but would be redundant, since our logger
    # (set_logging) already does this.
    #
    # opt_keys = [opt_key for opt_key in opts.__dict__.keys() \
    # if opt_key not in [foo.opt_parse_destination \
    # for foo in self.field_settings.values() if foo.opt_parse_destination i
    # opt_keys.sort()
    # log.debug("# -- GLOBAL")
    # for opt_name in opt_keys:
    # value = opts.__dict__[opt_name]
    # log.debug("ARGUMENT OPTIONS [GLOBAL] %s: %s" % (opt_name,value))
    # log.debug('-'*80)
  
    errors = []
    if hasattr(opts,'action') and opts.action and trim(opts.action).strip():
      opts_action = trim(opts.action)
    else:
      opts_action = None
  
    if hasattr(opts,'section_name') and opts.section_name and \
    trim(opts.section_name).strip():
      opts_section_name = trim(opts.section_name)
    else:
      opts_section_name = None
  
  
    if sections:
      for section_name, section in sections:
        if opts_section_name and \
        opts_section_name.lower()==section_name.lower():
          # a section was specified on the command line, so we are only goin
          # to handle this one, skipping all others.
          if opts_action and opts_action.lower() != 'ignore':
            # keep going, we aren't being told to ignore
            # so if it did say ignore in the config, they just overrode it.
            # so go ahead and pass through, allowing validation below to occ
            pass
          elif trim(section.get('action','use')).lower() == 'ignore':
            # STDIN command line action was not overridden, and the config f
            # says ignore, so we should continue on to the next section,
            # skipping this one.  they did not tell the STDIN to ignore, and
            # the config file says to ignore, so we will skip
            continue
        elif opts_section_name:
          # as I said above, a section was specified on the command line, so
          # continue over this one, because this one's name isn't the same a
          # the one specified.
          # it was specified on STDIN and it isn't the one we are in
          continue
        else:
          # a section was not specified on the command line, so we should
          # validate all of them
  
          # including global?
          if sparce:
            for config_name in field_keys:
              try:
                value = self.validate_opt(config_name,None)
              except (EmptyString, ConfigurationError) as er:
                conjoin(er,errors)
                #[log.error(e) for e in errors if e]
                #sys.exit(1)
              else:
                log_value = value
                if config_name.upper() in ('PASSWD','PASSWORD','PASS',
                'CLOUD_CHECKER_ACCESS_KEY','SR_SECRET_ACCESS_KEY','DB_PASSWORD'):
                  log_value='*'*8
  
                log.debug("VALIDATED OPTIONS [GLOBAL] %s: %s" % \
                  (config_name,log_value))
  
                field = self.field_settings[config_name]
                if field.global_scope and (value != field.default_value):
                  self.config[config_name] = value
  
            #   #   #
  
        log.debug("# -- %s" % section_name)
  
        for config_name in field_keys:
          try:
            value = self.validate_opt(config_name,section_name)
          except (EmptyString, ConfigurationError) as er:
            conjoin(er,errors)
            #[log.error(e) for e in errors if e]
            #sys.exit(1)
          else:
            log_value = value
            if config_name.upper() in ('PASSWD','PASSWORD','PASS',
              'CLOUD_CHECKER_ACCESS_KEY','SR_SECRET_ACCESS_KEY','DB_PASSWORD'):
              log_value='*'*8

            log.debug("VALIDATED OPTIONS [%s] %s: %s" % \
              (section_name,config_name,log_value))
  
            field = self.field_settings[config_name]
            if (value != field.default_value or not sparce):
              if section_name not in self.config.keys():
                self.config[section_name] = {}
              self.config[section_name][config_name] = value
    else:
      # we either have the first new section ever for a config, or we are
      # editing the global scope of the config
  
      if opts_section_name:
        log.debug("# -- %s" % opts_section_name)
      else:
        log.debug("# -- GLOBAL SCOPE")
  
      for config_name in field_keys:
        try:
          value = self.validate_opt(config_name,opts_section_name)
        except (EmptyString, ConfigurationError) as er:
          conjoin(er,errors)
        else:
          log_value = value
          if config_name.upper() in ('PASSWD','PASSWORD','PASS'):
            log_value='*'*8
          if opts_section_name:
            log.debug("VALIDATED OPTIONS [%s] %s: %s" % \
              (opts_section_name,config_name,log_value))
          else:
            log.debug("VALIDATED OPTIONS [GLOBAL] %s: %s" % (opt,log_value))
  
          field = self.field_settings[config_name]
          if ((not opts_section_name and field.global_scope) or \
          opts_section_name) and (value != field.default_value or not sparce):
            if opts_section_name:
              if opts_section_name not in self.config.keys():
                self.config[opts_section_name] = {}
              self.config[opts_section_name][config_name] = value
            else:
              self.config[config_name] = value

    if errors:
      [log.error(e) for e in errors if e]
      sys.exit(1)
  
    log.debug('-'*80)

  # ########################################################################
  # ########################################################################
  # ########################################################################
  
  def ensureLoaded(self):
    """ self explanitory, load, load now, whatever you can."""  
    if self.config == None:
      if self.exists:
        self.config = self.getConfig()
      else:
        self.config = {}

  def __getitem__(self, key):
    self.ensureLoaded()
    return self.config[key]
  
  def values(self):
    self.ensureLoaded()
    return self.config.values()

  def keys(self):
    self.ensureLoaded()
    return self.config.keys()

  def load(self, force=False):
    """ (alias for getCOnfig)
    """
    return self.getConfig(force)

  def getConfig(self, force=False):
    self.config = COBJ.load(self.filename, force)
    self.set_exists()
    return self.config

  def saveConfig(self, opts=optparse.Values, section_name=None):
    global log
    if opts:
      self.opts = dict(opts.__dict__.items())

    self.config = self.getConfig(True)

    if section_name:
      section_name=section_name.strip()
      try:
        config = self.config[section_name]
      except KeyError as e:
        self.config[section_name] = {}
        config = self.config[section_name]
    else:
      log.debug("No section_name provided, saving globally.")
      config = self.config
  
    if self.field_settings:
      errors = []
      for config_name, field in self.field_settings.items():
        try:
          value = self.validate_opt(config_name,section_name)
        except (EmptyString, ConfigurationError) as er:
          conjoin(er,errors)
        else:
          if not field.prompt or (field.prompt and getInputYN("Are you sure you wish to save the %s?" % field.title,
                "This is not encrypted, and will be stored in plain text.")):
            config[config_name] = value
          else:
            log.debug("User choose not to save %s" % field.title)

        if type(value) == type(None) and type(field.cast) != type(value):
          if type(field.cast) is type(int) and value == 0 and value is not None:
            pass
          else:
            log.debug("removing %s from config code 6579" % config_name)
            del config[config_name]
        
      if errors:
        [log.error(e) for e in errors if e]
        sys.exit(1)

      if not section_name:
        self.config.update(config)
      else:
        self.config[section_name].update(config)
      self.config.save()

    else:
      # beginning of the old way XXX-TODO this will need phased out
      if self.fields:
        for k in self.opts.keys():
          if self.opts[k] is None or k not in self.fields:
            del self.opts[k]

        for fld in config.keys():
          sub = config[fld]
          if str(type(sub)) == "<class 'pylib.configobj.Section'>":
            pass
          elif self.exists and fld not in self.fields:
            del config[fld]
        
        for prompt in self.prompts:
          if self.opts.get(prompt, None) is not None:
            if not getInputYN("Are you sure you wish to save the %s?" % prompt,
                "This is not encrypted."):
              if prompt in self.opts.keys():
                del self.opts[prompt]
              if self.exists and prompt in config.keys():
                del config[prompt]
        # END of old way XXX
      
      if not section_name:
        self.config.update(self.opts)
      else:
        config.update(self.opts)
        self.config.save()

    try:
      if opts.debug:
        log.debug("Saving options to: '%s'" % self.filename)
    except (AttributeError, NameError) as e:
      pass


class ConfigField(odict,dict):

  _defaults = dict(default_value=None, global_scope=True, inherited=True, \
  cast='str', option=None,required=True, extendable=False, updateable=False, \
  utype=None,prompt=False,config_name=None, title_override=None)
  #_defaults = {}

# _utype=None

  # --------------------------------------------------------------------------#
  # begin properties
  """
  # additional properties that can be set inline
  # Lists
  def set_extendable(self,extendable):
    ''' So the field cast is a list, and it may inherit from the parent
  sections, i.e. the global config section.  Great, does the global list get
  completly replaced if a section value is found, or does the list get
  extended? '''
    self._extendable=bool(extendable)
  def get_extendable(self): return self._extendable
  extendable = property(get_extendable, set_extendable)

  # Dicts
  def set_updateable(self,updateable):
    ''' So the field cast is a dict, and it may inherit from the parent sections,
  i.e. the global config section.  Great, does the global dict get completly
  replaced if a section value is found, or does the list get extended? '''
    self._updateable=bool(updateable)
  def get_updateable(self): return self._updateable
  updateable = property(get_updateable, set_updateable)
  """

  def set_update_type(self,utype=None):
    if (utype and type(utype) is type(str('')) and utype.lower.strip() in \
    ('parent','global','child')) or utype is None:
      self._utype=utype
    else:
      raise ProgrammingError("PyTis.ConfigField.update_type(): Invalid" \
      " value selected, please choose from 'parent', 'global', 'child', or None.")
  def get_update_type(self):
    return self._utype
  update_type = property(get_update_type,set_update_type)

  # end properties
  # --------------------------------------------------------------------------#

  def __init__(self,dict,other={}):
    odict.__init__(self,dict)
    if other:
      self._defaults = other

    if type(self.config_name) != type(str('')) or not self.config_name.strip():
        raise ProgrammingError('The first argument, the "config name" is ' \
        'required.')

    if 'title_override' not in self.keys() or not self['title_override']:
      self['title']=self.config_name.replace('_',' ').replace('-',' ').strip().title()
    elif self.title_override:
      self['title'] = self.title_override.strip()

  def __getitem__(self, key):
    # check the first place to look, self as dictionary
    if self.has_key(key): ###
      return odict.__getitem__(self,key)
    # check default dictionary
    elif self._defaults.has_key(key):
      return self._defaults.get(key)
    # do we have it as an attribute?
    try:
      return dict.__getattribute__(self,key)
    except AttributeError:
      raise KeyError(key)

  def __setattr__(self, attr, val):
    if attr in ('_keys', '_defaults','data'):
      return dict.__setattr__(self, attr, val)
    else:
      dict.__setattr__(self, attr, val)
      UserDict.__setitem__(self, attr, val)
      if attr not in self._keys: self._keys.append(attr)
      return

  # --------------------------------------------------------------------------#

def config_file():
  global __configdir__
  return "%s.ini" % os.path.abspath(os.path.join(__configdir__, \
    os.path.basename(sys.argv[0])))

def load_config(config_file=config_file()):
  global config
  config = COBJ.load(config_file, True)
  return config


# ============================================================================#
class MyLogger(logging.Logger):
  opt_debug = False
  opt_full_verbose = False

  # opt_verbose = False
  # 0,1,2,3,4:0=quiet,1=verbose,2=more verbose,3=most verbose,4=debug & verbose
  opt_verbose = 0

  opt_had_verbose = False
  opt_quiet = False
  had_error = False
  had_warning = False
  paused = False

#  def Pause(self):
#    return self.pause()

  def pause(self):
    self.paused = True
  Pause=pause

  def unPause(self):
    self.paused = False

  def setopts(self, opts):
    try:
      self.opt_full_verbose = opts.totally_verbose
    except AttributeError as e:
      try:
        self.opt_full_verbose = opts.verbose
      except AttributeError as e:
        pass
    else:
      if not opts.totally_verbose:
        self.opt_full_verbose = False

    try:
      self.opt_verbose = opts.verbose
      if type(opts.verbose) is type(bool(1)) and self.opt_verbose:
        self.opt_verbose=1

    except AttributeError as e:
      pass

    try:
      self.opt_debug = opts.debug
    except AttributeError as e:
      pass

    try:
      self.opt_quiet = opts.quiet
    except AttributeError as e:
      pass

    try:
      self.opt_had_verbose = opts.had_verbose
    except AttributeError as e:
      pass
  # setting an Alias
  setOpts=setopts

  @property
  def hadWarning(self):
    return self.had_warning
  # setting an Alias
  hadWarnings=hadWarning

  @property
  def hadError(self):
    return self.had_error
  # setting an Alias
  hadErrors=hadError

  '''
  def debug
  def info
  def warn
  def error
  def critical
  def fatal
  '''

  def debug(self, msg, *args, **kwargs):
    if self.opt_full_verbose and self.opt_debug and not self.opt_quiet:
      print( msg)
    return logging.Logger.debug(self, msg, *args, **kwargs)
    
  def info(self, msg, *args, **kwargs):
    # if self.opt_verbose:
    if not self.opt_quiet:
      print(msg)
    return logging.Logger.info(self, msg, *args, **kwargs)

  def info1(self, msg, *args, **kwargs):
    if self.opt_verbose >= 1:
      print(msg)
    return logging.Logger.info(self, msg, *args, **kwargs)

  def info2(self, msg, *args, **kwargs):
    if self.opt_verbose >= 2:
      print(msg)
    return logging.Logger.info(self, msg, *args, **kwargs)

  def info3(self, msg, *args, **kwargs):
    if self.opt_verbose >= 3:
      print(msg)
    return logging.Logger.info(self, msg, *args, **kwargs)

  def info4(self, msg, *args, **kwargs):
    if self.opt_verbose >= 4:
      print(msg)
    return logging.Logger.info(self, msg, *args, **kwargs)

  def warn(self, msg, *args, **kwargs):
    logging.Logger.warn = logging.Logger.warning
    return self.warning(msg, *args, **kwargs)

  def warning(self, msg, *args, **kwargs):
    self.had_warning = True
    if not self.opt_quiet:
      print('WARNING: %s' % msg)
    return logging.Logger.warning(self, msg, *args, **kwargs)

  def error(self, msg, *args, **kwargs):
    self.had_error = True

    sys.stderr.write("%s%s\n" % (('' if kwargs.get('exc_info',None) else \
      'ERROR: ') ,msg))

    return logging.Logger.error(self, msg, *args, **kwargs)

  def critical(self, msg, *args, **kwargs):
    self.had_error = True

    # if kwargs.get('exc_info',None): sys.stderr.write("%s\n" % msg)
    # else: sys.stderr.write("CRITICAL: %s\n" % msg)

    sys.stderr.write("%s%s\n" % (('' if kwargs.get('exc_info',None) else \
      'CRITICAL: ') ,msg))

    return logging.Logger.critical(self, msg, *args, **kwargs)

  def fatal(self, msg, *args, **kwargs):
    self.had_error = True

    #if kwargs.get('exc_info',None): sys.stderr.write("%s\n" % msg)
    #else: sys.stderr.write("FATAL: %s\n" % msg)

    sys.stderr.write("%s%s\n" % (('' if kwargs.get('exc_info',None) else \
      'FATAL: ') ,msg))

    logging.Logger.fatal(self, msg, *args, **kwargs)
    sys.exit(1)

  def _log(self, level, msg, args, exc_info=None):
    """
    Low-level logging routine which creates a LogRecord and then calls
    all the handlers of this logger to handle the record.
    """
    global python_version
    if self.paused:
      return

    #if level == logging.DEBUG and self.opt_verbose and self.opt_debug:
    #  print msg
    #if level == logging.DEBUG and self.opt_full_verbose and self.opt_debug:
    #if level == logging.DEBUG and self.opt_verbose and self.opt_debug:

    if logging._srcfile:
      if python_version >= 3.0:
        fn, lno, func, stack_info  = self.findCaller()
      else:
        fn, lno, func  = self.findCaller()
    else:
      fn, lno, func = "(unknown file)", 0, "(unknown function)"
    if exc_info:
      if type(exc_info) != types.TupleType:
        exc_info = sys.exc_info()

    record = self.makeRecord(self.name, level, fn, lno, msg, args, exc_info)
    self.handle(record)

# ============================================================================#
class MyParser(optparse.OptionParser):
  extra_txt = None
  helpishere = False
  py_args = []
  py_opts = []
  """
  The below variable is new, but I want to have backwards compatability.  If
  you turn this variable on, and make set it to True then the print_help will
  hide the default help page which lists well formatted options and their help
  messages.  I choose to do this because while in the extra_txt, I usually
  provide additional help, in the current program I am working on the
  extra_txt represents an entire man page with greater detail on each
  individual option.  Therefore I do not wish to show the built-in,
  auto-generated help message as well.  Lastly, you won't actually set this
  variable directly, I am creating a setter and getter method to treat it as a
  property, which you should find under the __init__.  
  """
  _full_help_available = False

  def setFullHelpAvaiable(self):
    self._full_help_available=True

  '''
  def set_helpishere(self,b=True):
    self._full_help_available=b
  def get_full_help_available(self):
    return self._full_help_available
  full_help_available = property(get_full_help_available, set_full_help_available)
  '''

  def set_full_help_available(self,b):
    self._full_help_available=b
  def get_full_help_available(self):
    return self._full_help_available
  full_help_available = property(get_full_help_available, 
    set_full_help_available)

  def __init__(self,
               usage=None,
               option_list=None,
               option_class=optparse.Option,
               version=None,
               conflict_handler="error",
               description=None,
               formatter=None,
               add_help_option=True,
               prog=None,
               epilog=None):

    optparse.OptionParser. __init__(self,
               usage, option_list, option_class, version, conflict_handler, 
               description, formatter, add_help_option, prog, epilog)


  def print_out(self, txt):
    try:
      import curses
      #txt = txt.replace("`$","\n")
      txt = txt.replace("`$","\n                     ")
      #txt = txt.replace(":\n",":\n\n")
      win=curses.initscr()
      max_x, max_y = win.getmaxyx()
      curses.endwin()
      if len(txt.split("\n")) > max_x:
        pager = pydoc.getpager()
        try:
          pager(txt)
        except (EOFError, KeyboardInterrupt) as e:
          pass
      else:
        sys.stdout.write("%s\n" % txt)
    except:
      pager = pydoc.getpager()
      try:
        pager(txt)
      except (EOFError, KeyboardInterrupt) as e:
        pass
      sys.stdout.write("%s\n" % txt)


  def print_help(self, errors=None):
    """
    NAME
    SYNOPSIS
    DESCRIPTION
    OPTIONS
    COMMANDS
    ENVIRONMENT
    SEE ALSO
    AUTHOR
    HISTORY
    VERSION
    """
    buf = StringIO()
    sys.stdout = buf

    # The user did not enter --help, they only entered -h, show short help and
    # instructions on howto view full help.
    if '--help' not in sys.argv and self.extra_txt is not None:
      # print the short usage.
      self.set_usage("%s\n%s" % (self.get_usage(), "*** USE '--help' for the full help page. ***"))

    # If NOT (--help was typed in, and there is extra_text to show, and
    # full_help_available)
    if not ('--help' in sys.argv and self.extra_txt is not None and 
      self.full_help_available):
      # print help as the OptionParser normally would, without extra goodies
      optparse.OptionParser.print_help(self)


    extras = ''
    if '--help' in sys.argv and self.extra_txt is not None and errors is None:
      """
      try: extras = "Created: %s\n" % __created__
      except NameError: pass
      try: extras = "%sAuthor: %s\n" % (extras,__author__)
      except NameError: pass
      try: extras = "%sCopyright: %s\n" % (extras,__copyright__)
      except NameError: pass
      try: extras = "%sVersion: %s\n" % (extras,__version__)
      except NameError: pass
      if extras:
        self.extra_txt = "\n%s\n\n%s" % (self.extra_txt, extras)
      """
      #print self.extra_txt
      self.print_out(self.extra_txt)

    if not errors:
      errrors = []
    elif not isinstance(errors, list):
      errors = [errors]

    sys.stdout = sys.__stdout__
    # XXX:TODO - 2 Weeks ago I was writing a ManPage builder.  Afer looking
    # back at this method I wrote years ago.  I realized it would be easy to
    # alter this code just slightly to have it generate manpages.  It may be
    # better to just add a similar method for generating manpages, easier than
    # what I was doing.
    self.print_out(buf.getvalue().replace("Options:\n","OPTIONS:\n").replace(":\n",":\n\n"))
    #txt = txt.replace(":\n",":\n\n")

    if errors:
      sys.stderr.write("\n")
      for error in errors:
        sys.stderr.write(wrap("ERROR: %s\n" % error))
    sys.stderr.flush()

      # FIXME - this was in python3, does it return in python2?
#    return bool(errors)

# ============================================================================#
class Callback(object):
  def __init__(self):
    self.cb = None
    self.a = [] 
    self.k = {}

  def setCallback(self,cb): self.cb=cb
  def getCallback(self): return self.cb
  def setArgs(self,*a): self.a=a
  def getArgs(self): return self.a
  def setKwArgs(self,**k): self.k=k
  def getKwArgs(self): return self.k


class ImmutableDict(UserDict):
  """ This is a dictionary that enforces as set once and only once policy.
  Then if you try to overwrite a key with a new value, it will still maintain
  it's original value.

  The one and only option that gives this any flexibility, is to allow keys
  with empty values (None or '') to be re-assigned non-empty values, however
  this feature must be enabled.

  """
  _reassign_empties = False

  #@property
  #def 
  
  def allowEmptyReset(self):
    self.reassign_empties = True

  @property
  def emptyReset(self):
    return self._reassign_empties

  def set_reassign_empties(self, b):
    self._reassign_empties =b 
  def get_reassign_empties(self):
    return self._reassign_empties
  reassign_empties = property(get_reassign_empties, set_reassign_empties)

  def __init__(self, **kwargs):
    """ # Start by filling-out the abstract methods
    """
    self._keys = []
    UserDict.__init__(self, dict(kwargs))

  def __delitem__(self, key):
    """ # We must override this in order to delete the key from our list of
    keys set on self._key.  First we will call the parent, and finally we will
    remove our own reference to the key.
    """
    UserDict.__delitem__(self, key)
    self._keys.remove(key)

  def __setitem__(self, key, item):
    """ key:hashable item
        item: value to assign
    """
    if key in self._keys: 
      if not self.reassign_empties: return
      else:
        old_item = self.__getitem__(key)
        if old_item is None or (type(old_item) is str and old_item == ''):
          pass
        else: return

    UserDict.__setitem__(self, key, item)
    if key not in self._keys: self._keys.append(key)

  def setdefault(self, key, failobj = None):
    """ D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
    """
    if key in self._keys: 
      if not self.reassign_empties: return
      else:
        old_item = self.__getitem__(key)
        if old_item is None or (type(old_item) is str and old_item == ''):
          pass
        else: return

    UserDict.setdefault(self, key, failobj)
    if key not in self._keys: self._keys.append(key)

# ============================================================================#
#
class StopWatch():
  # the exact time this class was initialized, or time since reset was called.
  t = 0
  # there is a way to pause this, I don't know why I coded it, I'm not going
  # any further (adding in start, restart, etc.).
  _stopped=False
  # do you want this to show the total time since initialized, or since last
  # used?  If since last used, then pass True into the instance as you
  # initialize it.
  reset_each_call=False

  # decimals is used when formatting the output to be more "human-readable"
  decimals=4

  def __init__(self,reset_each_call=False):
    """
    The intention is for this class's instance to be treated as almost a
    singleton.  Look closely at the internal methods that I am overridding.
    Example usage:
      sw = StopWatch()
      print(dosomething(), sw)
      print(dosomething_else(), sw)
      print(and_done(), sw)

    Example (copy/paste) of REAL output:

     --> ./dynamodb.py
 >> Event Id: 07c3cbee-ec83-4451-963c-d80d85000ef6...0.0 Âµ microseconds..
 >> DynamoDB auto remediation function has been called 0.0001 Âµ microseconds
 >> obtaining dynamodb client - 7.6639 seconds
 >> obtaining dynamodb resource - 23.67544174 miliseconds OR 0.0237 seconds
 >> grabbing 'test_users' to read - 14.90569115 miliseconds OR 0.0149 seconds
 >> dynamodb.Table(name='test_users')
 >> describing table 'test_users' - 2.56061554 miliseconds OR 0.0026 seconds



    """
    self.t=time.time()
    self.reset_each_call=reset_each_call

  def __call__(self):
    """
    this could be a shortcut to stop or reset this timer
    """
    pass

  def __str__(self):
    """
    Print the time as a string (human readable / formatted)
    """
    return self.beautify(self.read())

  def __repr__(Self):
    """
    Print the time as a string (unformatted)
    """
    return self.read()

  def read(self):
    if self._stopped:
      return self.t
    else:
      if self.reset_each_call: 
        r=(time.time()-self.t)
        self.reset()
        return r
      return (time.time()-self.t)

  def reset(self):
    self.t=time.time()
    self._stopped=False

  def stop(self):
    self.t=time.time()-self.t
    self._stopped=True

  def beautify(self, t):
    """
    Make the output human friendly / readable.  
    Examples of Output:
      > 14.8730278 miliseconds OR 0.0149 seconds
      > 24.6193409 miliseconds OR 0.0246 seconds
      > 16.13354683 miliseconds OR 0.0161 seconds
      > 0.2569 seconds
      > 20.0882 seconds
    """
    t=float(t)

    if t > 0.1: return "%s seconds" % round(t, self.decimals)

    if t >= 0.001:
      if float(t) == float(0.001): label = ''
      else: label = 's'
      return "%s milisecond%s OR %s seconds" % (round(1000*t, self.decimals+4),
        label, round(t, self.decimals))

    if t >= 0.000001:
      if float(t) == float(0.000001): label = " Âµs microsecd"
      else: label = 'Âµ microseconds'
      return "%s %s" % (round(t,4), label)


# #############################################################################
# Util functions Below
# #############################################################################

def column_from_csv_file(fname, headers=False, col=0):
  col=column(col)
  lines=parse_csv_file(fname, headers) 
  return list(itertools.izip_longest(*lines))[col]
  ret= list(itertools.izip_longest(*lines))[col]
  print(ret)
  return ret
    
def parse_csv_file(fname, headers=False):
  if hasattr(fname, 'readlines') and hasattr(fname, 'write') and \
  hasattr(fname, 'seek'):
    fname.seek(0)
    lines = fname.readlines(-1)
  else:
    try:
      handle = open(os.path.abspath(fname),'r')
    except PermissionError as e:
      raise PermissionError(e)
    except (IOError, OSError) as e:
      raise FileNotFound('CSV File not found: %s' % fname)
    else:
      lines = handle.readlines(-1)
  records=[parse(l) for l in lines if parse(l) is not None and len(parse(l))]
  if headers and records:
    del records[0]
  # I think we can just call del records[0] if headers but I want to test
  # this out a little first

  return records

def get_calling_file():
  """ Needs error checking """
  try:
    1/0
  except ZeroDivisionError:
    t = sys.exc_info()[2]
    return t.tb_frame.f_back.f_back.f_globals['__file__']
  return None

def calling_module():
  import inspect
  i=0
  while i < 10:
    try:
      frame,filename,line_number,function_name,lines,index=\
        inspect.getouterframes(inspect.currentframe())[i]
      if (filename != __file__):
        a=0
        b=0
        max_a=max_b=10
        while a < max_a: 
          try:
            frm = inspect.stack()[a]
          except IndexError as e:
            max_a = a
          mod = inspect.getmodule(frm[b])
          if mod.__file__ != __file__:
            return mod
          a+=1
          if a == max_a:
            a=0
            b+=1
          if b == max_b:
            break
    except IndexError as e:
      break
    i+=1
  return None

def getVersion(mod=None):
    if not mod: mod=calling_module()
    try:
        return mod.__version__
    except AttributeError as e:
        #print >> sys.stderr, "Version not found."
        sys.stderr.write("Version not found.\n")
    return 0.1

def printVersion(version=None):
    mod=calling_module()
    if not version: version=getVersion()
    print("%s v%s" % (os.path.basename(mod.__file__), getVersion()))
    return 0

def optional_arg(arg_default,choices=[]):
  if choices and arg_default not in choices:
    raise IdiotError("Your arg_default was not in your supplied list of choices.")
  def func(option,opt_str,value,parser):

    if value:
      print("VALUE FOUND: %s" % value)
      val=value
    else:
#      print(dir(parser))
      print("parser.rargs follows")
      pprint(parser.rargs)
      print("parser.largs follows")
      pprint(parser.largs)
      print("epilog follows:")
      pprint(parser.epilog)
      print("py_args follows:")
      pprint(parser.py_args)
      print("py_opts follows:")
      pprint(parser.py_opts)
      if parser.rargs and not parser.rargs[0].startswith('-'):
        val=parser.rargs[0]
        parser.rargs.pop(0)
      else:
        val=arg_default

      print("VALUE NOW IS: %s" % val)

    if choices and val not in choices:
      parser.print_usage()
      buf = []
      metavar = option.metavar or "[%s]" % str(option.dest).upper()
      if option._short_opts:
        buf.append("%s %s" % (option._short_opts[0], metavar) )
      if option._long_opts:
        buf.append("%s=%s" % (option._long_opts[0], metavar) )
      buf=', '.join(buf)

      print("option: %s" % option)
      print("opt_str: %s" % opt_str)
      print("value: %s" % value)
      print("parser: %s" % parser)
      print("buf: %s" % buf)
#-A [ACTION], --action=[ACTION]
      print("\n%s\n\t %s\n" % (buf,option.help))
      print("%s - ERROR: option %s: invalid choice: '%s' (choose from %s)" % (os.path.basename(sys.argv[0]),opt_str,val,','.join(["'%s'" % choice for choice in choices])))
      sys.exit(0)
      #x = ArgumentError(None,opt_str,val,choices)
      #raise x
# cryptwatch: error: option -a: invalid choice: 'foo' (choose from 'start', 'stop', 'restart', 'status')
    if not str(val).strip():
      val = '_empty_val_trick_'
    setattr(parser.values,option.dest,val)
  return func

def getInput(question, helptext='No help for this command',example_or_hint=None,default=None,required=False):
  """
  Full Name - press Enter for default: root
  if helptext:
    if required:
      Full Name [i.e. John Smith (required)]:
    else:
      Full Name [i.e. John Smith (or leave blank)]:
  else:
    if required:
      Full Name (required):
    else:
      Full Name:
  """

  if helptext == 'No help for this command' or not helptext.strip():
    h=''
  else:
    h = '/?'

  if example_or_hint:
    if required:
      txt = '%s %s%s ' % (question,example_or_hint,h)
    else:
      txt = '%s %s (or leave blank)%s ' % (question,example_or_hint,h)
  else:
    if default and required and not example_or_hint:
      example_or_hint='(default "%s")' % default
    txt = '%s %s%s ' % (question,example_or_hint,h)

  try:
    res = get_input("%s>>> " % (txt))
  except (KeyboardInterrupt,EOFError) as e:
    print("\nInvalid input, press 'q' to quit or 'h' for help.")
    return getInput(question,helptext,example_or_hint,default,required)

  if not res.strip() and required:
    if default:
      __option_always__ = [False]
      if getInputYN('Use default: %s?' % (default),
          'This will set the %s to the system default of "%s"' % (question,default),
          __input_options__,[]):
        return default
      else:
        if not example_or_hint: 
          example_or_hint='(default "%s")' % default
        return getInput(question,helptext,example_or_hint,default,required)

    else:
      print("\n")
      print('Nothing entered "%s" is required, please try again.' % question)
      print("\n")
      if not example_or_hint:
        example_or_hint='(default "%s")' % default
      return getInput(question,helptext,example_or_hint,default,required)

  if res.strip().lower() in ['h','?']:
    print("\nHELP (q to quit)" )
    print("\n\t? or "+'"h"'+" for this help")
    print("\ty for Yes")
    print("\tn for No")
    if helptext:
      if required:
        r="\t\tREQUIRED -\n "
      else:
        r=''
      print("\n%s" % fixWidth("%s%s"%(r,helptext)))
    return getInput(question,helptext,example_or_hint,default,required)
  if res.strip().lower() == 'q':
    raise QuitNow(question)
  else:
    return res


def getInputYN(question, helptext='No help for this command',
input_options=__input_options__,option_always=__option_always__):

  if len(option_always):
    if option_always[0]:
      return True
    if 'a' not in input_options:
      input_options.append('a')

  if helptext == 'No help for this command' or not helptext.strip():
    pass
  elif '?' not in input_options:
    input_options.append('?')
  options = '/'.join(input_options)

  try:
    res = get_input("%s [%s]>>> " % (question,options))
  except (KeyboardInterrupt,EOFError) as e:
    print("\nInvalid input, press 'q' to quit or 'h' for help.")
    if 'q' in input_options:
      if 'h' not in input_options:
        input_options.append('h')
    if 'q' not in input_options:
      input_options.append('q')
    return getInputYN(question,helptext,input_options,option_always)

  if not res.strip():
    print( "Nothing entered, please try again.")
    return getInputYN(question, helptext,input_options,option_always)
  if len(option_always) and res.strip().lower() == 'a':
    option_always[0] = True
    return True
  if res.strip().lower() == 'y':
    return True
  if res.strip().lower() == 'n':
    return False
  if res.strip().lower() in ['h','?']:
    print( "\n\t? or h for this help" )
    print( "\ty for Yes")
    print( "\tn for No")
    if len(option_always):
      print('\ta for always (skipping prompt from now on, always assuming yes.)')
    print ("\nHELP (q to quit): \n%s\n" % wrap(helptext))
    return getInputYN(question, helptext,input_options,option_always)
  if res.strip().lower() == 'q':
    raise QuitNow #, question
  else:
    print ("Invalid input, please try again.")
    return getInputYN(question, helptext,input_options,option_always)

def to80(s): return fixWidth(s)

def wrap(text, width=79):
  """
  A word-wrap function that preserves existing line breaks
  and most spaces in the text. Expects that existing line
  breaks are posix newlines (\n).
  """
  global python_version
  if python_version >= 3.0:
    return functools.reduce(lambda line, word, width=width: '%s%s%s' % (line,
    ' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0])>=width)],
    word), text.split(' '))
  else:
    return reduce(lambda line, word, width=width: '%s%s%s' % (line,
    ' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0])>=width)],
    word), text.split(' '))


def fixWidth(st):
  buf = list(st.split(" "))
  lines = []
  cur = ''
  for word in buf:
    if word=="\n":
      lines.append(cur)
      cur = ''
    elif len('%s %s' % (cur, word)) >= 79:
      lines.append(cur)
      cur = ''
    if cur:
      cur = "%s %s" % (cur,word)
    else:
      cur = word
  if cur:
    lines.append(cur)
  return "\n".join(lines)

def version(v):
  print("%s version: %s" % (os.path.basename(sys.argv[0]), v))

def set_logging(opts, name, quiet=False, __logdir__=__logdir__):
  global log
  if opts.debug:
    level=logging.DEBUG
    log_file = '%s.log' % name
  else: 
    level=logging.INFO
    log_file = 'pytis_tools.log'
  if python_version >=3:
    logging.basicConfig(
      filename = os.path.abspath(os.path.join(os.path.abspath(__logdir__), 
        log_file )),
      level=level,
      format='%(asctime)s.%(msecs)03d %(name)-10s %(levelname)-8s ' \
        '[PID: %(process)d]  %(message)s',
      datefmt="%Y%m%d %H:%M:%S")
  else:
    logging.basicConfig(
      name=name,
      filename = os.path.abspath(os.path.join(os.path.abspath(__logdir__), 
        log_file )),
      level=level,
      format='%(asctime)s.%(msecs)03d %(name)-10s %(levelname)-8s ' \
        '[PID: %(process)d]  %(message)s',
      datefmt="%Y%m%d %H:%M:%S")

  logging.setLoggerClass(MyLogger)
  log = logging.getLogger(name)
  log.setopts(opts)

  try:
    version = opts.version
  except AttributeError as e:
    version = False
  try:
    totally_verbose = opts.totally_verbose
  except AttributeError as e:
    totally_verbose = True
  
  if not quiet and version != True and totally_verbose:
    log.info("Starting %s at %s" % (name,prettyNow())) 

  # BEGIN TRICK
  # From here to the next comment is a trick to allow the log message to goto
  # only a log file, and not make it to the screen of a user.
  # we MIGHT be using this trick again, depends on the overall verbosity, look
  # further down this function for the next occurance of sys.stdout  
  buf = StringIO() 
  sys.stdout = buf
  log.info("STARTING: %s" % name)
  sys.stdout = sys.__stdout__
  del buf
  # END TRICK

  if not totally_verbose:
    # we may be using this trick again, depends on the overall verbosity, look
    # further down this function for the next occurance of sys.stdout  
    buf = StringIO()
    sys.stdout = buf

  relogOpts(opts, "Options parsed from STDIN")

  if not totally_verbose:
    # and now we end our little second utilization of the output override trick.
    sys.stdout = sys.__stdout__
    del buf
  return log


def relogOpts(opts, msg=None, also_protect=[]):
  """ After all config file loading, option parsing and data crunching  has 
      been completed, ths function will re-log to debug all options gathered,
      so we  can see what their values are.
  """
  global log, protected_options
  protect_these = [x for x in protected_options]
  if type(also_protect) is type(str('')): also_protect=[also_protect]
  protect_these.extend(also_protect)
  
  log.setopts(opts)
  #opts.ip_addresses=PyTis.unique(opts.ip_addresses)

  # I want the output alphabatized, so I am going to create a list of tuples,
  # sort them, no wait, you know what would be faster? to just grab the keys,
  # sort those, request each value by key.

  log.debug('-'*80) 
  if msg: 
    log.debug(msg)
  opt_keys = list(opts.__dict__.keys())
  opt_keys.sort()
  for opt in opt_keys:
    value = opts.__dict__[opt]

    if type(value) == type(str('')):
      # function optional_arg utilizes this feature.
      if value.strip() == '_empty_val_trick_': value = ''
      if str(opt).lower() in protect_these: value = protect(value)
      if not value: value = "''"
      
    log.debug("OPTION %s: %s" % (opt,value))

  log.debug('-'*80) 
  return

def is_root():
  return bool(getpass.getuser()=='root')

def homedir():
  """ Get Home directory path in Python for Windows and Linux
  """
  #homedir = os.path.expanduser('~')
  # ...works on at least windows and linux. 
  # In windows it points to the user's folder 
  #  (the one directly under Documents and Settings, not My Documents)
  # In windows, you can choose to care about local versus roaming profiles.
  # You can fetch the current user's through PyWin32.
  #
  # For example, to ask for the roaming 'Application Data' directory:
  #  (CSIDL_APPDATA asks for the roaming, CSIDL_LOCAL_APPDATA for the local one)
  #  (See microsoft references for further CSIDL constants)
  try:
    from win32com.shell import shellcon, shell
    homedir = shell.SHGetFolderPath(0, shellcon.CSIDL_APPDATA, 0, 0)
  except ImportError: # quick semi-nasty fallback for non-windows/win32com case
    homedir = os.path.expanduser("~")
  return homedir

def timestamp(full=False):
  if full: return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f") 
  else: return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") 

def fileModified(path):
  return time.strftime("%Y-%m-%d %H:%M:%S.%s",
  time.localtime(os.path.getmtime(path)))
  
def fileCreated(path):
  return time.strftime("%Y-%m-%d %H:%M:%S.%s", 
   time.localtime(os.path.getctime(path)))
  
def prettyNow():
  return datetime.datetime.now().strftime("%I:%M%%s %m %b, %Y") % datetime.datetime.now().strftime("%p").lower()

def fileStampNow():
    return datetime.datetime.now().strftime("%Y%m%d_%H%M")

def testFind(path):
  """
  """
  f=[]
  for root, dirs, files in os.walk(os.path.abspath(path), topdown=False):
    for name in dirs:
      fpath = os.path.abspath(os.path.join(root,name))
      for fname in glob.glob(os.path.join(fpath, '*.png')):
        f.append(fname)
  pprint(f)
  return f

def filesFromPath(path, cd=os.curdir, recursive=False):
  """ allows me to call once per path (with or without wildcards)
  """
  global log
  arg=path
  files = []
  cmd = None
  if recursive:
    re = ''
  else:
    re = '-maxdepth 1'


  if os.path.isfile(arg) and os.path.exists(arg):
    files.append(arg)
  elif ('/' in arg or '\\' in arg):
    if (os.path.isfile(os.path.abspath(os.path.join(cd,arg))) and os.path.exists(os.path.abspath(os.path.join(cd,arg)))):
      files.append(os.path.abspath(os.path.join(cd,arg)))
      return files
    elif(os.path.isdir(os.path.abspath(os.path.join(cd,arg))) and os.path.exists(os.path.abspath(os.path.join(cd,arg)))):
      if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
        arg = "'%s'" % arg
      cmd = "find %s %s" % (re,os.path.abspath(arg))
    else:
      if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
        arg = "'%s'" % arg
      cmd = "find %s %s" % (re,arg)
  elif arg == '.':
    if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
      arg = "'%s'" % arg
    cmd = "find . * %s" % re
  else:
    if '*' in arg and (not arg.startswith('"') or not arg.startswith("'")):
      arg = "'%s'" % arg
    cmd = "find . %s -type f -iname %s | egrep -v '.svn|.git'" % (re,arg)

  if cmd:
    log.debug("CMD IS: %s" % cmd)
    cmd_out = os.popen(cmd).readlines(-1)
    for line in cmd_out:
      line = line.strip()
      if line and os.path.abspath(line) not in files \
        and os.path.isfile(line) and os.path.exists(line):
        files.append(os.path.abspath(line))
  return files
  

def filesFromArgs(opts, args):
  """ 
  XXX:TODO unix only, need to make this so it would work on windows.
  XXX:TODO this thing needs serious work, with recursive an no . in filenames
  import glob
  """
  global log
  files = []
  for arg in args:
    if os.path.isdir(arg):
      files.extend(filesFromPath(path=arg,recursive=opts.recursive))
    else:
      files.append(arg)
  return files

def testFile(f):
  # ensure it is a valid real existing file 
  try:
    if not f.strip(): 
      raise NoFiles('An empy string was passed in, no file to test.')
      #return False
  except AttributeError as e:
    if "int' obj" in str(e):
      # a number was passed in instead of a string respresentation of a file
      # path.
      raise ArgumentError('An integer was provided instead of a file to test.')
    if "float' obj" in str(e):
      raise ArgumentError('A number was provided instead of a file to test.')
    if "NoneType' obj" in str(e):
      raise ArgumentError('Nothing was passed in, expecting a file path ' \
        'to test.')
    if "file' obj" in str(e):
      # they passed a file in, it may very likely have a valid path.
      f = os.path.abspath(f.name)
      # technically, we could say f=f.name because of the next line down, but
      # to make what is happening easier to understand... we do it like this.
    
  f = os.path.abspath(f)
  try:
    if not os.path.exists(f) or not os.path.file(f):
      return False
  except PermissionError as e:
    raise PyTis.PermissionError(e)
  except IOError as e:
    if 'Permission denied' in str(e):
      raise PyTis.PermissionError(e)
    return False
  except (IOError, OSError) as e:
    return False
    #raise FileNotFound('File not found: %s' % f)
  else:
    return True

def fileTest(f):
  # ensure it is a valid real existing file 
  if not f.strip(): return False
  f = os.path.abspath(f)
  if not os.path.exists(f) or not os.path.file(f): return False
  return True

def dirTest(d):
  # ensure it is a valid real existing directory 
  if not d.strip(): return False
  d = os.path.abspath(d)
  if not os.path.exists(d) or not os.path.isdir(d): return False
  return True

def toContinue(prefix=''):
  """ Prompt the user to press a key to continue. Should probably use a pager
  most of the time though.
  """
  if sys.platform in ('win32', 'win64'):
    os.system('PAUSE')
    sys.stdout.write("\n")
  elif sys.stdin.isatty():
    import tty
    if prefix.strip():
      sys.stdout.write("\n%s\n" % prefix)
    sys.stdout.write("Press any key to continue . . .\n")
    tty.setraw(sys.stdin.fileno())
    try:
      sys.stdin.read(1)
    finally:
      os.system("stty sane")
    sys.stdout.write("\n")
  return
def _done():
  return toContinue('done.')
toContinue.done=_done

def dos2unix(thing):
  """
    This will take in 3 types of input, 
    a list of strings
    a string
    or the path to a file to fix.

    If your input is a file path, it will clean up the file (dos2unix)
    
    If your input is a string, it will clean the string and return the cleaned
    input.

    If your input is a list, it will clean each line, and return a new list.
  """
  if type(thing) is type('') and os.path.isfile(thing) and \
  os.path.exists(thing):
    try:
      handle = open(thing,'r')
      contents = handle.read(-1)
      handle.close()
      nhandle = open(thing,'w')
      nhandle.write(contents.replace("\r$","").replace("\r",''))
      nhandle.close()
    except Exception as e:
      sys.stderr.write("thing is fpath in dos2unix error here.\n")
      raise e

  if type(thing) is type(''):
    try:
      return thing.replace("\r\n","\n")
    except Exception as e:
      sys.stderr.write("thing is string in dos2unix error here.\n")
      raise e

  if type(thing) is type([]):
    try:
      lines = []
      for line in thing:
        lines.append(line.replace("\r\n","\n"))
      return lines 
    except Exception as e:
      sys.stderr.write("thing is list in dos2unix error here.\n")
      raise e

  raise ProgrammerError("This function (PyTis.dos2unix) requires list " \
    "or string or file path as input but a %s was passed in." % \
    repr(type(thing)))

def clearScreen():
  sys.stdout.write("\n")
  if sys.platform in ('win32', 'win64'):
    os.system('cls')
  elif sys.stdin.isatty():
    os.system('clear')
  return

def hello():
  import inspect
  i=0
  while i < 10:
    try:
      #print 'i',i
      frame,filename,line_number,function_name,lines,index=\
        inspect.getouterframes(inspect.currentframe())[i]
      print( 'frame', frame)
      print( 'filename', filename)
      print( 'line_number',line_number)
      print( 'function_name',function_name)
      print( 'lines',lines)
      print( 'index',index)
      print( 'basename of filename', os.path.basename(filename))
      print( '__file__', __file__)
      if (filename != __file__):
        a=0
        b=0
        max_a = 5
        while a < max_a: 
          try:
            frm = inspect.stack()[a]
          except IndexError as e:
            max_a = a

          print(dir(frm))

          mod = inspect.getmodule(frm[b])
          if '__FINDME__' in dir(mod):
            print( '='*80)
            print( sys.argv[0])
            print( 'FOUND IT')
            print( 'filename', filename)
            print( 'i', i)
            print( 'a', a)
            print( 'b', b)
            print( 'FINDME = ', mod.__FINDME__)
            print( mod)
            print( dir(mod))
            print( 'VERSION vvv')
            print( mod.__version__)
            print( 'VERSION ^^^')
            print( '='*80)
            return mod
          print( mod)
          print( dir(mod))
          a+=1
          if a == max_a:
            a=0
            b+=1
          if b == 5:
            break

      print( '*'*80)
    except IndexError as e:
      break
    i+=1

def traceCaller():
    i=0
    while i < 10:
        try:
            frame,filename,line_number,function_name,lines,index=\
                inspect.getouterframes(inspect.currentframe())[i]
            if (filename != __file__):
                a=0
                b=0
                max_a=max_b=10
                while a < max_a: 
                    try:
                        frm = inspect.stack()[a]
                    except IndexError as e:
                        max_a = a
                    mod = inspect.getmodule(frm[b])
                    if mod.__file__ != __file__:
                        return mod
                    a+=1
                    if a == max_a:
                        a=0
                        b+=1
                    if b == max_b:
                        break
        except IndexError as e:
            break
        i+=1
    return None

def logging_file_descriptors():
  ''' logging file descriptors are used in core.Service.daemonize() '''
  return [handler.stream.fileno() for handler in [wr() for wr in
      logging._handlerList] if isinstance(handler, logging.FileHandler)]

def unique(L):
  '''
  ret = []
  for l in L:
    if l not in ret: ret.append(l)
  return ret
  '''
  return list(set(L))

def microtime(dt=None):
  """ simple microtime function that can take in a datetime timestamp to ret
  the microtime for, returns the microtime right now. """
  dt = dt or datetime.datetime.now()
  return (dt - datetime.datetime.utcfromtimestamp(0)).total_seconds()

def tolen(instr, i=80):
  """ Reads the input string :instr: and reformatts to an specified length :
  """
  lines = []; line = []
  for word in instr.split(' '):

    while len(word) >= 1 and word[0:2] in ("\\n","\n",'\n'):
      lines.append("\n")
      word = word[2:]

    if len('%s %s' % (' '.join(line), word)) > i:
      lines.append(' '.join(line))
      line = [word]
    else:
      if word.startswith('\n'):
        lines.append(' '.join(line))
        line = [word]
      else:
        line.append(word)
  if line:
    lines.append(' '.join(line))
  return '\n'.join(lines)

def mbool(val, default=True):
  if not val:
    return False
  val = str(val).strip()
  if not val:
    return False
  if val.upper() in ['NONE', 'FALSE', '0']:
    return False
  if val.upper() in ['TRUE', '1', 'YES']:
    return True
  return default

def identify_sections(cfile=COBJ, filename=None):
  if filename and filename.strip():
    if os.path.exists(filename):
      cfile = COBJ.load(filename)
    else:
      raise FileNotFound("The config file does not exist, no sections will be able to be found in a non-existant file.")
  sections=[]
  for k,v in cfile.items():
    if str(type(v)) == "<class 'pylib.configobj.Section'>":
      sections.append((k,v))
  return sections

def get_section(sections, section_key):
  for section, sub in sections:
    if section == section_key:
      return sub
  return None

def relative_date(date=datetime.datetime.now(),years=None,months=None,weeks=None,days=None,hours=None,minutes=None):
  if hours or minutes:
    raise FutureFeature("Not coded yet.")
  if years or years==0:
    year = date.year+years
    return datetime.date(year,date.month,day)
  elif months or months==0:
    acceptable_date = datetime.datetime(date.year,date.month,1)
    while int(months) != 0:
      acceptable_date = acceptable_date-datetime.timedelta(days=20)
      acceptable_date = datetime.datetime(acceptable_date.year,acceptable_date.month,1)
      if months < 0: months=months+1
      else: months=months-1
    return date.replace(year=acceptable_date.year,month=acceptable_date.month,day=date.day)
  elif weeks or weeks==0:
    return date+datetime.timedelta(days=7*weeks)
  elif days or days == 0:
    if days > 0: # positive number of days
      return date+datetime.timedelta(days=days)
    else: # negative number of days
      # oops, wound up with a double negative, passing a negative date in, and
      # subtracting it.  Need to add here too. I could just leave this as a
      # one-liner without the above IF/ELSE but for clarity on what is going
      # on, or for copy/pasting into the other switch cases, I am going to
      # leave it (for now).
      return date+datetime.timedelta(days=days)
    pass
  elif hours:
    pass
  elif minutes:
    pass
  else:
    pass
  raise ProgrammingError("PyTis.relative_date() -- You must specify one of the following: years,months,weeks,days,hours or minutes.")

def trim(item):
  """
  """
  if type(item) == type(str('')):
    if item: item=item.strip()
    else: item = ''
  elif type(item) == type([]):
    return [f.strip() for f in item]
  elif type(item) == type(dict()):
    newdict = {}
    for k,v in item.items():
      newdict[k]=trim(v)
    return newdict
  else:
    if not item:
      item = ''
  return item

def die(string=None):
  global log
  try:
    if log and string:
      log.fatal(string)

  except NameError:
    if string:
      print("output: '%s'" % string)
  else:
    if not log and string:
      print("output: '%s'" % string)

  sys.exit()
DIE=Die=die

def protect(s,trim_len=4):
  """ padd a password and only show the remaining "trim_len" 
  example: protect('this now', 2) >> '******ow'
  example: protect('my password', 0) >> '**********'
  """
  global log
  if type(s) is type(None):
    return "''"
  if len(s) == 0:
    return "''"
    #return '*'*8
  elif trim_len >= len(s):
    log.warn("Programming error in PyTis.protect; trim len passed is " \
      "actually longer than string passed.")
    return '*'*len(s)
  else:
    return '%s%s'%('*'*(len(s)-trim_len),s[(len(s)-trim_len):])

def num2col(num):
  ''' Turns a numeric representation of a column into a MS Excel Column title.
  EXAMPLES:
    0 returns A,
    25 returns Z,
    26 returns AA,
    51 returns AZ 
    and 52 returns BA.
  '''
  col = []
  while True:
    remain =  num % 26
    col.append(chr(int(ord('A') + remain)))
    num = (num - remain) / 26 - 1
    if num < 0:
      break
  return ''.join(reversed(col))

def is_int(x):
  try: 
    int(x)
  except:
    return False
  else:
    return True

col2num = lambda col: reduce(lambda x, y: x*26 + y, [ord(c.upper()) - ord('A') + 1 for c in col])
''' Turns a MS Excel Column title into  a numeric representation of a column.
EXAMPLES:
  A return 0,
  Z returns 25,
  AA returns 26,
  AZ returns 51,
  and BA returns 52.
'''
#lipColumn = lambda thing: if not thing: return 0

def column(str_or_int):
  try:
    return int(str_or_int)
  except ValueError:
    return col2num(str_or_int)-1

def simpleDecode(s=''):
  bencoded_txt = s.strip().encode('ascii')
  try:
    bdecoded_txt = b64.b64decode(bencoded_txt)
  except TypeError as e:
    raise InputError("Invalid encoded input:  This is likely caused by a " \
      "malformed encrypted password, usually an incorrect length.")
  return bdecoded_txt.decode('ascii')

def simpleEncode(s=''):
  bencoded_txt = s.strip().encode('ascii')
  return (b64.b64encode(bencoded_txt).decode('ascii'))

ireplace=lambda f,r,s: re.sub(r'(?i)%s'%str(f),str(r),str(s))

def sendEmail(body, subject, to, mfrom, cc, host=None, local_hostname=None,
  port=25, timeout=20):
  global log

  from email.mime.text import MIMEText
  import smtplib
  import socket

  msg=MIMEText(body)
  msg['Subject'] = subject

  if type(to) is type([]) or type(to) is type(()):
    to=';'.join(to)
  else:
    to=';'.join(to.split(','))

  msg['To'] = to 

  msg['From'] = mfrom

  if cc: msg['CC'] = cc

  if local_hostname is None: local_hostname = os.uname()[1]

  if host is None:
    host_attempts = ['localhost','127.0.0.1']
  elif host.lower() == 'localhost':
    host_attempts = ['localhost','127.0.0.1']
  else:
    host_attempts = [host]

  for host in host_attempts:
    log.debug("smtplib.SMTP(host='%s',port=%s," \
      "local_hostname='%s',timeout=%s) - %s" % (host,port,
      local_hostname, str(long(timeout)), subject))
    try:
      s = smtplib.SMTP(host=host,port=port,
        local_hostname=local_hostname,timeout=timeout)
      s.sendmail(msg['From'],msg['To'],msg.as_string())
      s.quit()

      log.debug('smtplib Instantiated with no errors - %s' % subject)

    except socket.error as e:
      log.debug('socket.error caught, continuing: %s - %s' % (str(e), subject))
      return False
    else:
      log.debug('To: %s, CC: %s, FROM: %s; s.sendmail successfull - %s' % \
        (msg['To'], msg['CC'], msg['From'], subject))
      return True
  else:
    log.error("Incorrect mail host and/or local_hostname " \
    "provided, sendmail failed - %s " % subject)
    return False

def add_os_touch():
  if not getattr(os,'touch',None):
    if sys.version_info >= (3, 3) and sys.version_info < (3,6):
      def touch(fname, *largs,**kwargs):
        if os.path.isfile(fname) and os.path.exists(fname): return False
        open(fname, 'w+').close()
        return True

    elif sys.version_info >=(3, 3):
      def touch(fname, mode=0o666, dir_fd=None, **kwargs):
        if os.path.isfile(fname) and os.path.exists(fname):
          return False
        flags = os.O_CREAT | os.O_APPEND
        with os.fdopen(os.open(fname, flags=flags, mode=mode, dir_fd=dir_fd)) as f:
          os.utime(f.fileno() if os.utime in os.supports_fd else fname,
            dir_fd=None if os.supports_fd else dir_fd, **kwargs)
        return True

    else:
      def touch(fname, times=None):
        if os.path.isfile(fname) and os.path.exists(fname): return False
        with file(fname, 'a'):
          os.utime(fname, times)
        return True
    os.touch = touch


if not getattr(os,'touch',None):
  add_os_touch()

def main(): #global __version__
  #hello()
  print("PyTis toolkit library, version: %s" % str(__version__))

if __name__ == '__main__': 
  sys.exit(main())



