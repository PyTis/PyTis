#!/usr/bin/env python
# -*- coding: ISO-8859-1 -*-
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 1.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#  http://www.PyTis.com/License/                                               #
#                                                                              #
#  Copyright (c) 2015 Josh Lee                                                 #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 05:54 06 Jun, 2015            #
############################################################################## #
"""copyright
=========
This tool will automatically edit files and add your copyright loaded from a 
template.  The use of this "template" can be over-ridden using the -t flag.

Features:
  *  Will not add copyright to file twice.
  *  Can determine best comment char to use for ini, html, php, and python.
  *  Manages multiple copyrights.
  *  Creates default copyright for you.

"""
import datetime
import glob
import optparse
import os
import shutil
import sys
import pytis.pytis as PyTis

import configure as pytis_configure # (imports configdir and logdir)

__author__ = 'Josh Lee'
__created__ = '06:14pm 09 Sep, 2009'
__modified__ = '12:14pm 09 Mar, 2020'
__copyright__ = 'PyTis'
__version__ = '3.0'

def defaultTemplate():
  return """The contents of this file are subject to the PyTis Public License Version
3.0 (the "License"); you may not use this file except in compliance with
the License. You may obtain a copy of the License at

    http://www.PyTis.com/License/
    
    Copyright Â© {year} Josh Lee 

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the
License.
"""

def createDefault(write_to):
  try:
    fpath = os.path.abspath(os.path.join(write_to,'default.txt'))
    handle = open(fpath,'w')
    handle.write(defaultTemplate())
    handle.close()
  except OSError as e:
    print('The copyright program has attempted to create a default ' \
      'template, but has received an error.')
    print(str(e))
    sys.exit(1)


if PyTis.is_root():
  # simple, the directory is '/etc/pytis/.mycopyright'
  __configdir__ = '/etc/pytis/.mycopyright'

  if not os.path.exists(__configdir__):
    try:
      os.makedirs(__configdir__)
      print("Template dir created.")
    except OSError as e:
      print('The "copyright" program requires a template directory to exist.')
      print('It has attempted to create "%s", but an error occured.' % \
        __configdir__)
      print(str(e))
      print("\nPlease manually create the template dir at '%s' and try again.")
      sys.exit(1)
    else:
      createDefault(__configdir__)
else:
  # okay, it is a user,
  __configdir__ = os.path.abspath(os.path.join(PyTis.homedir(),
    '.mycopyright'))
  if not os.path.exists(__configdir__):
    # the user's .mycopyright dir doesn't exist, can they use a root one?
    if os.path.exists('/etc/pytis/.mycopyright'):
      __configdir__ = '/etc/pytis/.mycopyright'
      # does the default template exist?
    else:
      try:
        __configdir__ = os.path.abspath(os.path.join(PyTis.homedir(),
          '.mycopyright'))

        os.mkdir(__configdir__)
        createDefault(__configdir__)
      except OSError as e:
        print('cannot create copyright config path.')
        sys.exit(1)
      else: 
        print('default copyright created at: %s' % \
          os.path.abspath(os.path.join(__configdir__, 'default.txt.')))

comment_chars = {'php'      :  {'begin'  : '/*',
                  'middle' : '//',
                  'end'  : '*/',
                  'bin'  : 'php',
                  'ext'  : ['.php','.php4','.php5', 
                        'phtml']},
         'javascript'   :  {'begin'  : '/*',
                  'middle' : '//',
                  'end'  : '*/',
                  'bin'  : None,
                  'ext'  : ['.js']},
         'bash'      :  {'begin'  : '#',
                  'middle' : '#',
                  'end'  : '#',
                  'bin'  : 'bash',
                  'ext'  : ['.sh']},
         'vim'      :  {'begin'  : '"" ',
                  'middle' : '""',
                  'end'  : ' ""',
                  'bin'  : 'vim',
                  'ext'  : ['vimrc']},
         'sh'      :  {'begin'  : '#',
                  'middle' : '#',
                  'end'  : '#',
                  'bin'  : 'sh',
                  'ext'  : ['.sh']},
         'ini'      :  {'begin'  : ';',
                  'middle' : ';',
                  'end'  : ';',
                  'bin'  : None,
                  'ext'  : ['.ini']},
         'python'     :  {'begin'  : '#',
                  'middle' : '#',
                  'end'  : '#',
                  'bin'  : 'python',
                  'ext'  : ['.py', '.pyw']},
         'html'     :  {'begin'  : '<!-- ',
                  'middle' : '-',
                  'end'  : ' -->',
                  'bin'  : None,
                  'ext'  : ['.html','.htm','.shtml',
                        '.dhtml','.xml']},
         'css'      :  {'begin'  : '/*',
                  'middle' : '//',
                  'end'  : '*/',
                  'bin'  : None,
                  'ext'  : ['.css']}
}


# =============================================================================
# Begin Helpers
# -----------------------------------------------------------------------------

# I like this way more, but the other is easier to understand
def func(method):
  global comment_chars
  def _(func):
    comment_chars[func.__name__][method] = func
  return _

def apply(func):
  global comment_chars
  comment_chars[func.__name__]['apply'] = func

def check(func):
  global comment_chars
  comment_chars[func.__name__]['check'] = func

# -----------------------------------------------------------------------------
# End Helpers
# =============================================================================

# =============================================================================
# Begin Check Functions
# -----------------------------------------------------------------------------

def generic_check(fi,cp,lang):
  global comment_chars
  pcp = prettyCopyright(cp, comment_chars[lang])

  handle = open(fi,'r')
  lines = handle.readlines(-1)
  handle.seek(0)
  body = handle.read(-1)
  handle.close()

  if pcp in body:
    raise PyTis.DuplicateCopyright("This file already has been " \
          "copyrighted with an identical copyright." )
  for line in lines:
    if 'copyright' in line.lower() or 'license' in line.lower():
      if comment_chars[lang]['begin'] in line or \
        comment_chars[lang]['middle'] in line:
        return False 
  else:
    return True

@check
def javascript(fi,cp):
  return generic_check(fi,cp,'javascript')

@check
def python(fi,cp):
  return generic_check(fi,cp,'python')

@check
def css(fi,cp):
  return generic_check(fi,cp,'css')

@check
def sh(fi,cp):
  return generic_check(fi,cp,'sh')

@check
def bash(fi,cp):
  return generic_check(fi,cp,'bash')

@check
def vim(fi,cp):
  return generic_check(fi,cp,'vim')

@check
def ini(fi,cp):
  return generic_check(fi,cp,'ini')

@check
def php(fi,cp):
  return generic_check(fi,cp,'php')

@check
def html(fi,cp):
  return generic_check(fi,cp,'html')

# -----------------------------------------------------------------------------
# End Check Functions
# =============================================================================

# =============================================================================
# Begin Apply Functions
# -----------------------------------------------------------------------------
@apply
def javascript(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)

  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['javascript'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:
      lines=PyTis.dos2unix(lines)
      #nhandle.write(bytes(pcp, encoding='ISO-8859-1'))
      nhandle.write(pcp)
      nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

@apply
def ini(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)

  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['ini'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:
      lines=PyTis.dos2unix(lines)
      nhandle.write(pcp)
      nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

@apply
def css(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)

  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['css'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:
      lines=PyTis.dos2unix(lines)
      nhandle.write(pcp)
      nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

@apply
def html(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)

  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['html'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:
      lines=PyTis.dos2unix(lines)

      # BEGIN HANDLE SHEBANG
      if '<!DOCTYPE' in lines[0]: # Kinda like the shebang line, 
                    # but could take a few lines.
        inline = 0
        while inline < len(lines):
          inline +=1
          if '>' in lines[inline]:
             break

        nhandle.writelines(lines[0:inline])
        nhandle.write(pcp)
        nhandle.writelines(lines[inline:])
      # END HANDLE SHEBANG

      else:
        nhandle.write(pcp)
        nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

@apply
def vim(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)

  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['vim'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:
      lines=PyTis.dos2unix(lines)
      nhandle.write(pcp)
      nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True


@apply
def bash(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)
  
  # little fix for encoding bug,...
  cp = cp.replace("\xa9", "(c)")


  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['bash'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:

      lines=PyTis.dos2unix(lines)
      # BEGIN HANDLE SHEBANG
      if lines[0].startswith('#!/'): # shebangline
        nhandle.write(lines[0])
        nhandle.write(pcp)
        nhandle.writelines(lines[1:])
      # END HANDLE SHEBANG

      else:
        nhandle.write(pcp)
        nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

@apply
def sh(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)
  
  # little fix for encoding bug,...
  cp = cp.replace("\xa9", "(c)")


  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['sh'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:

      lines=PyTis.dos2unix(lines)
      # BEGIN HANDLE SHEBANG
      if lines[0].startswith('#!/'): # shebangline
        nhandle.write(lines[0])
        nhandle.write(pcp)
        nhandle.writelines(lines[1:])
      # END HANDLE SHEBANG

      else:
        nhandle.write(pcp)
        nhandle.writelines(lines[0:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True


@apply
def python(fi,cp):
  global comment_chars

  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)
  
  # little fix for encoding bug,...
  #cp = cp.replace("\xa9", "(c)")


  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['python'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      print('a')
      sys.exit()
      #nhandle.write(bytes(pcp, encoding='ISO-8859-1'))
      nhandle.write(pcp)
    # END HANDLE EMPTY

    else:

      lines=PyTis.dos2unix(lines)
      # BEGIN HANDLE SHEBANG
      if lines[0].startswith('#!/'): # shebangline
        # BEGIN HANLDE ENCLDING LINE, WITH SHEBANG LINE
        if lines[1].startswith('# encoding='):
          nhandle.write(lines[0]) # copy shebangline
          nhandle.write(lines[1]) # copy encoding
          #nhandle.write(bytes(pcp, encoding='ISO-8859-1'))
          nhandle.write(pcp) # place copyright
          nhandle.writelines(lines[2:]) # write everythign else
        # END HANLDE ENCLDING LINE, WITH SHEBANG LINE
        else:
          nhandle.write(lines[0]) # copy shebang
          #nhandle.write(bytes(pcp, encoding='ISO-8859-1'))
          nhandle.write(pcp) # place copyright
          nhandle.writelines(lines[1:]) # write everything else
      # END HANDLE SHEBANG
      else:
        # BEGIN HANDLE ENCODING LINE, WITHOUT SHEBANG LINE
        if lines[0].startswith('# encoding='):
          nhandle.write(lines[0]) # copy over encoding line
          #nhandle.write(bytes(pcp, encoding='ISO-8859-1'))
          nhandle.write(pcp) # place copyright
          nhandle.write(lines[1:]) # write everything else
        # END HANDLE ENCODING LINE, WITHOUT SHEBANG LINE
        else:
          # No SHEBANG, NO ENCODING
          #nhandle.write(bytes(pcp, encoding='ISO-8859-1'))
          nhandle.write(pcp) # place copyright
          nhandle.writelines(lines[0:]) # write everything else


  except Exception as e:
    print('d')
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

@apply
def php(fi, cp):
  global comment_chars
  # create a backup incase we have some error writting the backup
  backup = os.path.abspath(os.path.join(os.path.dirname(fi),
                      ".%s.bak" % os.path.basename(fi)))
  shutil.copy(fi,backup)

  # get the copyright ready
  pcp = prettyCopyright(cp,comment_chars['php'])

  try:
    handle = open(fi,'r')
    lines = handle.readlines(-1)
    handle.close()
    nhandle = open(fi,'w', encoding='ISO-8859-1')

    # BEGIN HANDLE EMPTY
    # simplest case, the file is empty.
    if not lines:
      nhandle.write("<?\n")
      nhandle.write(pcp)
      nhandle.write("?>\n")
    # END HANDLE EMPTY

    else:

      lines=PyTis.dos2unix(lines)
      # BEGIN HANDLE SHEBANG
      if lines[0].startswith('#!/'): # shebangline
        nhandle.write(lines[0])
        # prevent IndexError # strip \n and \S|\s|\t|\w
        if len(lines)>2 and lines[1] and lines[1].lower().strip() in \
        ("<?","<?\n","<?php","<?php\n"):
          nhandle.write(lines[1])
          nhandle.write(pcp)
          nhandle.writelines(lines[2:])
        else:
          nhandle.write("<?php\n")
          nhandle.write(pcp)
          if len(lines) <= 2:
            nhandle.write("?>")
          else:
            nhandle.write("?>\n")
          nhandle.writelines(lines[1:])
      # END HANDLE SHEBANG
      
      # BEGIN HANDLE FILE STARTS IN HTML, or something other than PHP
      elif lines[0].find("<?") == -1:
        nhandle.write("<?\n")
        nhandle.write(pcp)
        nhandle.write("?>\n")
        nhandle.writelines(lines[0:])
      # END HANDLE FILE STARTS IN HTML, or something other than PHP

    # 3 cases left to handle, 
    # a <? on first line by itself
    # b <? on a line with code
    # c <? on a line that also has ?>
      
      # case c ( easier to do case b with an else
      elif '<?' in lines[0].strip() and '?>' in lines[0].strip():
        # just in case the are doing <?=$foo?> well just insert it on line 0
        nhandle.write("<?\n")
        nhandle.write(pcp)
        nhandle.write("?>\n")
        nhandle.writelines(lines[0:])

      # case a
      elif lines[0].strip() in ['<?', '<?php', '<?php4', '<?php5']:
        nhandle.write(lines[0])
        nhandle.write(pcp)
        nhandle.writelines(lines[1:])
        

      else: 
        nhandle.write("%s\n" % lines[0].split()[0])
        nhandle.write(pcp)
        nhandle.write("\n%s\n" % ' '.join(lines[0].split()[1:]))
        nhandle.writelines(lines[1:])

  except Exception as e:
    print(e)
    # we messed up, restore from backup
    try:
      handle.close()
    except:
      pass
    try:
      nhandle.close()
    except:
      pass
    shutil.move(backup, fi)
    raise Exception(e)
  else:
    nhandle.close()
    os.unlink(backup)
    return True

# -----------------------------------------------------------------------------
# End Apply Functions
# =============================================================================

# =============================================================================
# Begin Copyright / License Applying functions
# -----------------------------------------------------------------------------

def loadCopyright(opts):
  """
  Load a copyright from one of the template files.  Present a warning 
  if the file is empty.
  """
  global log

  fi = tpath(opts,opts.file==None)
  log.debug("template path: %s" % fi)
  try:
    handle = open(fi,'r',encoding='ISO-8859-1')
  except (IOError, OSError) as e:
    raise PyTis.FileNotFound('Template not found: %s' % fi)

  body = handle.read(-1)
  handle.close()
  if not body.strip():
    raise PyTis.EmptyTemplate("ERROR! The copyright template loaded " \
      "was empty.  Template file: %s" % os.path.abspath(fi))
  else:
    body = PyTis.ireplace('%(year)s',datetime.datetime.now().year,body)
    body = PyTis.ireplace('{year}',datetime.datetime.now().year,body)
    try:
      body = body % dict(year=datetime.datetime.now().year)
    except:
      pass

  body = "%s\n@auto-generated by the PyTis Copyright Tool on %s" % (body, 
        datetime.datetime.now().strftime("%I:%M %p - %d %b, %Y"))
  return body, fi

def prettyCopyright(cp,d):
  """ 
  Using data provided in the comment_chars, format the Copyright already
  loaded for it's filetype.
  """

  b = PyTis.StringIO()
  b.write(str("%s %s" % (d['begin'], d['middle']*80))[:80])
  b.write("\n")
  for line in cp.split("\n"):
    b.write("%s %s %s" % (d['middle'], 
              line.ljust(78- len(d['middle']*2) ),
              d['middle']))
    b.write("\n")

  b.write(str("%s %s" % (d['middle']*80, d['end']))[-80:])
  b.write("\n")
  return b.getvalue()

def fileType(fi):
  """ 
  For the given file :fi: find and return the dict object associated with
  this file defined in the above comment_chars.  If none is found return 
  none.
  """
  def tryShebang(fi):
    # try to find a shebang line
    handle = open(os.path.abspath(fi),'r')
    lines = handle.readlines(-1)
    if lines:
      line = lines[0]
      for k,v in comment_chars.items():
        if v['bin'] and v['bin'] in line:
          return k,v

    return None, None

  try:
    ext = os.path.splitext(fi)[-1:][0]
  except IndexError as e:
    # no file extention, last resort
    return tryShebang(fi)

  for k,v in comment_chars.items():
    if ext in v['ext']:
      return k,v
      
  # not found in our data def comment_chars, try to find a shebang line
  return tryShebang(fi)

def checkCopyright(fi,data,cp):
  """
  dispatch to correct checking func
  :fi: file in question
  :data: a bag of information about that file's language from comment_chars
  :cp: a copyright
  """
  return data['check'](fi,cp)

def applyCopyright(fi, data, cp):
  """
  For the given file :fi: insert the copyright text :cp: using the 
  appropriate comment strings defined in comment_chars and returned by the
  FileType function.
  """
  return data['apply'](fi,cp)

def copyright(opts,args):
  """ 
  Do the nasty
  Errors to catch:
    class DuplicateCopyright(UserWarning): pass
    class EmptyTemplate(FileNotFound): pass
    class FileNotFound(UserWarning): pass
    class IdiotError(Exception): pass
    class QuitNow(Exception): pass
  """
  global log
  cp, cpfile = loadCopyright(opts)
  files = PyTis.filesFromArgs(opts, args)
  files = [f for f in files if not f.endswith('.swo') and \
    not f.endswith('.bak') and \
    not f.endswith('.pyc') and \
    not f.endswith('.swp') and \
    not f.endswith('.htaccess')]
  files.sort()

  log.debug("FILES: %s" % files)

  if not files:
    raise PyTis.IdiotError("No files to copyright")

  force = False # if the user wants to force all
  fix = [] # a list of files that the user might want to check latter.a

  if cpfile in files or os.path.abspath(sys.argv[0]) in files:
    # The cannot copyright a the template file that the copyright was
    # loaded from, nor can they copyright this program, hell, they didn't
    # write it, I did.
    raise PyTis.IdiotError("These files may not be copyrighted.")

  def checkFoo():
    # XXX-TODO - fix this below from get_input to getInputYN
    #c = PyTis.getInputYN('[y/N/a (always) or q to quit] >>>').lower()
    c = PyTis.get_input('[y/N/a (always) or q to quit] >>>').lower()
    if c not in ['y','n','q','a']:
      return checkFoo()
    if c == 'q':
      log.debug('user input quit')
      raise PyTis.QuitNow("User pressed quit.")
    return c

  
  for f in files:
    ftype, data = fileType(f)
    log.debug("File: %s" % f)
    log.debug("ftype: %s" % ftype)
    log.debug("data: %s" % data)

    if not ftype:
      msg = 'Skipping un-known filetype for: %s' % f
      log.debug(msg)
      print(msg)
      continue
    try:
      if opts.preview:
        PyTis.clearScreen()
        if not preview(f):
          log.info("User skipped: %s" % os.path.abspath(f))
          continue # user entered 's' to skip
        if wantToApply(f):
          if checkCopyright(f,data,cp):
            log.info("Copyright Applied.")
            applyCopyright(f,data,cp)
          else:
            msg = "\nThis file appears to already have a copyright, " \
                "do you wish to add one anyway?\n\t%s" % f
            print(msg)
            log.debug(msg)
            c = checkFoo()
            if c == 'n':
              log.debug('user input no')
              continue
            elif c == 'a':
              log.debug('user input always')
              force = True
              applyCopyright(f,data,cp)
            elif c == 'y':
              log.debug('user input yes')
              applyCopyright(f,data,cp)
        else:
          log.info("%s skipped." % os.path.abspath(f))

      elif checkCopyright(f,data,cp):
        applyCopyright(f,data,cp)
      else:
        fix.append(f)
        if force:
          applyCopyright(f,data,cp)
        else:
          msg = "\nThis file appears to already have a copyright, " \
              "do you wish to add one anyway?\n\t%s" % f
          print(msg)
          log.debug(msg)
          c = checkFoo()
          if c == 'n':
            log.debug('user input no')
            continue
          elif c == 'a':
            log.debug('user input always')
            force = True
            applyCopyright(f,data,cp)
          elif c == 'y':
            log.debug('user input yes')
            applyCopyright(f,data,cp)
    
    except PyTis.DuplicateCopyright as e:
      log.info("duplicate, skipping: %s" % f)
      print('%s\nSkipping: %s' % (e,f))
    except PyTis.QuitNow as e:
      print("\n%s\n\nOkay, bye!" % str(e))
      return False
  return fix

# -----------------------------------------------------------------------------
# End Copyright / License Applying functions
# =============================================================================

# =============================================================================
# Begin Path helper functions
# -----------------------------------------------------------------------------
def tpath(opts, default=False):
  """
  template file path with file name
  """
  global __configdir__
  if default:
    return os.path.abspath(os.path.join(__configdir__,'default.txt'))
  return os.path.abspath(os.path.join(__configdir__,"%s.txt" % \
  opts.file.strip().replace(' ', '_')))

def efpath(opts, default=False):
  """
  edit template file path with file name
  """
  global __configdir__
  if default:
    return os.path.abspath(os.path.join(__configdir__,'default.txt'))
  return os.path.abspath(os.path.join(__configdir__,"%s.txt" % \
  opts.edit.strip().replace(' ', '_')))

def nfpath(opts, default=False):
  """
  new template file path with file name
  """
  global __configdir__
  if default:
    return os.path.abspath(os.path.join(__configdir__,'default.txt'))
  return os.path.abspath(os.path.join(__configdir__,"%s.txt" % \
  opts.new.strip().replace(' ', '_')))

# -----------------------------------------------------------------------------
# End Path helper functions
# =============================================================================

# =============================================================================
# Begin Copyright creation / editing functions
# -----------------------------------------------------------------------------
def show(opts):
  try:
    cr, path= loadCopyright(opts)
  except (PyTis.EmptyTemplate, PyTis.FileNotFound) as e:
    print(str(e))
    sys.exit(1)
  print(cr)
  return 

def tList(opts):
  global __configdir__
  print("Available Templates")
  print("===================")
  print
  i =1
  temps = {}
  for f in glob.glob(os.path.join(__configdir__,'*.txt')):
    n = os.path.basename(f).replace('.txt','')
    temps[str(i)]=n
    print(" %s) %s" % (i,n))
    i+=1
  print("\nEnter a template number to edit, or any other key to quit")
  res = PyTis.get_input('>>> ').strip()

  if res in temps.keys():
    opts.edit = temps[res]
    fi = efpath(opts, False)
    print('About to edit: %s' % fi)
    PyTis.toContinue()
    return edit(fi, direct=True)
  else:
    return True

def createDefault(opts, fi=None):
  """The contents of this file are subject to the YOUR COMPANY Public License Version
1.0 (the "License"); you may not use this file except in compliance with
the License. You may obtain a copy of the License at

  http://www.YOURSITE.com/License/
  
  Copyright \xa9 %s YOUR NAME

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the
License."""
  global __configdir__  
  if fi is None:
    fi = nfpath(opts, opts.new==None)
  if os.path.isfile(fi) and os.path.exists(fi):
    print("ERROR: A template with this name already exists in: %s.\n\n" \
    "**Please rename or remove this file first.\n" % __configdir__)
    return PyTis.toContinue()

  handle = open(fi, 'w', encoding='ISO-8859-1')
  txt = createDefault.__doc__ % datetime.datetime.now().year
  handle.writelines(txt)
  handle.close()
  print('The template "%s" has been created.' % fi)
  edit(fi, direct=False)

def edit(fi, direct=False):
  """
  Allows the user the option to edit a license/copyright template.
  """
  global log
  ed = os.environ.get('EDITOR', os.environ.get('VISUAL')) 
  if not ed: ed = get_editor()
  if direct:
    if ed:
      os.system("%s %s" % (ed, fi))
    else:
      print('You may edit "%s" at any time.' % fi)
    return PyTis.toContinue()
  else: 
    if PyTis.get_input('Would you like to edit the license/copyright '
           'now? [y/N]').lower() in ['y','yes']:
      if ed:
        os.system("%s %s" % (ed, fi))
        print('This license is now ready.')
      else:
        print('You may edit "%s" at any time.' % fi)
      return PyTis.toContinue()

    print('You may edit "%s" at any time.' % fi)
    return PyTis.toContinue()


def preview(fi):
  """
  Allows the user the option to edit a license/copyright template.
  """
  global log

  ed = os.environ.get('EDITOR', os.environ.get('VISUAL')) 
  if ed:
    if not myContinue(fi):
      return False
    os.system("%s %s" % (ed, fi))
  else:
    log.error('No editor could be found.')
    raise PyTis.QuitNow()
  return True

# -----------------------------------------------------------------------------
# End Copyright creation / editing functions
# =============================================================================


# =============================================================================
# Begin Installation / Configuration Functions
# -----------------------------------------------------------------------------

def removeConfigDir(opath):
  for f in glob.glob(os.path.join(opath,'*.txt')):
    os.remove(f)
  try:
    os.rmdir(opath)
  except OSError as e:
    print
    print('ERROR:')
    print('Could not remove direcotry %s, this folder contains user files.')
    print

def addConfigDir(d):
  global log  
  if PyTis.get_input('Create directory %s [y/N]: ' % d).lower().strip() == 'y':
    try:
      os.makedirs(d)
    except OSError as e:
      if 'File exists' in str(e):
        return True
      elif 'Permission denied' in str(e):
        log.warn('ERROR: You do not have permission to create this ' \
            'directory.')
        return False
      else:
        log.error(str(e))
        return 
    else:
      return True
  else:
    return False


def setConfig(d):
  global __configdir__
  mpath = os.path.abspath(sys.argv[0])
  handle = open(mpath, 'r')
  lines = handle.readlines(-1)
  handle.close()
  nfile_lines = []
  for line in lines:
    if line.startswith('__configdir__'):
      line = "__configdir__ = '%s'\n" % d
    nfile_lines.append(line)

  handle = open(mpath,'w', encoding='ISO-8859-1')
  handle.writelines(nfile_lines)
  handle.close()
  
def testConfig():
  global __configdir__
  if not __configdir__.strip() or \
  not os.path.exists(os.path.abspath(__configdir__)) or \
  not os.path.isdir(os.path.abspath(__configdir__)):
    return False
  return True

def config(opts):
  global __configdir__

  print
  oldpath=''
  if __configdir__:
    oldpath = os.path.abspath(__configdir__)
  
  if __configdir__.strip()  and os.path.isdir(oldpath) and \
    os.path.exists(oldpath):

    print('CONFIG DIR was already set to: %s' % oldpath)
    if PyTis.get_input('Remove old CONFIG DIR? [y/N]').lower().strip() == 'y':
      removeConfigDir(oldpath)

  if PyTis.is_root():
    default_configdir = os.path.abspath(os.path.join(PyTis.__configdir__,
      '.mycopyright'))
  else:
    default_configdir = os.path.abspath(os.path.join(PyTis.homedir(),
      '.mycopyright'))

  newpath = default_configdir
  print('DEFAULT: %s' % newpath)
  print("Path to data dir (leave blank to use default) q to quit ")
  configdir = PyTis.get_input('>>>')
  if not configdir.strip():
    configdir = newpath

  if configdir == 'q':
    return sys.exit(0)
  if not addConfigDir(configdir):
    print("\nPlease try again.")
    return config(opts)
  else:
    setConfig(configdir)
    createDefault(opts,
      os.path.abspath(os.path.join(configdir,'default.txt')))

# -----------------------------------------------------------------------------
# End Installation / Configuration Functions
# =============================================================================
def get_editor():
  if sys.platform in ('win32', 'win64'):
    return 'notepad.exe'
  else:
    for line in os.popen('which vim').readlines(-1):
      line=line.strip()
      if line: return line
    for line in os.popen('which vi').readlines(-1):
      line=line.strip()
      if line: return line
    for line in os.popen('which nano').readlines(-1):
      line=line.strip()
      if line: return line
  return None

def wantToApply(f):
  question = "Apply copyright to: %s" %  os.path.abspath(f)
  helptext = "Now that you've previewed the file, would you like to apply " \
    "the copyright to this file? [y for Yes, n for No, q to Quit, ?/h for " \
    "this help text]"
  __input_options__=['Y','N']
  __option_always__=[]
  return PyTis.getInputYN(question,helptext,__input_options__,__option_always__)

def myContinue(fi=None):
  if fi:
    txt = "About to preview: %s\nPress ENTER to continue... (or q to quit | " \
      "or s to skip)" % os.path.abspath(fi)
  else:
    txt = "Press ENTER to continue... (or q to quit | or s to skip)"

  try:
    res = PyTis.get_input("%s>>> " % (txt))
  except (KeyboardInterrupt,EOFError) as e:
    print("\nInvalid input, press 'q' to quit or 'h' for help.")
    return myContinue()
  else:
    if res.lower().strip() == 'q':
      raise PyTis.QuitNow()
    elif res.lower().strip() == 's':
      return False
    elif res.lower().strip() in ('h','help','?'):
      print('Enter "h" for help, "q" to quit, "s" to skip the file, or ' \
      'Enter to continue to the next file.')
      return myContinue(fi)
    else:
      return True


def main():
  """usage: copyright [optional: -t{TEMLATE}] [file(s)]"""
  global __configdir__,__author__,__created__,__modified__,__copyright__
  global log
  hlp = __doc__
  if '-d' in sys.argv[1:] or '--debug' in sys.argv[1:]:
    hlp = "%s\n\n%s\n**Current template dir: '%s'**\n%s" % (hlp,
        '-'*80, __configdir__, '-'*80)

  help_dict = dict(version=__version__,
             author=__author__,
             created=__created__,
             modified=__modified__,
             copyright=__copyright__)
  parser = PyTis.MyParser()
  parser.extra_txt = """
CODE:
  Flag vs. Argument:
    Flag - an option that accepts no input.
    Argument - an option that requires input.

SEE ALSO:

  copytest (soon to be renamed preview)

COPYRIGHT:

  %(copyright)s

AUTHOR:

  %(author)s

HISTORY:

  Original Author

CHANGE LOG:

  v3.0 MAJOR CHANGE                                                March 31 2020
    I realized today that if an administrator installs this package with pip, a
    user direcotry may or may-not exist.  I need to create a way to detect, and 
    SET the configdir before this program really starts.

  v2.6 MINOR CHANGE                                                 March 9 2020
    Changed Python decorated handler to now, in addition to handle shebang
    lines, it can also handle encoding lines.

  v2.5 MINOR CHANGE                                               January 8 2019
    Edited timestamp to end of copyright (@auto-generated by the PyTis...)
    line.  I had the wrong strftime variable for the day of month 
    (changed %%m to %%d).  Also added "%%p" for AM or PM, to the timestamp.
  
  v2.4 MINOR CHANGE                                             October 15, 2018
    Added error handling for missing templates when using the [-s/--show] 
    option.

  v2.3                                                           April 24, 2018
    Fixed known issue, PHP shebang bug, see "BUGS - KNOWN ISSUES" section for
    more information.
  
  v2.2 MINOR CHANGE                                               April 24, 2016
    Added in "BUGS - KNOWN ISSUES" section.

  v2.1 MINOR CHANGE                                               April 24, 2016
    Added in bash and sh file types.

  v2.0 MAJOR CHANGE                                               April 24, 2016
    Added in the [-p/--preview] Option flag to allow the user to preview the
    file first, the choose whether or not to apply the template.

  v1.5 MAJOR CHANGE                                               April 14, 2016
    Added in the [-s/--show] Option flag to allow the user to quickly 
    display a copyright template.

    No longer allows overwriting of an existing tempalte with the default one,
    if a user tries the [-n/--new] argument with an existing template name.
    This now throws a error to the user, prompting them to rename or remove 
    the existing template first.

  v1.4 MINOR CHANGE                                               March 31, 2014
    Added the ability to add a case-insensative {YEAR} variable into copyright
    templates. "{YEAR}" will be replaced with the current year.

  **
  Added in this change log
  **

  v1.3 MINOR CHANGES                                          February 26, 2012
    No documentation available; However documentation may still exist in 
    SourceForge PyTis SVN comments.
     
  v1.0 ORIGINAL RELEASE                                        September 9, 2009
    Original Publish.

EXAMPLES:  

  copyright --newMyCopyright

  copyright -tMyCopyright *.php (apply MyCopyright to all php files in this 
    directory).

  copyright *.* -r (recursively apply default copyright to all files.

  copyright -t pytis -p . (Run on all filetypes you can, in this directory,
    non-recursively, preview files first, appling the pytis template.)


BUGS - KNOWN ISSUES:

  -- fixed in v2.3
  php-cli, php files with a shebang line seem to place the copyright after the
  shebang line, before the "<?php", this will need fixed, when I have time to
  get to it. 

LAST MODIFIED:

  %(modified)s

CREATED:

  %(created)s

VERSION:

  %(version)s

"""  % help_dict

  parser.set_description(hlp)
  parser.set_usage(main.__doc__)
  parser.formatter.format_description = lambda s:s
  # ----------------------------
  parser.add_option("-D", "--debug", action="store_true", default=False, 
          help="Enable debugging")

  parser.add_option("-v", "--version", action="store_true", default=False, 
            help="Display Version")

  parser.add_option("-V", "--verbose", action="store_true",
            default=False, 
            help="Be more Verbose")

  parser.add_option("-S", "--setup", action="store_true", default=False, 
            help="Runs setup to install this script")
  # ----------------------------
  temp = optparse.OptionGroup(parser, "Template Control")
  temp.add_option("-e", "--edit", action="store", default=None,
          metavar='[NAME]',
          help="Edit an existing Copyright/License Template file "
             "using provided name.")

  temp.add_option("-l", "--list", action="store_true", default=False,
            help="List all available Copyright/License templates.")

  temp.add_option("-n", "--new", action="store", default=None,
          metavar='[NAME]',
          help="Generate a new Copyright/License Template file "
             "using provided name.")

  temp.add_option("-s", "--show", action="store", default=None,
          metavar='[NAME]',
          help="Display a Copyright/License Template file "
             "using provided name.")

  parser.add_option_group(temp)
  # ----------------------------
  prim = optparse.OptionGroup(parser, "Main")
  prim.add_option("-r", "--recursive", action="store_true", default=False,
            help="Recursively apply copyright to all files.")

  prim.add_option("-p", "--preview", action="store_true", default=False,
    metavar='preview', help="Preview each file and choose where to apply " \
      "the copyright, using the default editor.")

  prim.add_option("-t", "--file", action="store", default=None,
          metavar='[NAME]',
          help="Template file to load your copyright from.  If "
             "not specified the default will be used.")
  parser.add_option_group(prim)
  # ----------------------------

  (opts, args) = parser.parse_args()

  # Logging Configuration
  log = PyTis.set_logging(opts, 'copyright')

  log.debug("OPTS version: %s" % opts.version)
  log.debug("OPTS setup: %s" % opts.setup)
  log.debug("OPTS list: %s" % opts.list)
  log.debug("OPTS edit: %s" % opts.edit)
  log.debug("OPTS new: %s" % opts.new)
  log.debug("OPTS recursive: %s" % opts.recursive)
  log.debug("OPTS file: %s" % opts.file)


  if opts.version:
    return PyTis.version(__version__)
  try:
    if not testConfig():
      print("This tool is not configured properly, running setup.")
      __configdir__ = None
      print('INSTALLING')
      print('='*80)
      return config(opts)

    if opts.setup:
      print('INSTALLING')
      print('='*80)
      return config(opts)

    if opts.new:
      return createDefault(opts)

    if opts.edit is not None:
      fi = efpath(opts, False)
      print('About to edit: %s' % fi)
      PyTis.toContinue()
      if not os.path.exists(fi) or not os.path.isfile(fi):
        print("Template not found: '%s'" % fi)
        print("Try using the --list option to see available templates.")
        return
      return edit(fi, direct=True)

    if opts.show:
      opts.file=opts.show
      return show(opts)

    if opts.list:
      return tList(opts)
    log.debug("args: %s" % args)
    if len(args) > 0:
      try:
        fix = copyright(opts, args)
      except (PyTis.EmptyTemplate, PyTis.FileNotFound) as e:
        print(str(e))
        sys.exit(1)
      except PyTis.IdiotError as e:
        print(str(e))
      else:
        if fix:
          print('-'*80)
          print("These files might have had a different copyright, " \
              "and you might want to \ncheck these files.")
          print("\t", "\n\t".join(fix))
        return True
    return parser.print_help()

  except KeyboardInterrupt as e:
    print("\nbye!")
    return
  else:
    return

if __name__ == '__main__':
  main()

